<!DOCTYPE html>
<html>
<head>
<title>VIM: usr_05</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>USR_05</h2>
<pre>
<b class="vimtag">*<a name="usr_05.txt">usr_05.txt</a>*</b>	For Vim version 7.0.  새로고침: 2006 Apr 24

		      VIM 사용설명서 - Bram Moolenaar 저
				       심규진 역

				 설정 바꾸기


여러분이 원하는 일을 할 수 있도록 빔을 설정할 수 있습니다. 이 장에서는 다른
설정값으로 빔을 시작하는 방법에 대해 설명합니다. 플러그인을 추가하여 빔의
능력을 증대시킬 수도 있고, 여러분만의 매크로를 정의할 수도 있습니다.

|<a href="usr_05.html#05.1">05.1</a>|	vimrc 파일
|<a href="usr_05.html#05.2">05.2</a>|	예제 vimrc파일 뜯어보기
|<a href="usr_05.html#05.3">05.3</a>|	간단한 맵핑
|<a href="usr_05.html#05.4">05.4</a>|	플러그인 추가하기
|<a href="usr_05.html#05.5">05.5</a>|	도움말 파일 추가하기
|<a href="usr_05.html#05.6">05.6</a>|	옵션 창
|<a href="usr_05.html#05.7">05.7</a>|	자주 사용되는 옵션

다음 장: |<code class="badlink">usr_06</code>|  문법 강조 사용하기
이전 장: |<code class="badlink">usr_04</code>|  약간 고치기
   차례: |<a href="usr_toc.html#usr_toc.txt">usr_toc</a>|

</pre><hr><pre><b class="vimtag">*<a name="05.1">05.1</a>*</b>	vimrc 파일					<b class="vimtag">*<a name="vimrc-intro">vimrc-intro</a>*</b>

항상 똑같은 명령어를 자주 입력하는데 지쳤다면, vimrc 파일에 여러분들이
좋아하는 모든 옵션과 설정값, 키 맵핑 등을 저장하여 빔이 시작될 때에 자동으로
불러오도록 할 수 있습니다.

이미 여러분의 vimrc파일이 존재한다면 ( 예: 시스템 관리자가 여러분을 위해 미리
설정해 놓은 경우 ), 아래와 같은 방법으로 편집할 수 있습니다.:
<code class="example"></code>
<code class="example">	:edit $MYVIMRC</code>
<code class="example"></code>
여러분의 vimrc 파일이 존재하지 않는다면 어디에 vimrc 파일을 만들어야 하는지
|<code class="badlink">vimrc</code>|를 참고할 수 있습니다. 또한 ":version"명령어를 실행하면 빔이 참조하고
있는 vimrc파일들의 목록을 볼 수 있습니다.

유닉스와 매킨토시에서는 주로 아래 파일을 사용합니다.

<code class="section">	~/.vimrc </code>

MS-DOS와 MS-Windows에서는 아래 파일들 중 하나를 사용합니다.

<code class="section">	$HOME/_vimrc </code>
<code class="section">	$VIM/_vimrc </code>

vimrc 파일에는 여러분이 콜론(:) 다음에 실행할 수 있는 모든 명령어를 기재할 수
있습니다. 가장 간단한 예제는 옵션을 설정하는 것인데, 이를테면 여러분이 빔을
시작할 때 'incsearch'옵션이 켜진 상태로 시작하고 싶다면 아래 줄을 여러분의
vimrc 파일에 추가하면 됩니다.:
<code class="example"></code>
<code class="example">	set incsearch</code>
<code class="example"></code>
추가하고 난 후 빔을 다시 시작하면 옵션이 적용된 상태로 시작합니다.
재시작하지 않고 적용하는 방법은 나중에 다루도록 합니다.

이 장에서는 아주 간단한 내용만을 다룹니다. 빔 스크립트에 대한 아주 자세한
내용이 알고 싶다면 다음을 참조하기 바랍니다.: |<code class="badlink">usr_41</code>|

</pre><hr><pre><b class="vimtag">*<a name="05.2">05.2</a>*</b>	예제 vimrc파일 뜯어보기		<b class="vimtag">*<a name="vimrc_example.vim">vimrc_example.vim</a>*</b>

이 장에서는 빔 배포판과 함께 배포된 예제 vimrc파일이 비호환
모드(|<a href="usr_01.html#not-compatible">not-compatible</a>| 참조) 에서 빔을 시작할 때 어떻게 사용되는 지 설명합니다.
예제 vimrc파일은 다음 경로에서 볼 수 있습니다.

<code class="section">	$VIMRUNTIME/vimrc_example.vim </code>

이 장에서는 예제 파일에서 사용된 다양한 명령어들에 대해 설명함으로써 여러분들
나름대로의 환경을 설정하는 데 도움을 주려고합니다. 하지만 이 장에서 모든 것을
설명할 수는 없습니다. ":help" 를 이용하여 더욱 많은 것을 찾아볼 수 있습니다


<code class="example">	set nocompatible</code>
<code class="example"></code>
첫 장에서 얘기한 것처럼 이 도움말에서는 빔을 향상된 모드에서 사용할 때에 대해
설명하므로 Vi와 완벽히 호환되지 않습니다. 'compatible' 옵션을 꺼서 비호환
모드로 동작하도록 합니다.


<code class="example">	set backspace=indent,eol,start</code>
<code class="example"></code>
이 옵션은 입력 모드에서 <code class="special">&lt;BS&gt;</code> 키가 지울 수 있도록 허용된 문자들을 지정합니다.
위에 명시된 쉼표로 구분된 세가지 항목들은 각각 빔이 행 시작에 있는 공백
문자, 줄바꿈, 입력 모드가 시작되기 이전의 글자들도 지울 수 있음을 의미합니다.

<code class="example"></code>
<code class="example">	set autoindent</code>
<code class="example"></code>
이 옵션은 새로 만들어진 행이 앞 행의 들여쓰기를 따르도록 합니다.
예를 들어 입력 모드에서 <code class="special">&lt;Enter&gt;</code>키를 입력하거나 "o"키를 눌러 새 행을 만들 때
적용됩니다.

<code class="example"></code>
<code class="example">	if has("vms")</code>
<code class="example">	  set nobackup</code>
<code class="example">	else</code>
<code class="example">	  set backup</code>
<code class="example">	endif</code>
<code class="example"></code>
이 옵션을 지정하면 파일을 덮어쓰기 전에 백업본을 만들어 놓습니다. 하지만 VMS
시스템에서는 파일의 이전 버전들을 이미 보관하기 때문에 옵션을 켤 필요가
없습니다. 백업으로 만들어진 파일이름은 원래 파일 이름에 "~"가 붙습니다. 자세한
정보는 |<a href="usr_07.html#07.4">07.4</a>|를 참조하기 바랍니다.

<code class="example"></code>
<code class="example">	set history=50</code>
<code class="example"></code>
50개의 명령과 검색 패턴을 히스토리에 저장합니다. 더 많이 혹은 더 적게
히스토리를 기억하고 싶다면 이 숫자를 바꾸면 됩니다.

<code class="example"></code>
<code class="example">	set ruler</code>
<code class="example"></code>
현재 빔 창의 오른쪽 아래 귀퉁에에 항상 현재 커서의 위치를 표시합니다.


<code class="example">	set showcmd</code>
<code class="example"></code>
현재 빔 창의 왼쪽아래 귀퉁이에 아직 완성되지 않은 명령을 표시합니다. 예를 들어
여러분이 "2f"를 입력하였다면, 빔은 여러분이 추가적인 명령을 입력하기를
기다리고 "2f"가 창의 왼쪽 아래에 출력될 것입니다. "w"를 최종적으로 입력하면
"2fw" 명령이 실행되고, "2f"라는 표시가 사라집니다.

	+-------------------------------------------------+
	|<code class="badlink">text in the Vim window				  </code>|
	|<code class="badlink">~						  </code>|
	|<code class="badlink">~						  </code>|
	|<code class="badlink">-- VISUAL --			2f     43,8   17% </code>|
	+-------------------------------------------------+
	 ^^^^^^^^^^^		      ^^^^^^^^ ^^^^^^^^^^
	  '모드'		     '명령'	'커서좌표'


<code class="example">	set incsearch</code>
<code class="example"></code>
검색 패턴을 입력하는 도중에 결과를 바로 바로 보여줍니다.


<code class="example">	map Q gq</code>
<code class="example"></code>
키 맵핑을 정의합니다. 키 맵핑에 관한 자세한 내용은 다음 섹션에서 다룹니다.
"Q"명령을 "gq"명령과 똑같이 동작하도록 정의합니다. 빔 5.0 버전 이전에는 "Q"
명령이 현재의 "gq"명령과 동일하였으므로 이런 옵션이 들어 있습니다. 설정하지
않는 다면 "Q" 커맨드는 명령 모드를 실행합니다만, 여러분이 이 키를 필요로
하지는 않을 것입니다.


<code class="example">	vnoremap _g y:exe "grep /" . escape(@", '\\/') . "/ <b class="vimtag">*<a name=".c ">.c </a>*</b>.h"<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
이 맵핑은, 현재 선택된 텍스트를 복사하고, C 파일들 안에서 선택된 택스트를
검색합니다. 이처럼 복잡한 일을 하는 데도 맵핑이 사용될 수 있습니다. 이렇게
복잡해 보이는 맵핑도 단지 여러분이 입력하는 명령어의 나열일 뿐입니다.


<code class="example">	if &amp;t_Co &gt; 2 || has("gui_running")</code>
<code class="example">	  syntax on</code>
<code class="example">	  set hlsearch</code>
<code class="example">	endif</code>
<code class="example"></code>
이 스위치는 색을 사용할 수 있는 경우에, 문법 강조를 하도록 합니다. 또한
'hlsearch' 옵션은 최근에 검색한 검색 패턴과 일치하는 구문들을 강조해서
보여주도록 합니다. "if" 명령어는 조건적으로 옵션을 설정할 때 아주 유용합니다.
자세한 내용은 |<code class="badlink">usr_41</code>| 에서 다룹니다.

							<b class="vimtag">*<a name="vimrc-filetype">vimrc-filetype</a>*</b>
<code class="example">	filetype plugin indent on</code>
<code class="example"></code>
<code class="example"></code>
이 스위치는 아래 세 기능을 작동 시킵니다.
1. 파일 타입 감지
   빔은 여러분이 파일을 열 때, 파일이 어떤 종류인지를 알아내려고 합니다.
   여러분이 "main.c"라는 파일을 열었다면 빔은 ".c"라는 확장자를 보고 "c" 파일
   타입으로 인식합니다. 여러분이 "#!/bin/sh"로 시작하는 파일을 열었다면 이
   파일을 "sh" 파일 타입으로 인식합니다.
   파일 타입 감지는 문법 강조 기능과 아래의 두 기능에서 사용됩니다.
   자세한 내용은 |<code class="badlink">filetypes</code>|를 참고하시기 바랍니다.

2. 파일 타입 플러그인 사용하기
   다른 종류의 파일들은 다른 종류의 옵션으로 편집하는 것이 편리합니다. 예를
   들어 "c"파일을 편집할 때는 자동으로 들여쓰기 위해 'cindent' 옵션을 켜는
   것이 매우 유용합니다. 이렇게 자주 쓰이는 옵션 설정들은 파일 타입
   플러그인으로 빔에 포함되어 있습니다. 여러분 나름대로의 플러그인을
   추가하시려면 |<code class="badlink">write-filtype-plugin</code>|을 참조하시기 바랍니다.

3. 들여쓰기
   행의 들여쓰기를 빔이 자동으로 계산합니다. 빔은 다양한 파일타입의 인덴팅
   규칙을 알고 있습니다. |<code class="badlink">:filtype-indent-on</code>|과 'indentexpr'을
   참조하시기바랍니다.


<code class="example">	autocmd FileType text setlocal textwidth=78</code>
<code class="example"></code>
파일타입이 일반 텍스트일 경우에는 입력한 라인의 열이 78을 넘지 않도록 자동
줄바꿈 합니다. 이 명령은 두 가지 부분으로 구성되어 있습니다. "autocmd FileType
text"는 자동명령입니다. 이 명령은 파일 타입이 "text"일 경우 자동으로 다음에
오는 명령을 실행합니다. "setlocal textwidth=78"은 현재 파일에 대해서만
'textwidth'를 78로 설정합니다.

<code class="example"></code>
<code class="example">	autocmd BufReadPost *</code>
<code class="example">	    \ if line("'\"") &gt; 0 &amp;&amp; line("'\"") &lt;= line("$") |</code>
<code class="example">	    \   exe "normal g`\"" |</code>
<code class="example">	    \ endif</code>
<code class="example"></code>
이것 또한 자동 명령입니다. 이 명령은 파일을 읽어들인 직후에 실행됩니다.
'"마크가 정의되었는지 확인한 후에, 해당 마크의 위치로 이동합니다. 백슬래쉬는
여러줄에 걸친 명령을 작성할 때 사용됩니다. 한 줄이 매우 길어지는 것을 막을 수
있으며 자세한 내용은 |<code class="badlink">line-continuation</code>|을 참고하세요. 빔 스크립트 파일에서만
사용가능하며, 명령줄에 명령을 직접 입력할 때는 쓸 수 없습니다.

</pre><hr><pre><b class="vimtag">*<a name="05.3">05.3</a>*</b>	Simple mappings

맵핑은 빔 명령을 키 입력으로 실행할 수 있도록 연결하는 기능입니다. 예를 들어
 "amount"라는 단어를 "<code class="special">{amount}</code>"로 바꾸는 것 처럼 특정 단어를 중괄호로 묶는
 기능이 필요하다고 합시다. :map 명령을 이용하여 여러분이 F5키를 눌렀을 때 이
 작업을 수행하도록 할 수 있습니다:
<code class="example"></code>
<code class="example">	:map <code class="special">&lt;F5&gt;</code> i<code class="special">{<code class="special">&lt;Esc&gt;</code>ea}</code><code class="special">&lt;Esc&gt;</code></code>

	주의:
	이 명령을 입력할 때, <code class="special">&lt;F5&gt;</code>는 실제로 F5키를 누르는 것이 아니라 네개의
	글자를 각각 입력하는 것입니다. <code class="special">&lt;Esc&gt;</code>또한 마찬가지로 ESC키를 누르는
	것이 아니라 다섯 글자를 입력하는 것입니다. 매뉴얼을 읽을 때 항상 이를
	유의하시기 바랍니다.

하나하나 살펴 봅시다.
    <code class="special">&lt;F5&gt;</code>	F5 키가 눌렸을 때 명령을 실행하겠다는 의미입니다.

    i{<code class="special">&lt;Esc&gt;</code>	{ 문자를 삽입합니다. <code class="special">&lt;Esc&gt;</code>키는 입력 모드에서 빠져나오게
		합니다.

    e		커서를 단어의 끝으로 이동합니다.

    a}<code class="special">&lt;Esc&gt;</code>	단어이 끝에 }를 입력합니다.

이 명령을 실행한 뒤에는 커서를 단어 처음에 놓고 F5키만 누르면 <code class="special">{}</code>를 단어 앞뒤에
붙일 수 있습니다.

이 예제에서는 단축키가 키 하나이지만 어떤 문자열도 될 수 있습니다. 하지만 이미
빔에서 사용하고 있는 명령의 키를 사용한다면, 여러분은 해당 명령을 다시 사용할
수 없으므로 피하는 것이 좋습니다.
   맵핑에 사용될 수 있는 키들 중 하나는 백슬래쉬입니다. 여러분은 하나 이상의
맵핑을 사용하고 싶어할 것입니다. 백슬래쉬뒤에 원하는 글자를 추가하시기
바랍니다. "\p" 나 "\c" 를 다음과 같이 맵핑할 수 있습니다.
<code class="example"></code>
<code class="example">	:map \p i(<code class="special">&lt;Esc&gt;</code>ea)<code class="special">&lt;Esc&gt;</code></code>
<code class="example">	:map \c i<code class="special">{<code class="special">&lt;Esc&gt;</code>ea}</code><code class="special">&lt;Esc&gt;</code></code>
<code class="example"></code>
\를 입력하신 후 재빨리 p를 입력하시면 빔은 그 두개가 연속되어 눌렸다는 것을
인식합니다.

:map 명령을 아무런 인자 없이 실행하면 현재의 맵핑을 모두 보여줍니다. 맵핑에
관한 더욱 자세한 내용은 |<code class="badlink">40.1</code>|섹션을 참고하시기 바랍니다.

</pre><hr><pre><b class="vimtag">*<a name="05.4">05.4</a>*</b>	플러그인 추가하기					<b class="vimtag">*<a name="add-plugin">add-plugin</a>*</b> <b class="vimtag">*<a name="plugin">plugin</a>*</b>

플러그인을 추가하여 빔의 기능을 확장할 수 있습니다. 플러그인은 단지 빔이
시작할 때 실행되는 빔 스크립트 파일입니다. 여러분의 플러그인 디렉토리에 넣어
놓음으로써 간단하게 추가할 수 있습니다.
{|<code class="badlink">+eval</code>| 기능과 함께 빔이 컴파일 되었을 때만 사용 가능합니다}

플러그인에는 두 가지 형태가 있습니다.

    글로벌 플러그인: 모든 종류의 파일에 대하여 사용됩니다.
    파일 타입 플러그인: 한 종류의 파일 타입에 특화되어 사용됩니다.

글로벌 플러그인에 대하여 먼저 설명하고, 파일 타입 플러그인에 대해서는
|<a href="usr_05.html#add-filetype-plugin">add-filetype-plugin</a>|에서 설명합니다.


글로벌 플러그인						<b class="vimtag">*<a name="standard-plugin">standard-plugin</a>*</b>

빔을 시작할 때 자동으로 몇개의 글로벌 플러그인을 불러옵니다. 이 파일들은  불러오기 위해
아무 것도 할 필요가 없습니다. 빔에 컴파일 되지 않았으나 많은 사람들이 필요로
하는 기능을 제공하기 위해 빔 스크립트로 작성된 플러그인을 사용합니다. 표준
플러그인의 목록은 |<a href="help.html#standard-plugin-list">standard-plugin-list</a>|에서 확인할 수 있습니다.
|<code class="badlink">load-plugins</code>|도 참조하여 보시기 바랍니다.

							<b class="vimtag">*<a name="add-global-plugin">add-global-plugin</a>*</b>
빔을 사용하시면서 언제든지 글로벌 플러그인을 추가할 수 있습니다. 글로벌
플러그인을 추가하는 방법은 다음과 같습니다.
1. 플러그인의 복사본을 구한다.
2. 적절한 디렉토리에 넣는다.

플러그인 구하기

어디서 플러그인을 구할 수 있을까요?
- 몇 가지는 빔과 함께 배포됩니다. $VIMRUNTIME/macros와 그 하위 디렉토리들에서
  찾을 수 있습니다.
- 인터넷에서 다운로드할 수 있습니다. http://www.vim.org 에 방대한 플러그인
  모음이 있습니다.
- 빔 메일리스트 (|<code class="badlink">maillist</code>|) 에 게재되기도 합니다.
- 여러분 스스로 작성할 수도 있습니다. |<code class="badlink">write-plugin</code>|을 참고하세요.

몇 가지 플러그인은 vimball로 제공됩니다. |<code class="badlink">vimball</code>|을 참고하시기 바랍니다.
몇몇 플러그인들은 자동으로 업데이트 됩니다. |<code class="badlink">getscript</code>|를 참고하시기 바랍니다.


글로벌 플러그인 사용하기

먼저 플러그인에 특별한 조건이 있는지 문서를 읽어 봅니다.
그런 후에 플러그인 파일을 여러분의 플러그인 디렉토리에 복사해 넣으시기
바랍니다.

<code class="section">	system		plugin directory </code>
	Unix		~/.vim/plugin/
	PC and OS/2	$HOME/vimfiles/plugin or $VIM/vimfiles/plugin
	Amiga		s:vimfiles/plugin
	Macintosh	$VIM:vimfiles:plugin
	Mac OS X	~/.vim/plugin/
	RISC-OS		Choices:vimfiles.plugin

Unix에서의 예는 아래와 같습니다. (플러그인 디렉토리가 아직 없다고 가정할
때):

	mkdir ~/.vim
	mkdir ~/.vim/plugin
	cp /usr/local/share/vim/vim60/macros/justify.vim ~/.vim/plugin

이렇게만 하면 여러분은 텍스트를 왼쪽 혹은 오른쪽으로 정렬하도록 해주는 justify
플러그인을 사용할 수 있습니다.

plugin/ 아래에 바로 복사해 넣는 대신에, plugin/.의 하위 디렉토리에 파일들을
넣으면 관리하기에 용이합니다. 예를 들어 여러분의 펄과 관련된 플러그인 들을
"~/.vim/plugin/perl/*.vim"에 모두 넣을 수 있습니다.


파일타입 플러그인			<b class="vimtag">*<a name="add-filetype-plugin">add-filetype-plugin</a>*</b> <b class="vimtag">*<a name="ftplugins">ftplugins</a>*</b>

빔 배포판에 사용된 여러 종류의 파일 타입 플러그인을 사용하시려면 아래 명령을
입력하시면 됩니다.

	:filetype plugin on

자세한 내용은 |<a href="usr_05.html#vimrc-filetype">vimrc-filetype</a>|을 참고하시기 바랍니다.

여러분이 사용하시는 파일타입의 플러그인이 없거나 더 나은 것을 찾았다면
간단하게 아래 방법으로 추가할 수 있습니다.
1. 플러그인의 복사본을 구한다.
2. 적절한 디렉토리에 넣는다.


파일타입 플러그인 구하기

글로벌 플러그인과 같은 곳에서 파일타입 플러그인을 구할 수 있습니다. 명시된
파일타입을 주의깊게 살펴보시면 어떤 종류의 플러그인인지 알 수 있습니다.
$VIMRUNTIME/macros에 있는 스크립트들은 글로벌 플러그인이며,
$VIMRUNTIME/ftplugin의 스크립트들은 파일타입 플러그인입니다.


파일타입 플러그인 사용하기					<b class="vimtag">*<a name="ftplugin-name">ftplugin-name</a>*</b>

적절한 디렉토리에 파일타입 플러그인을 복사해놓음으로써 플러그인을 추가할 수
있습니다. 글로벌 플러그인의 디렉토리 명에서 마지막 부분을 "ftplugin"으로
바꾸면 파일타입 플러그인이 사용하는 디렉토리들이 됩니다. 유닉스를 사용하면서
stuff 파일타입의 플러그인을 사용하고 싶다면, 아래 처럼 파일을 이동하면 됩니다.  :
<code class="example"></code>
<code class="example">	mv thefile ~/.vim/ftplugin/stuff.vim</code>
<code class="example"></code>
"stuff"를 위한 플러그인이 이미 존재한다면, 존재하는 플러그인과 충돌하지 않는지
확인하고 추가할 수 있습니다. 새 플러그인을 아래와 같이 다른 이름으로
변경합니다.  :
<code class="example"></code>
<code class="example">	mv thefile ~/.vim/ftplugin/stuff_too.vim</code>
<code class="example"></code>
이름에서 파일 타입과 나머지 부분을 구분하기 위해 밑줄을 사용합니다. 만약
"otherstuff.vim"이라고 했다면 이 파일은 "otherstuff" 파일 타입을 위해 불러지게
되므로 작동하지 않습니다.

MS-DOS에서는 긴 파일이름을 사용할 수 없으므로 파일 타입 플러그인을 여러개 만들
때 어려움을 겪을 수 있습니다. 아래와 같이 추가로 디렉토리를 만들어 이 문제를
피해갈 수 있습니다.
<code class="example"></code>
<code class="example">	mkdir $VIM/vimfiles/ftplugin/fortran</code>
<code class="example">	copy thefile $VIM/vimfiles/ftplugin/fortran/too.vim</code>
<code class="example"></code>
파일타입 플러그인의 일반적인 이름은 다음과 같습니다:
<code class="example"></code>
<code class="example">	ftplugin/<code class="special">&lt;filetype&gt;</code>.vim</code>
<code class="example">	ftplugin/<code class="special">&lt;filetype&gt;</code>_<code class="special">&lt;name&gt;</code>.vim</code>
<code class="example">	ftplugin/<code class="special">&lt;filetype&gt;</code>/<code class="special">&lt;name&gt;</code>.vim</code>
<code class="example"></code>
여기서 "<code class="special">&lt;name&gt;</code>"은 여러분이 원하는 어떤 값이든 상관없습니다.
예를 들어 유닉스에서 "stuff"파일 타입이라면:
<code class="example"></code>
<code class="example">	~/.vim/ftplugin/stuff.vim</code>
<code class="example">	~/.vim/ftplugin/stuff_def.vim</code>
<code class="example">	~/.vim/ftplugin/stuff/header.vim</code>
<code class="example"></code>
여기서 <code class="special">&lt;filtype&gt;</code> 파트는 여러분이 사용하고자 하는 플러그인의 파일타입입니다. 이
파일타입에 해당하는 파일만이 이 플러그인에 있는 설정을 사용합니다.
<code class="special">&lt;name&gt;</code>부분은 실제 동작에는 아무런 영향을 끼치지 않으며 단지 여러분이 한
파일타입에 대해 여러개의 플러그인을 사용할 수 있도록합니다. 모든 플러그인은
".vim"으로 끝나야 한다는 것을 주의하시기 바랍니다.


다음 항목들을 추가로 읽어 보시기 바랍니다:
|<code class="badlink">filetype-plugins</code>|	Documentation for the filetype plugins and information
			about how to avoid that mappings cause problems.
|<code class="badlink">load-plugins</code>|		When the global plugins are loaded during startup.
|<code class="badlink">ftplugin-overrule</code>|	Overruling the settings from a global plugin.
|<code class="badlink">write-plugin</code>|		How to write a plugin script.
|<code class="badlink">plugin-details</code>|	For more information about using plugins or when your
			plugin doesn't work.
|<code class="badlink">new-filetype</code>|		How to detect a new file type.

</pre><hr><pre><b class="vimtag">*<a name="05.5">05.5</a>*</b>	도움말 파일 추가하기		<b class="vimtag">*<a name="add-local-help">add-local-help</a>*</b> <b class="vimtag">*<a name="matchit-install">matchit-install</a>*</b>

운이 좋다면 여러분은 도움말 파일과 함께 배포되는 플러그인을 얻었을 수도
있습니다. 여기서는 여러분들의 새 플러그인에 대한 도움말을 쉽게 찾아볼 수
있도록 도움말 파일을 설치하는 방법에 대해 알려드립니다.
   "matchit.vim" 플러그인을 예로 들어 보겠습니다. ( 배포된 빔안에 포함되어
있습니다.) 이 플러그인은 "%" 명령을 HTML 태그 사이나, 빔 스크립트의
if/else/endif 사이를 매치시켜 줍니다. 아주 유용하지만, 구버전과 호환되지
않습니다. ( 기본으로 켜지지 않는 이유이기도 합니다. )
   이 플러그인은 다음 문서를 포함합니다: "matchit.txt". 먼저 플러그인을 적절한
디렉토리로 복사합니다. 빔에 포함된 스크립트를 사용하므로 $VIMRUNTIME
디렉토리에 복사해둬도 괜찮을 것 같습니다. ( 이미 디렉토리가 있다면
"mkdir"명령을 건너 뛰어도 좋습니다. )
<code class="example"></code>
<code class="example">	:!mkdir ~/.vim</code>
<code class="example">	:!mkdir ~/.vim/plugin</code>
<code class="example">	:!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/plugin</code>
<code class="example"></code>
Unix라면 "cp" 명령을 사용하고, MS-DOS에서는 "copy" 명령을 사용합니다.


'runtimepath' 중의 한 디렉토리 아래에 "doc" 디렉토리를 만듭니다.

	:!mkdir ~/.vim/doc

도움말 파일을 "doc" 디렉토리에 복사합니다.
<code class="example"></code>
<code class="example">	:!cp $VIMRUNTIME/macros/matchit.txt ~/.vim/doc</code>
<code class="example"></code>
새로운 도움말 파일의 주제로 건너 뛰기를 추가하기 위해 이제는 마법을 하나 부릴
차례입니다: 지역 태그 파일을 생성하기 위해 |<code class="badlink">:helptags</code>| 명령을 실행합니다.

	:helptags ~/.vim/doc

이제 다음 처럼 도움말을 볼 수 있습니다.
<code class="example"></code>
<code class="example">	:help g%</code>
<code class="example"></code>
방금 막 추가한 "g%"명령에 대한 도움말을 확인할 수 있습니다. 여러분이 추가한
도움말의 목록은 아래와 같이 확인할 수 있습니다.
<code class="example"></code>
<code class="example">	:help local-additions</code>
<code class="example"></code>
추가된 도움말 파일들의 첫 제목 줄이 자동적으로 이 섹션에 등록됩니다. 이곳에서
여러분이 추가한 도움말 파일을 확인할 수 있으며, 태그를 타고 그곳으로 건너뛸 수 있습니다.

도움말 파일을 작성하는 법에 대해 알고 싶으면 |<code class="badlink">write-local-help</code>| 를 참고하시기
바랍니다.

</pre><hr><pre><b class="vimtag">*<a name="05.6">05.6</a>*</b>	옵션 창

여러분이 원하는 옵션을 찾고 싶다면 |<code class="badlink">options</code>| 도움말에서 찾아볼 수 있습니다. 또
다른 한 가지 방법은 다음 명령을 사용하는 것입니다. :
<code class="example"></code>
<code class="example">	:options</code>
<code class="example"></code>
이 명령을 실행하면 한줄짜리 설명과 함께 옵션의 목록이 있는 창을 보여줍니다.
옵션들은 주제에 따라 그룹으로 나뉘어져 있습니다. 주제로 커서를 옮긴 후
<code class="special">&lt;Enter&gt;</code>키를 눌러서 해당 주제로 이동할 수 있습니다. 다시 돌아오려면 <code class="special">&lt;Enter&gt;</code>를
입력하거나 <code class="keystroke">CTRL-O</code>를 입력하시기 바랍니다.

이 창에서 옵션의 값을 변경할 수 있습니다. 예를 들어, "displaying text" 주제로
이동한 후 커서를 다음과 같은 줄에 위치 시킵니다.

<code class="section">	set wrap	nowrap </code>

<code class="special">&lt;Enter&gt;</code>를 입력하면 해당 줄이 아래와 같이 바뀝니다:

<code class="section">	set nowrap	wrap </code>

이제 이 옵션은 꺼졌습니다.

'wrap' 옵션에 대한 간단한 도움이 있는 줄 위로 커서를 이동해 봅시다. 이제
<code class="special">&lt;Enter&gt;</code>를 입력하면 'wrap' 옵션에 대해 상세한 설명이 있는 도움말 페이지를 볼 수
있습니다.

숫자나 문자열을 인자로 받는 옵션에 대해서는 값을 수정하고 <code class="special">&lt;Enter&gt;</code>키를 눌러
변경된 옵션을 적용할 수 있습니다. 몇 줄 위로 올라가서 아래와 같은 라인으로
커서를 이동시켜 봅시다.:

<code class="section">	set so=0 </code>

"$" 명령을 이용해 커서를 0 위로 이동시킵니다. "r5"를 입력하여 값을 5로 변경한
후 새로운 값을 적용하기 위해 <code class="special">&lt;Enter&gt;</code> 키를 입력합니다. 이제 커서를 이동하여
페이지를 스크롤 하려 해 보면 버퍼 창의 끝에 도달하기 전에 스크롤이 일어나는
것을 알 수 있습니다. 이처럼 'scrolloff' 옵션은 스크롤이 시작되는 위치와 창의
끝부분 사이의 간격을 의미합니다.

</pre><hr><pre><b class="vimtag">*<a name="05.7">05.7</a>*</b>	자주 사용되는 옵션

밤에는 엄청나게 많은 수의 옵션이 있고 대부분을 사용해 보기는 힘들 것 입니다.
어곳에서 소개된 몇 가지 옵션들은 유용해서 자주 쓰이는 것들 입니다. 작은
따옴표로 둘러 싸인 옵션 이름을 이용해 언제든지 ":help"명령어로 도움말을 볼 수
있습니다:
<code class="example"></code>
<code class="example">	:help 'wrap'</code>
<code class="example"></code>
옵션에 대해 파악했으면 해당 옵션을 기본 값으로 돌려 놓기 위해 옵션 이름 다음에
앰퍼샌드(&amp;)를 쓸 수 있습니다. 예를 들어 다음과 같이 쓸 수 있습니다.

	:set iskeyword&amp;


자동으로 줄 바꾸지 않기

빔은 여러분에게 모든 내용을 보여주기 위해 긴 줄을 자동으로 줄바꿈하여
보여줍니다. 하지만 때때로 줄을 바꾸지 않고 내용이 창 오른쪽에 연속해서
나오게하여 횡으로 스크롤 하면서 긴 행을 보고싶을 수 있습니다. 자동 줄바꿈
옵션은 다음 명령으로 변경할 수 있습니다:
<code class="example"></code>
<code class="example">	:set nowrap</code>
<code class="example"></code>
여러분이 화면에 보이지 않는 내용으로 이동하려 할때 빔이 저절로 스크롤을
합니다. 근처 10글자를 보고 싶으면 다음과 같이 설정합니다:
<code class="example"></code>
<code class="example">	:set sidescroll=10</code>
<code class="example"></code>
이 옵션은 실제 텍스트를 바꾸지는 않으며, 단지 보여지는 방법만 바뀝니다.


커서 이동 명령 줄 바꿈하기

대부분의 커서를 이동하는 명령은 행의 시작이나 끝에서 이동을 멈춥니다.
'whichwrap' 옵션을 설정하여 이를 변경할 수 있습니다. 이 옵션은 다음과 같이
기본값이 설정되어 있습니다.:
<code class="example"></code>
<code class="example">	:set whichwrap=b,s</code>
<code class="example"></code>
이 옵션에 따르면 <code class="special">&lt;BS&gt;</code> 키가 행의 첫 위치에서 입력되면 이전 행의 끝으로 커서를
이동시킵니다. 그리고 <code class="special">&lt;Space&gt;</code>키는 행의 끝에서 다음 행의 시작으로 커서를 이동
시킵니다.

<code class="special">&lt;Left&gt;</code>키와 <code class="special">&lt;Right&gt;</code> 키 또한 이렇게 동작하도록 바꾸고 싶다면 다음과 같이
설정합니다.:
<code class="example"></code>
<code class="example">	:set whichwrap=b,s,<code class="special">&lt;,&gt;</code></code>
<code class="example"></code>
하지만 여전이 일반 모드에서만 동작합니다. 입력 모드에서도 <code class="special">&lt;Left&gt;</code> 와 <code class="special">&lt;Right&gt;</code>가
이 방식으로 동작하도록 만들고 싶다면 다음과 같이 설정합니다:
<code class="example"></code>
<code class="example">	:set whichwrap=b,s,<code class="special">&lt;,&gt;</code>,[,]</code>
<code class="example"></code>
몇 가지 다른 플래그를 더 사용할 수 있으며, 'whichwrap'을 참고하시면 됩니다.


탭 보기

파일에 탭이 있지만 여러분은 어디에 탭이 있는지 볼 수 없습니다. 탭이 보이도록
하려면 다음 명령을 이용합니다:
<code class="example"></code>
<code class="example">	:set list</code>
<code class="example"></code>
이제 탭은 ^I와 같이 보이게 됩니다. 그리고 행 끝에 얼마나 많은 공백문자가
있는지 알기 위해 행 끝에 $ 가 보이게 됩니다.
  이 방법의 단점은, 파일에 탭이 많을 때 흉하게 보이게 됩니다. 컬러 터미널을
  사용하거나 GUI를 사용하게 될 경우는, 빔은 공백과 탭을 강조된 문자로 보여줄
  수도 있습니다. 'listchars' 옵션을 사용합니다:
<code class="example"></code>
<code class="example">	:set listchars=tab:&gt;-,trail:-</code>
<code class="example"></code>
이제 모든 탭은 "&gt;---" 로 보여지고 ( "-"의 갯수는 유동적입니다. ) 따르는 공백
문자는 "-"로 보여지게 됩니다. 더 보기 편하지 않습니까?


키워드

'iskeyword' 옵션은 단어로 인정할 문자들을 지정합니다:
<code class="example"></code>
<code class="example">	:set iskeyword</code>
<code class="section">	  iskeyword=@,48-57,_,192-255 </code>

"@"는 모든 알파벳 문자를 의미합니다. "48-57"은 48에서 57까지의 아스키 코드에
해당하는 문자를 의미하며, 0 에서 9 까지의 문자입니다. "192-255"는 출력 가능한
라틴 문자를 의미합니다.
   "-" 를 단어로 인정할 문자에 포함하고 싶을 수 있습니다. 이를테면
"upper-case"를 한 단어로 인식하고 싶을 때에는 다음과 같이 설정할 수 있습니다:

<code class="example"></code>
<code class="example">	:set iskeyword+=-</code>
<code class="example">	:set iskeyword</code>
<code class="section">	  iskeyword=@,48-57,_,192-255,- </code>

새로운 값이 추가되면 쉼표를 이용해 값 사이를 구분하는 것을 볼 수 있습니다.
   문자를 제거하고 싶을 때는 "-="를 이용하면 됩니다. 밑줄 문자를 빼고 싶다면
   다음과 같이 설정합니다:

	:set iskeyword-=_
	:set iskeyword
<code class="section">&lt;	  iskeyword=@,48-57,192-255,- </code>

이때 쉼표는 자동적으로 함께 제거됩니다.


ROOM FOR MESSAGES

빔은 메시지를 출력하기 위해 하단에서 하나의 행을 사용합니다.
메시지가 길어지게 되면 넘친 메시지는 잘려서 일부분만 보이거나, 스크롤 되어
<code class="special">&lt;Enter&gt;</code>키를 눌러야만 더 볼 수 있게 됩니다.
   'cmdheight' 옵션을 메시지를 출력하기 위한 행 높이를 조절하기 위해 사용할 수
있습니다. 예를 들어:
<code class="example"></code>
<code class="example">	:set cmdheight=3</code>
<code class="example"></code>
이렇게 하면 텍스트를 편집하기 위해 사용되는 공간이 줄어듦으로, 적당한 선에서
절충하여 사용하시기 바랍니다.

</pre><hr><pre>
다음 장: |<code class="badlink">usr_06</code>|  문법 강조 사용하기

저작권: |<a href="usr_01.html#manual-copyright">manual-copyright</a>| 참고  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Fri Dec 23 22:48:56 PST 2011</i></p>
</body>
</html>
