<!DOCTYPE html>
<html>
<head>
<title>VIM: usr_22</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>USR_22</h2>
<pre>
<b class="vimtag">*<a name="usr_22.txt">usr_22.txt</a>*</b>	Vim version 7.0 대상.  새로고침: 2006 Apr 24

		      VIM 사용설명서 - Bram Moolenaar 저
				       정지용 역

			       편집할 파일 찾기


파일이 여기저기 사방에 흩어져있습니다.  어떻게 원하는 파일을 찾을 수 있을까요?
빔을 이용하면 다양한 방법으로 디렉토리 구조를 둘러볼 수 있습니다.  한 파일
안에 적혀있는 경로를 따라가 파일을 편집하는 명령도 있습니다.  빔은 그동안
편집했었던 파일들의 목록도 기억합니다.

|<a href="usr_22.html#22.1">22.1</a>|	파일 탐색기
|<a href="usr_22.html#22.2">22.2</a>|	현재 디렉토리
|<a href="usr_22.html#22.3">22.3</a>|	파일 찾기
|<a href="usr_22.html#22.4">22.4</a>|	버퍼 목록

다음 장: |<a href="usr_23.html#usr_23.txt">usr_23</a>|  특별한 파일 편집하기
이전 장: |<code class="badlink">usr_21</code>|  나갔다가 되돌아오기
   차례: |<a href="usr_toc.html#usr_toc.txt">usr_toc</a>|

</pre><hr><pre><b class="vimtag">*<a name="22.1">22.1</a>*</b>	파일 탐색기

빔 플러그인으로 디렉토리의 내용을 수정할 수 있습니다.  다음 명령을
수행해보십시오:
<code class="example"></code>
<code class="example">	:edit .</code>
<code class="example"></code>
자동명령(autocommand)과 빔 스크립트가 수행되면서 디렉토리의 내용이 창에
표시됩니다.  표시되는 내용은 다음과 같습니다.

<code class="section">	" Press ? for keyboard shortcuts </code>
<code class="section">	" Sorted by name (.bak,~,.o,.h,.info,.swp,.obj,.orig,.rej at end of list) </code>
<code class="section">	"= /home/mool/vim/vim6/runtime/doc/ </code>
<code class="section">	../ </code>
<code class="section">	check/ </code>
<code class="section">	Makefile </code>
<code class="section">	autocmd.txt </code>
<code class="section">	change.txt </code>
<code class="section">	eval.txt~ </code>
<code class="section">	filetype.txt~ </code>
<code class="section">	help.txt.info </code>

다음 내용들이 표시됩니다:
1.  파일 탐색기의 도움말을 보려면 ? 를 누르라는 주석문.
2.  디렉토리의 내용이 어떻게 표시되었는 지에 대한 안내.  디렉토리의 내용은
    여러가지 방법으로 정렬해서 볼 수 있습니다.
3.  현재 디렉토리의 이름.
4.  상위 디렉토리를 나타내는 "../".
5.  디렉토리들.
6.  일반 파일들.  두 번째 줄에 나왔듯이, 몇 가지 파일들은 여기가 아니라 목록의
    맨 마지막에 나옵니다.
7.  특수 파일들.  일반적으로는 이 파일들을 잘 사용하지 않으므로, 목록의 맨
    마지막에 표시되었습니다.

문법 강조를 사용하면, 각 부분이 다른 색으로 표시되어 구별하기 쉬워집니다.

빔의 보통 상태 명령들을 사용해서 내용 위를 움직이며 파일들을 편집할 수
있습니다.  예를 들어, 파일명 위로 커서를 옮긴 후, <code class="special">&lt;Enter&gt;</code>를 눌러보십시오.  그
파일을 편집하도록 바뀌었을 것입니다.  다시 탐색기로 돌아가려면 ":edit ."
명령을 사용하십시오.  <code class="keystroke">CTRL-O</code>를 사용해도 됩니다.
   이번에는 커서를 디렉토리명 위로 옮긴 후, <code class="special">&lt;Enter&gt;</code>를 눌러보십시오.  탐색기가
그 디렉토리로 이동한 후, 디렉토리의 내용을 보여주도록 바뀌었을 것입니다.
커서를 첫 번째 디렉토리인 "../"로 옮긴 후 <code class="special">&lt;Enter&gt;</code>를 누르면 상위 디렉토리로
이동할 수 있습니다.  아니면 커서를 옮길 필요도 없이 "-"키를 눌러도 됩니다.

? 를 누르면 탐색기의 명령들에 대한 간단한 도움말을 볼 수 있습니다.  도움말의
내용은 다음과 같습니다:

<code class="section">	" <code class="special">&lt;enter&gt;</code> : open file or directory </code>
<code class="section">	" o : open new window for file/directory </code>
<code class="section">	" O : open file in previously visited window </code>
<code class="section">	" p : preview the file </code>
<code class="section">	" i : toggle size/date listing </code>
<code class="section">	" s : select sort field    r : reverse sort </code>
<code class="section">	" - : go up one level      c : cd to this dir </code>
<code class="section">	" R : rename file	   D : delete file </code>
<code class="section">	" :help file-explorer for detailed help </code>

윗쪽에는 파일을 선택해서 표시하는 명령어가 몇 가지 나옵니다.  어떤 명령어를
쓰느냐에 따라 파일이 나타나는 위치가 다음과 같이 달라집니다:

	<code class="special">&lt;Enter&gt;</code>		현재 창에 표시.
	o		새 창을 열어서 표시.
	O		이전에 사용했던 창에 표시.
	p		미리보기 창에 표시하고, 탐색기 창으로 돌아옴.
			|<code class="badlink">preview-window</code>|

다른 정보를 표시하는 명령어들도 있습니다:

	i		파일의 크기와 날짜를 표시.  i를 다시 누르면 이 정보가
			사라집니다.
	s		현재 커서가 있는 영역을 기준으로 재정렬.  먼저 i를
			눌러서 파일의 크기와 날짜를 나오게 합니다.  그리고
			커서를 파일의 크기들 중 하나로 옮긴 후, s를 눌러
			보십시오.  파일이 크기를 기준으로 정렬되었을 것입니다.
			커서를 날짜 위에 놓고 s를 누르면 날짜 순으로
			정렬됩니다.
	r		역순으로 재정렬. (크기나 날짜 순 정렬일 경우도 가능)

이 밖에도 다음 명령들이 있습니다:

	c		현재 표시된 디렉토리로 현재 디렉토리를 바꿈.  현재
			표시되고 있는 파일들을 ":edit"로 열 때, 더 이상 경로를
			지정하지 않아도 됩니다.
	R		커서가 위치한 파일의 이름을 변경.  빔이 새 이름을
			입력받습니다.
	D		커서가 위치한 파일을 삭제.  진짜로 삭제할 것인 지 다시
			한 번 확인을 거칩니다.

</pre><hr><pre><b class="vimtag">*<a name="22.2">22.2</a>*</b>	현재 디렉토리

쉘과 마찬가지로, 빔에도 현재 디렉토리라는 개념이 있습니다.  현재 디렉토리가 홈
디렉토리이고, "길고긴디렉토리이름"이라는 디렉토리안의 파일들을 열고 싶다고 합시다.
다음과 같이 할 것입니다:
<code class="example"></code>
<code class="example">	:edit 길고긴디렉토리이름/file1.txt</code>
<code class="example">	:edit 길고긴디렉토리이름/file2.txt</code>
<code class="example">	:edit 길고긴디렉토리이름/file3.txt</code>
<code class="example"></code>
타이핑 하는 양을 줄이고 싶다면 다음과 같이 하면 됩니다:
<code class="example"></code>
<code class="example">	:cd 길고긴디렉토리이름</code>
<code class="example">	:edit file1.txt</code>
<code class="example">	:edit file2.txt</code>
<code class="example">	:edit file3.txt</code>
<code class="example"></code>
":cd" 명령은 현재 디렉토리를 바꿉니다.  현재 디렉토리는 ":pwd" 명령으로 확인할
수 있습니다:
<code class="example"></code>
<code class="example">	:pwd</code>
<code class="example">	/home/Bram/길고긴디렉토리이름</code>
<code class="example"></code>
빔은 마지막으로 사용한 디렉토리를 기억합니다. "cd -"를 사용하면 가장
마지막으로 사용한 디렉토리로 돌아갑니다.
예:
<code class="example"></code>
<code class="example">	:pwd</code>
<code class="example">	/home/Bram/길고긴디렉토리이름</code>
<code class="example">	:cd /etc</code>
<code class="example">	:pwd</code>
<code class="example">	/etc</code>
<code class="example">	:cd -</code>
<code class="example">	:pwd</code>
<code class="example">	/home/Bram/길고긴디렉토리이름</code>
<code class="example">	:cd -</code>
<code class="example">	:pwd</code>
<code class="example">	/etc</code>
<code class="example"></code>
<code class="example"></code>
특정 창에 대해서만 디렉토리 설정하기

창을 나누면, 두 창이 모두 같은 현재 디렉토리를 갖게 됩니다.  새 창에서는 다른
디렉토리에 있는 여러 파일을 편집하고 싶다면, 원래 창의 현재 디렉토리는 놔둔 채
새 창만 다른 디렉토리로 설정할 수 있습니다.  바로 창 한정 디렉토리(window
local directory) 기능입니다.
<code class="example"></code>
<code class="example">	:pwd</code>
<code class="example">	/home/Bram/길고긴디렉토리이름</code>
<code class="example">	:split</code>
<code class="example">	:lcd /etc</code>
<code class="example">	:pwd</code>
<code class="example">	/etc</code>
<code class="example">	<code class="keystroke">CTRL-W</code> w</code>
<code class="example">	:pwd</code>
<code class="example">	/home/Bram/길고긴디렉토리이름</code>
<code class="example"></code>
":lcd" 명령어가 사용되지 않으면, 모든 창이 같은 현재 디렉토리 값을 공유하게
됩니다.  어느 창에서 ":cd" 명령을 사용하든지, 모든 창의 현재 디렉토리가 바뀌기
때문입니다.
   하지만 ":lcd"로 현재 디렉토리가 지정된 경우에는 바뀌지 않습니다.  즉, 다른
창에서 ":cd"나 ":lcd"를 하더라도 아무 영향이 없습니다.
   현재 디렉토리가 따로 설정되어있는 창에서 ":cd" 명령을 수행하면, 다시 다른
창들과 현재 디렉토리를 공유하게 됩니다.

</pre><hr><pre><b class="vimtag">*<a name="22.3">22.3</a>*</b>	파일 찾기

C 프로그램을 편집하는 중에 다음과 같은 내용이 있다고 해봅시다:

<code class="section">	#include "inits.h" </code>

"inits.h"의 내용을 보려면, 커서를 파일명이 있는 곳으로 옮긴 후 다음 명령을
사용하면 됩니다:
<code class="example"></code>
<code class="example">	gf</code>
<code class="example"></code>
빔은 해당 파일을 찾아서 열 것입니다.
   하지만 파일이 현재 디렉토리에 없다면 빔이 파일을 찾지 못합니다.  이 때는
'path' 설정을 사용하면 됩니다.  이 설정은 파일을 찾을 디렉토리들을 지정합니다.
   "c:/prog/include"에 포함(include)시킬 헤더파일들을 모아놓았다고 합시다.
다음 명령으로 'path' 설정에 경로를 추가할 수 있습니다:
<code class="example"></code>
<code class="example">	:set path+=c:/prog/include</code>
<code class="example"></code>
이 디렉토리는 절대경로로 표현되어있습니다.  따라서 현재 편집 중인 파일의
디렉토리에 상관없이 항상 같은 경로를 가리킬 것입니다.  만약 현재 편집 중인
파일의 하위 디렉토리에 찾을 파일들을 모아놓았다면 어떻게 해야할까요?  이 때는
상대경로로 지정하면 됩니다.  상대경로는 점(.)으로 시작합니다:
<code class="example"></code>
<code class="example">	:set path+=./proto</code>
<code class="example"></code>
위 명령은 파일을 현재 "gf"를 사용하는 파일이 있는 디렉토리 하위의 "proto"라는
디렉토리에서 찾도록 지정합니다.  따라서 "init.h" 위에서 "gf"를 하면, 현재
파일이 있는 디렉토리를 기준으로 "proto/inits.h" 파일을 찾게 됩니다.
   "./"없이 "proto"만 지정하는 경우에는 현재 디렉토리를 기준으로 "proto"
디렉토리를 찾습니다.  현재 디렉토리는 현재 편집 중인 파일의 디렉토리와 다를
수 있다는 데 주의하십시오.

'path' 설정은 이 외에도 파일을 찾을 디렉토리를 지정할 수 있는 여러가지 방법을
제공합니다. 'path'설정의 도움말을 참고하십시오.
   'isfname'옵션은 어떤 문자가 파일명에 포함되고, 어떤 문자는 포함되지 않는
지를 지정합니다(예를 들어, 위 예에서 " 문자는 포함되지 않습니다).

파일명은 아는데 현재 편집 중인 파일에 나오지 않아 "gf"를 쓸 수 없을 때는, 다음
명령을 사용하십시오:
<code class="example"></code>
<code class="example">	:find inits.h</code>
<code class="example"></code>
'path' 설정을 참고하여 파일을 찾게 됩니다.  이 명령은 'path'에서 파일을 찾는
다는 점만 빼고 ":edit" 명령과 동일합니다.

파일을 열 때 새 창에서 열려면 "gf" 대신 <code class="keystroke">CTRL-W</code> f 를, ":find" 대신 ":sfind"를
쓰면 됩니다.


처음 빔을 시작할 때 'path'안 어딘가에 있는 파일을 열려면 다음과 같이 하면
됩니다:
<code class="example"></code>
<code class="example">	vim "+find stdio.h"</code>
<code class="example"></code>
위 명령은 'path' 설정에서 "stdio.h"를 찾아서 열어줍니다.  따옴표는 find명령
전체를 하나의 인자로 만들기 위해 사용되었습니다 |<code class="badlink">-+c</code>|.

</pre><hr><pre><b class="vimtag">*<a name="22.4">22.4</a>*</b>	버퍼 목록

빔은 현재 편집중인 파일을 표현하기 위해 문자열 버퍼를 사용합니다.  사실,
버퍼는 현재 편집중인 파일의 복사본입니다.  실제로는 버퍼를 변경하다가, 편집이
끝나면 버퍼의 내용을 파일에 쓰게 됩니다.  버퍼는 파일의 내용뿐 아니라, 마크나
설정들 등등 편집에 필요한 여러가지 내용을 갖고 있습니다.


숨겨진 버퍼들

하나.txt 파일을 편집하는 도중에, 둘.txt 파일을 편집해야 한다고 합시다.
":edit 둘.txt" 명령으로 간단하게 편집중인 파일을 바꿀 수 있지만, 하나.txt
파일에 고친 내용이 있을 경우에는 동작하지 않을 것입니다.  하지만 고친 내용을
섣불리 하나.txt 파일에 저장하고 싶지도 않다면, 다음 명령을 사용하면 됩니다:
<code class="example"></code>
<code class="example">	:hide edit 둘.txt</code>
<code class="example"></code>
"하나.txt" 버퍼는 화면에서 사라지지만, 이 버퍼를 사용하고 있다는 정보는 그대로
남습니다.  따라서 변경된 사항들도 계속 유지됩니다.  이 기능은 내용이 있지만,
화면에는 나타나지 않는 버퍼란 의미에서 숨겨진 버퍼라고 합니다.
   ":hide" 명령의 인자는 다른 명령입니다.  이 명령 대신 'hidden' 설정을 켜도
같은 결과가 되므로 이 설정을 사용해도 됩니다.  이 경우 어떤 버퍼도 사라지지
않고 모두 숨겨진 상태가 됩니다.
   주의하십시오!  변경사항이 있는 숨겨진 버퍼가 있을 경우, 빔을 종료하기 전에
꼭 모든 버퍼를 저장해야만 합니다.


비활성 버퍼

   버퍼가 한 번이라도 사용되면, 빔에는 그에 대한 정보가 기록됩니다.  어떤
버퍼가 화면에 표시되지 않고, 숨겨진 상태도 아닌 경우라도 버퍼목록에는
남아있습니다.  이런 버퍼를 비활성 버퍼라고 합니다.  전체적으로 다음과 같은
버퍼들이 있습니다:

   활성			화면에 표시되고, 문서내용이 로딩됨.
   숨겨짐		화면에 표시되지는 않으나, 문서내용이 로딩됨.
   비활성		화면에 표시되지도 않고, 문서내용도 로딩되어 있지 않음.

비활성 버퍼도 마크 같은 다른 정보들의 기록을 위해 여전히 남아있습니다.  또한,
최근에 내가 어떤 파일을 열어봤는 지 알려주므로, 나중에 그 파일을 다시 열고싶을
때도 유용합니다.


버퍼 목록 보여주기

버퍼 목록을 보려면 다음 명령을 사용하면 됩니다:
<code class="example"></code>
<code class="example">	:buffers</code>
<code class="example"></code>
조금 이름이 이상하긴 하지만, 다음의 짧은 명령도 똑같이 버퍼 목록을 보여줍니다:

<code class="example"></code>
<code class="example">	:ls</code>
<code class="example"></code>
다음과 같이 버퍼목록이 표시됩니다:

<code class="section">  1 #h	"help.txt"			line 62 </code>
<code class="section">  2 %a+	"usr_21.kox"			line 1 </code>
<code class="section">  3	"usr_21.txt"			line 1 </code>

줄의 맨 앞에는 버퍼 번호가 옵니다.  이 번호로 버퍼의 이름을 모두 입력할
필요없이 버퍼를 선택할 수 있습니다.  아래 설명을 참고하십시오.
   버퍼 번호 다음에는 버퍼의 상태표시 문자들이 표시됩니다.  그 뒤에는 파일의
이름과 마지막으로 커서가 위치했던 줄의 번호가 나옵니다.
   상태표시 문자는 다음과 같습니다 (왼쪽에서 오른쪽 순서):

	u	목록에 없는 버퍼 |<code class="badlink">unlisted-buffer</code>|.
	 %	현재 버퍼.
	 #	교대 버퍼.
	  a	버퍼가 로딩되었고 화면에 표시됨.
	  h	버퍼가 로딩되었지만 숨겨짐.
	   =	읽기 전용 버퍼
	   -	버퍼 내용을 수정할 수 없음, 'modifiable' 설정이 꺼져있음.
	    +	버퍼에 수정사항이 있음.


버퍼 편집하기

파일명을 모두 칠 필요없이, 다음과 같이 버퍼 번호로 버퍼를 선택할 수 있습니다:

<code class="example"></code>
<code class="example">	:buffer 2</code>
<code class="example"></code>
하지만 번호를 알려면 버퍼 목록을 봐야하는 단점이 있습니다.  이 때는 파일명이나
파일명의 일부를 대신 쓸 수도 있습니다:
<code class="example"></code>
<code class="example">	:buffer help</code>
<code class="example"></code>
빔은 입력한 이름과 일치하는 버퍼를 찾습니다.  만약 일치하는 버퍼가 하나 밖에
없다면, 그 버퍼가 사용됩니다.  위 예의 경우에는 "help.txt"입니다.
   버퍼를 새 창에서 열려면:
<code class="example"></code>
<code class="example">	:sbuffer 3</code>
<code class="example"></code>
물론 버퍼 번호가 아니라 이름으로 해도 됩니다.


버퍼 목록 사용하기

다음 명령들로 버퍼 목록을 돌아다닐 수 있습니다:

	:bnext		다음 버퍼로 가기
	:bprevious	이전 버퍼로 가기
	:bfirst		첫 버퍼로 가기
	:blast		마지막 버퍼로 가기

버퍼를 목록에서 지우려면 다음 명령을 사용하십시오:
<code class="example"></code>
<code class="example">	:bdelete 3</code>
<code class="example"></code>
역시 버퍼 이름이나 그 일부로도 됩니다.
   만약 활성 버퍼(창에 표시된)를 지운 경우에는, 해당 창이 닫힙니다.  현재
버퍼를 지우면, 현재 창이 닫힙니다.  만약 창이 하나 밖에 없는 경우에는, 빔이
편집할 다른 버퍼를 찾아서 표시합니다.  아무것도 편집하지 않는 상태란 없습니다!

	<code class="note">Note:</code>
	":bdelete"로 버퍼를 지운 경우에도, 빔에는 버퍼 정보가 남아있습니다.
	사실 ":bdelete"로는 버퍼가 "목록에 없는" 상태가 될 뿐이고, 이 버퍼는
	":buffers"명령으로 표시가 안됩니다.  ":buffers!" 명령은 이런 "목록에
	없는" 버퍼까지 보여줍니다(빔에게 불가능이란 없습니다).  진짜로 버퍼를
	지우고 싶다면 ":bwipe" 명령을 사용하십시오.  'buflisted' 설정도
	참고하십시오.

</pre><hr><pre>
다음 장: |<a href="usr_23.html#usr_23.txt">usr_23</a>|  특별한 파일 편집하기

저작권: |<a href="usr_01.html#manual-copyright">manual-copyright</a>| 참고  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Fri Dec 23 22:48:56 PST 2011</i></p>
</body>
</html>
