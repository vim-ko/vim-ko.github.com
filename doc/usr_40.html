<!DOCTYPE html>
<html>
<head>
<title>VIM: usr_40</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>USR_40</h2>
<pre>
<b class="vimtag">*<a name="usr_40.txt">usr_40.txt</a>*</b>	Vim version 7.4 대상.  새로 고침: 2013년 8월 5일

		      VIM 사용설명서 - Bram Moolenaar 저
				       정지용 역

			      새로운 명령 만들기


Vim은 확장 가능한 편집기입니다.  자주 사용하는 일련의 명령들을 모아서 새로운
명령으로 만들 수 있습니다.  또는 기존의 명령을 새롭게 정의할 수도 있습니다.
자동명령 기능으로 명령들을 자동으로 수행시킬 수도 있습니다.

|<a href="usr_40.html#40.1">40.1</a>|	키 매핑
|<a href="usr_40.html#40.2">40.2</a>|	명령줄 명령 정의
|<a href="usr_40.html#40.3">40.3</a>|	자동명령

다음 장: |<a href="usr_41.html#usr_41.txt">usr_41</a>|  Vim 스크립트 만들기
이전 장: |<a href="usr_32.html#usr_32.txt">usr_32</a>|  실행 취소 트리
   차례: |<a href="usr_toc.html#usr_toc.txt">usr_toc</a>|

</pre><hr><pre><b class="vimtag">*<a name="40.1">40.1</a>*</b>	키 매핑

간단한 매핑은 이미 |<a href="usr_05.html#05.3">05.3</a>|에서 설명했습니다.  원리는 연속된 키들의 입력을 다른
키들의 입력으로 바꿔준다는 것입니다. 단순하지만 효과적인 방법이지요.
   가장 간단한 형태는 하나의 키가 일련의 키들로 매핑되는 것입니다.  <code class="special">&lt;F1&gt;</code>을
제외한 기능키들은 Vim에 정의된 동작이 없으므로 매핑하기에 좋은 후보들입니다.
예:
<code class="example"></code>
<code class="example">	:map <code class="special">&lt;F2&gt;</code> Go날짜: <code class="special">&lt;Esc&gt;</code>:read !date<code class="special">&lt;CR&gt;</code>kJ</code>
<code class="example"></code>
위 예에서는 세 가지 모드가 사용됩니다.  "G"로 마지막 줄로 이동한 후, "o"
명령으로 새로운 줄을 열고 입력 모드를 시작합니다.  "날짜: "라는 내용이 입력된
후, <code class="special">&lt;Esc&gt;</code>로 입력 모드가 종료됩니다.
   특수 키들은 <code class="special">&lt;&gt;</code>를 사용하여 표시하는 데 주의하세요.  꺾쇠괄호 표기법이라고
부릅니다.  이 키들을 입력할 때는 특수 키를 누르는 게 아니라, 표기법에 따라
입력해야 합니다.  그래야 보기도 좋고, 복사해서 붙여넣기에도 편하니까요.
   ":" 문자는 Vim을 명령줄 모드로 바꿉니다.  ":read !date" 명령은 "date"
프로그램의 출력을 읽어다 현재 위치의 아래 줄에 붙입니다. <code class="special">&lt;CR&gt;</code>은 ":read"
명령을 실행시키기 위해 필요합니다.
   여기까지 실행했을 때의 출력 결과는 다음과 같을 것입니다:

<code class="section">	날짜:  </code>
<code class="section">	2001. 06. 15. (금) 12:54:34 KST </code>

이제 "kJ"는 커서를 한 줄 위로 올려서 두 줄을 합칩니다.
   어떤 키 혹은 키들을 매핑에 사용할지는 |<code class="badlink">map-which-keys</code>|를 참고하세요.


매핑과 모드
-----------

":map" 명령은 보통 모드일 때의 키 매핑을 정의합니다.  다른 모드에서의 매핑도
정의할 수 있습니다.  예를 들어, ":imap"은 입력 모드에서의 매핑입니다.  다음
매핑을 현재 커서 밑에 날짜를 넣기 위해 쓸 수 있습니다:
<code class="example"></code>
<code class="example">	:imap <code class="special">&lt;F2&gt;</code> <code class="special">&lt;CR&gt;</code>날짜: <code class="special">&lt;Esc&gt;</code>:read !date<code class="special">&lt;CR&gt;</code>kJ</code>
<code class="example"></code>
시작 부분만 빼면 앞에서 정의한 보통 모드에서의 <code class="special">&lt;F2&gt;</code> 매핑과 비슷해보입니다.
보통 모드의 <code class="special">&lt;F2&gt;</code> 매핑은 여전히 유효합니다.  똑같은 키를 모드마다 다르게 매핑할
수 있는 것이지요.
   주의할 점은, 위 매핑이 입력 모드에서 시작되지만, 보통 모드로 끝난다는
것입니다.  계속 입력 모드가 되게 하려면, 매핑 끝에 "a"를 넣어주면 됩니다.

각 모드 별 매핑 명령을 봅시다:

	:map		보통, 시각, 오퍼레이터 대기
	:vmap		시각
	:nmap		보통
	:omap		오퍼레이터 대기
	:map!		입력과 명령줄
	:imap		입력
	:cmap		명령줄

오퍼레이터 대기(Operator-pending) 모드란 "d"나 "y" 같은 오퍼레이터 문자를
입력한 때의 모드입니다.  이 모드에서는 커서를 움직이는 명령이나 텍스트
오브젝트를을 입력해야 합니다.  "dw"를 입력할 때 "w"가 바로 오퍼레이터 대기
모드에서 입력되는 것입니다.

"d<code class="special">&lt;F7&gt;</code>" 명령으로 중괄호(<code class="special">{}</code>)로 둘러싸인 C 언어 프로그램 블록을 지울 수 있도록
<code class="special">&lt;F7&gt;</code>을 정의하고 싶다고 합시다.  비슷하게 "y<code class="special">&lt;F7&gt;</code>"로 프로그램 블록을 복사할
수도 있게요.  그러려면 <code class="special">&lt;F7&gt;</code>이 현재 프로그램 블록을 선택하도록 정의하면 됩니다.
다음과 같이 할 수 있지요:
<code class="example"></code>
<code class="example">	:omap <code class="special">&lt;F7&gt;</code> a{</code>
<code class="example"></code>
이 매핑을 정의하면, <code class="special">&lt;F7&gt;</code>로 오퍼레이터 대기 모드에서 "a{"을 입력한 것 처럼
블록을 선택할 수 있습니다.  만약 { 키를 입력하기 어려운 상황이라면 도움이 될
수 있겠지요.


매핑 목록 보기
--------------

현재 정의된 매핑들을 보려면, 인자 없이 ":map" 명령을 사용하면 됩니다.  물론
특정 모드의 매핑을 보려면 해당 모드의 명령을 사용해도 되고요.  다음과 같이
출력됩니다:

<code class="section">	   _g		 :call MyGrep(1)<code class="special">&lt;CR&gt;</code> </code>
<code class="section">	v  <code class="special">&lt;F2&gt;</code>		 :s/^/&gt; /<code class="special">&lt;CR&gt;</code>:noh<code class="special">&lt;CR&gt;</code>`` </code>
<code class="section">	n  <code class="special">&lt;F2&gt;</code>		 :.,$s/^/&gt; /<code class="special">&lt;CR&gt;</code>:noh<code class="special">&lt;CR&gt;</code>`` </code>
	   <code class="special">&lt;xHome&gt;</code>	 <code class="special">&lt;Home&gt;</code>
	   <code class="special">&lt;xEnd&gt;</code>	 <code class="special">&lt;End&gt;</code>


첫 번째 칸에는 이 매핑이 동작하는 모드가 나옵니다.  "n"은 보통(normal) 모드,
"i"는 입력(insert) 모드라는 식입니다.  빈칸인 경우는 ":map"으로 정의된 것인데,
보통과 입력 모드 모두에서 동작합니다.
   매핑 목록을 보면, <code class="special">&lt;&gt;</code> 표기법으로 입력한 특수 키가 제대로 인식되었는지 확인할
수 있습니다(컬러가 지원될 때만 가능).  예를 들어 <code class="special">&lt;Esc&gt;</code>가 컬러로 표시되면
이스케이프 키인 것이고, 다른 문자들과 같은 색으로 표시된다면 그냥 다섯글자짜리
입력인 것입니다.


매핑 중첩
---------

매핑이 반영된 결과에도 다른 매핑이 또 있을 수 있습니다.  예를 들어, 위에서
정의한 <code class="special">&lt;F2&gt;</code> 매핑은 다음과 같이 짧게 쓸 수 있습니다:
<code class="example"></code>
<code class="example">	:map <code class="special">&lt;F2&gt;</code> G<code class="special">&lt;F3&gt;</code></code>
<code class="example">	:imap <code class="special">&lt;F2&gt;</code> <code class="special">&lt;Esc&gt;</code><code class="special">&lt;F3&gt;</code></code>
<code class="example">	:map <code class="special">&lt;F3&gt;</code>  o날짜: <code class="special">&lt;Esc&gt;</code>:read !date<code class="special">&lt;CR&gt;</code>kJ</code>
<code class="example"></code>
보통 모드에서 <code class="special">&lt;F2&gt;</code>는 마지막 줄로 가서, <code class="special">&lt;F3&gt;</code>을 누른 것처럼 동작합니다.  입력
모드에서 <code class="special">&lt;F2&gt;</code>는 <code class="special">&lt;Esc&gt;</code>로 입력 모드를 끝내고, 마찬가지로 <code class="special">&lt;F3&gt;</code>을 이용합니다.
<code class="special">&lt;F3&gt;</code>에는 실제로 동작이 매핑되고요.

만약 Ex 모드를 거의 쓰지 않고, 따라서 "Q" 명령을 내용 정렬에 쓰고 싶다고
합시다 (Vim의 옛날 버전 동작입니다).  다음 매핑을 사용하면 됩니다:
<code class="example"></code>
<code class="example">	:map Q gq</code>
<code class="example"></code>
하지만, 아주 가끔이지만 Ex 모드를 쓰고 싶을 수도 있지요.  이를 위해 "gQ"를 Q로
매핑합시다.  Ex 모드를 쓸 수는 있도록 말이죠:
<code class="example"></code>
<code class="example">	:map gQ Q</code>
<code class="example"></code>
자 이제 "gQ"를 입력하면 매핑된 "Q"가 동작합니다.  이건 의도한 것이죠.  그런데
문제는 "Q"가 또다시 "gq"로 매핑되므로, 결국 "gQ"는 "gq"로 동작해버립니다.
따라서 Ex 모드에는 절대 들어갈 수 없네요.
   매핑이 중첩되는 것을 막으려면 ":noremap" 명령을 사용하면 됩니다:
<code class="example"></code>
<code class="example">	:noremap gQ Q</code>
<code class="example"></code>
이제 매핑의 결과인 "Q"에는 매핑이 적용되지 않습니다.  당연히 모드 별로 동일한
역할을 하는 명령들이 있습니다:

	:noremap	보통, 시각, 오퍼레이터 대기
	:vnoremap	시각
	:nnoremap	보통
	:onoremap	오퍼레이터 대기
	:noremap!	입력, 명령줄
	:inoremap	입력
	:cnoremap	명령줄


재귀 매핑
---------

만약 매핑이 자기 자신을 포함하고 있다면, 매핑은 영원히 동작합니다.  어떤
동작을 무한정 반복하고 싶을 때 사용할 수 있습니다.
   예를 들어, 첫 번째 줄에 버전 번호를 갖고 있는 파일들이 많다고 합시다.  이
파일들을 "vim *.txt"와 같이 열어봅시다.  자, 첫 번째 파일이 열렸지요.  다음
매핑을 정의합시다:
<code class="example"></code>
<code class="example">	:map ,, :s/5.1/5.2/<code class="special">&lt;CR&gt;</code>:wnext<code class="special">&lt;CR&gt;</code>,,</code>
<code class="example"></code>
이제 ",,"를 입력하면, 매핑이 시작됩니다.  첫 번째 줄의 "5.1"을 "5.2"로
바꿉니다.  그리고 ":wnext" 명령으로 파일을 저장한 후 다음 파일로 넘어갑니다.
매핑은 ",,"로 끝나는데, 이때문에 매핑이 다시 시작됩니다.  그러면 또 버전
번호를 바꾸는 과정이 반복됩니다.
   이 과정은 에러가 발생할 때까지 계속됩니다.  만약 "5.1"이 없는 파일이 있다면
멈추겠지요.  이때는 "5.1"을 입력한 후, 다시 ,,를 눌러서 시작하면 됩니다.
아니면 ":wnext"에서 에러가 날 수도 있는데, 이건 아마도 마지막 파일이기
때문이겠지요.
   만약 매핑이 동작하는 도중에 에러가 발생하면, 이후의 매핑은 모두 무시됩니다.
<code class="keystroke">CTRL-C</code>로 매핑을 멈출 수도 있습니다(윈도에서는 <code class="keystroke">CTRL-Break</code>).


매핑 삭제
---------

매핑을 지우려면 ":unmap" 명령을 사용합니다.  물론, 모드별로 지우는 명령이 따로
있습니다:

	:unmap		보통, 시각, 오퍼레이터 대기
	:vunmap		시각
	:nunmap		보통
	:ounmap		오퍼레이터 대기
	:unmap!		입력, 명령줄
	:iunmap		입력
	:cunmap		명령줄

보통 모드와 오퍼레이터 대기 모드에서는 동작하지만 시각 모드에서는 동작하지
않는 매핑을 만들려면 어떻게 해야 할까요?  먼저 세 모드 모두에서 동작하는
매핑을 만든 후, 시각 모드의 매핑을 지우면 됩니다:
<code class="example"></code>
<code class="example">	:map <code class="special">&lt;C-A&gt;</code> /---&gt;<code class="special">&lt;CR&gt;</code></code>
<code class="example">	:vunmap <code class="special">&lt;C-A&gt;</code></code>
<code class="example"></code>
"<code class="special">&lt;C-A&gt;</code>"라는 다섯 글자 입력은 <code class="keystroke">CTRL-A</code> 입력 하나를 의미합니다.

모든 매핑을 지우려면 |<code class="badlink">:mapclear</code>| 명령을 사용하면 됩니다.  모드별 명령은 이제
안 알려드려도 되겠지요?  이 명령은 취소할 수 없으니 꼭 조심해서 사용하세요.


특수 문자
---------

":map" 명령 다음에는 다른 명령이 올 수 있습니다.  | 문자로 두 명령을
연결합니다.  이 말은 |<code class="badlink"> 문자를 매핑에 쓸 수 없다는 말입니다.  </code>| 문자를 쓰려면
<code class="special">&lt;Bar&gt;</code> (다섯 글자) 를 대신 사용하세요.  예:

<code class="example">	:map <code class="special">&lt;F8&gt;</code> :write <code class="special">&lt;Bar&gt;</code> !checkin %<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
":unmap" 명령에도 동일한 문제가 있습니다.  이때는 뒤의 공백도 주의해야 합니다.
다음 두 명령은 다릅니다:

<code class="example">	:unmap a | unmap b</code>
<code class="example">	:unmap a| unmap b</code>
<code class="example"></code>
첫 번째 명령은 뒤에 공백을 하나 포함한 "a "의 매핑을 지웁니다.

매핑에 공백을 넣고 싶다면 <code class="special">&lt;Space&gt;</code>(일곱글자)를 사용하세요:
<code class="example"></code>
<code class="example">	:map <code class="special">&lt;Space&gt;</code> W</code>
<code class="example"></code>
위와 같이 매핑하면 스페이스바를 누를 때마다 어절 단위(공백으로 구분된)로
이동합니다.

매핑에는 주석을 바로 넣을 수 없습니다.  " 문자 자체가 매핑의 일부로 간주되기
때문입니다.  이럴 땐 |"를 사용하여 주석만으로 이루어진 빈 명령을 추가하면
됩니다.  예:
<code class="example"></code>
<code class="example">	:map <code class="special">&lt;Space&gt;</code> W|     " 스페이스바로 어절 단위 이동</code>
<code class="example"></code>
<code class="example"></code>
매핑과 약어
-----------

약어(Abbreviation)는 입력 모드의 매핑과 매우 유사합니다.  인자들도 동일한
방식으로 사용되고요.  가장 큰 차이는 동작 시점에 있습니다.  약어는 약어를
입력한 후, 단어가 아닌(non-word) 글자를 입력할 때 동작합니다.  매핑은 매핑의
마지막 글자를 입력할 때 동작합니다.
   또 다른 차이는 약어의 경우 입력중인 글자가 화면에 표시됩니다.  약어가
인식되면 입력했던 글자가 사라지면서 지정된 전체 문구로 바뀝니다.  매핑을
입력할 때는, 매핑의 마지막 글자로 동작이 시작될 때까지 화면에 아무것도
나타나지 않습니다.  만약 'showcmd' 옵션이 켜져있다면, Vim 창의 맨 밑줄에
입력된 글자들이 표시될 겁니다.
   매핑이 모호한 경우에는 예외인데요.  다음 두 매핑이 있다고 합시다:
<code class="example"></code>
<code class="example">	:imap aa foo</code>
<code class="example">	:imap aaa bar</code>
<code class="example"></code>
"aa"를 입력하면, Vim은 첫 번째 매핑을 적용해야할지, 아니면 두 번째 매핑일 수도
있으니 기다려야할 지 알 수가 없습니다.  이때는 다음 입력을 기다립니다.  만약
"a"가 입력되면 두 번째 매핑이 적용되면서 "bar"가 나타납니다.  만약 다른 문자,
예를 들어 공백이 입력되면, 첫 번째 매핑이 적용되며 "foo"가 나타난 후, 공백이
이어서 나타납니다.


추가로...
---------

<code class="special">&lt;script&gt;</code> 키워드를 써서 매핑을 스크립트 내에서만 사용할 수 있습니다.
|<code class="badlink">:map-&lt;script&gt;</code>|를 참고하세요.

<code class="special">&lt;buffer&gt;</code> 키워드를 써서 매핑을 특정 버퍼 내에서만 사용할 수 있습니다.
|<code class="badlink">:map-&lt;buffer&gt;</code>|를 참고하세요.

<code class="special">&lt;unique&gt;</code> 키워드를 써서 다른 매핑으로 덮어쓰여지지 않게 할 수 있습니다.  아니면
새로 매핑을 정의할 때 기존 매핑은 사라집니다.  |<code class="badlink">:map-&lt;unique&gt;</code>|를 참고하세요.

어떤 키가 아무 일도 하지 않게 하려면, <code class="special">&lt;Nop&gt;</code>(다섯 글자)에 매핑하세요.  다음
매핑은 <code class="special">&lt;F7&gt;</code>키가 아무 것도 하지 않게 만듭니다:
<code class="example"></code>
<code class="example">	:map <code class="special">&lt;F7&gt;</code> <code class="special">&lt;Nop&gt;</code>| map! <code class="special">&lt;F7&gt;</code> <code class="special">&lt;Nop&gt;</code></code>
<code class="example"></code>
단, <code class="special">&lt;Nop&gt;</code>뒤에 공백이 없다는 데 주의하세요.

</pre><hr><pre><b class="vimtag">*<a name="40.2">40.2</a>*</b>	명령줄 명령 정의

Vim에서는 나만의 명령을 정의할 수 있습니다.  정의한 명령은 다른 명령줄 모드
명령과 동일하게 사용할 수 있습니다.
   명령을 정의하려면, 다음과 같이 ":command" 명령을 사용하세요:
<code class="example"></code>
<code class="example">	:command DeleteFirst 1delete</code>
<code class="example"></code>
이제 ":DeleteFirst" 명령을 실행하면, Vim은 ":1delete"를 실행하고, 첫 번째 줄이
지워집니다.

	<code class="note">Note:</code>
	사용자 정의 명령은 반드시 대문자로 시작해야 합니다.  단, ":X",
	":Next", ":Print"는 사용할 수 없습니다.  밑줄도 사용할 수 없습니다.
	숫자는 사용할 수 있지만, 쓰지 않는 편이 좋습니다.

사용자 정의 명령을 보려면, 다음 명령을 사용하세요:
<code class="example"></code>
<code class="example">	:command</code>
<code class="example"></code>
내장 명령들과 마찬가지로, 사용자 정의 명령도 줄여서 쓸 수 있습니다.  다른
명령과 겹치지 않는 최소한의 앞부분만 입력하면 됩니다.  전체 이름을 얻기 위해
명령줄 자동 완성을 쓸 수도 있습니다.


인자의 수
---------

사용자 정의 명령은 일련의 인자들을 가질 수 있습니다.  인자의 수는 -nargs
옵션으로 지정되어야 합니다.  예를 들어 위의 ":DeleteFirst 명령은 인자가 없고,
다음과 같이 정의할 수도 있습니다:
<code class="example"></code>
<code class="example">	:command -nargs=0 DeleteFirst 1delete</code>
<code class="example"></code>
하지만, 인자가 없는 것이 기본 값이므로, "-nargs=0"을 쓸 필요는 없습니다.
-nargs에 쓸 수 있는 값은 다음과 같습니다:

	-nargs=0	인자 없음
	-nargs=1	하나의 인자
	-nargs=*	몇 개든 상관 없음
	-nargs=?	없거나 하나
	-nargs=+	하나 또는 그 이상


인자 사용하기
-------------

명령을 정의할 때, 인자들은 <code class="special">&lt;args&gt;</code> 키워드로 표현됩니다.  예:
<code class="example"></code>
<code class="example">	:command -nargs=+ Say :echo "<code class="special">&lt;args&gt;</code>"</code>
<code class="example"></code>
이제 다음과 같이 입력하면
<code class="example"></code>
<code class="example">	:Say Hello World</code>
<code class="example"></code>
Vim은 "Hello World"를 출력합니다.  하지만, 따옴표를 넣으면 동작하지
않을겁니다.  예:
<code class="example"></code>
<code class="example">	:Say "안녕" 하고 말했습니다.</code>
<code class="example"></code>
특수 문자를 표현식에 사용할 수 있도록 적절히 문자열로 변환하려면 "<code class="special">&lt;q-args&gt;</code>"를
사용하세요:
<code class="example"></code>
<code class="example">	:command -nargs=+ Say :echo <code class="special">&lt;q-args&gt;</code></code>
<code class="example"></code>
이제 위 ":Say" 명령은 다음과 같이 실행됩니다:
<code class="example"></code>
<code class="example">	:echo "\"안녕\" 하고 말했습니다."</code>
<code class="example"></code>
함수의 인자로 사용할 수 있게 변환해야할 때는 <code class="special">&lt;f-args&gt;</code> 키워드를 사용하세요.
예:
<code class="example"></code>
<code class="example">	:command -nargs=* DoIt :call AFunction(<code class="special">&lt;f-args&gt;</code>)</code>
<code class="example">	:DoIt a b c</code>
<code class="example"></code>
위 예는 다음과 같이 동작합니다:
<code class="example"></code>
<code class="example">	:call AFunction("a", "b", "c")</code>
<code class="example"></code>
<code class="example"></code>
줄 범위
-------

몇몇 명령은 범위를 인자로 받습니다.  이런 명령을 정의할 때는 -range 옵션을
사용하세요.  이 옵션에 쓸 수 있는 값은 다음과 같습니다:

	-range		범위 사용 가능. 기본 값은 현재 줄.
	-range=%	범위 사용 가능. 기본 값은 전체 파일.
	-range=<code class="special">{count}</code>	범위 사용 가능. 범위의 마지막 줄 숫자가 <code class="special">{count}</code>로
			사용되며, 기본 값은 <code class="special">{count}</code>.

범위가 지정되면, <code class="special">&lt;line1&gt;</code>과 <code class="special">&lt;line2&gt;</code>에 범위의 처음와 마지막 줄 번호가
들어갑니다.  예를 들어, 다음 명령은 지정된 범위의 내용을 "save_file"이란
파일에 저장하는 SaveIt 명령을 정의합니다:
<code class="example"></code>
<code class="example">	:command -range=% SaveIt :<code class="special">&lt;line1&gt;</code>,<code class="special">&lt;line2&gt;</code>write! save_file</code>
<code class="example"></code>
<code class="example"></code>
기타 옵션
---------

그 밖의 옵션이나 키워드는 다음과 같습니다:

	-count=<code class="special">{number}</code>		명령 앞에 숫자를 받을 수 있습니다.  기본 값은
				<code class="special">{number}</code>이고, 이 숫자는 <code class="special">&lt;count&gt;</code> 키워드로
				사용합니다.
	-bang			!를 사용할 수 있습니다.  !와 함께 사용되면,
				<code class="special">&lt;bang&gt;</code>의 값이 !가 됩니다.
	-register		레지스터를 지정할 수 있습니다.  (기본 값은
				익명 레지스터.)
				레지스터는 <code class="special">&lt;reg&gt;</code> (또는 <code class="special">&lt;register&gt;</code>)로
				사용합니다.
	-complete=<code class="special">{type}</code>	명령줄 자동 완성 형식을 지정합니다.  쓸 수
				있는 값은 |<code class="badlink">:command-completion</code>|를 참고하세요.
	-bar			명령 뒤에 |와 다른 명령을 붙이거나, "와 주석을
				붙일 수 있습니다.
	-buffer			현재 버퍼에서만 동작하는 명령을 정의합니다.

마지막으로, <code class="special">&lt;lt&gt;</code> 키워드가 있습니다.  <code class="special">&lt; 문자를 의미합니다.  &lt;&gt;</code>로 인해 문자열에
의도하지 않는 특별한 의미가 생길 때 사용하세요.


재정의 및 삭제
--------------

동일한 명령을 다시 정의하려면 !를 사용하세요:
<code class="example"></code>
<code class="example">	:command -nargs=+ Say :echo "<code class="special">&lt;args&gt;</code>"</code>
<code class="example">	:command! -nargs=+ Say :echo <code class="special">&lt;q-args&gt;</code></code>
<code class="example"></code>
사용자 정의 명령을 지우려면 "delcommand" 명령을 사용하세요.  명령 이름을
인자로 주면 됩니다.  예:
<code class="example"></code>
<code class="example">	:delcommand SaveIt</code>
<code class="example"></code>
모든 사용자 정의 명령을 지우려면:
<code class="example"></code>
<code class="example">	:comclear</code>
<code class="example"></code>
되돌릴 수 없으니 조심하세요!

사용자 정의 명령에 대한 더 자세한 내용은 상세 설명서에 있습니다:
|<code class="badlink">user-commands</code>|.

</pre><hr><pre><b class="vimtag">*<a name="40.3">40.3</a>*</b>	자동명령

자동명령은 특정한 상황, 예를 들어 파일을 읽거나 쓰는 일, 버퍼의 내용이 바뀌는
일 등이 발생할 때 자동으로 실행되는 명령입니다.  예를 들어 자동명령을 사용해서
Vim으로 압축된 파일을 편집할 수 있습니다.  |<code class="badlink">gzip</code>| 플러그인에서 하듯이요.
   자동명령은 매우 강력합니다.  주의깊게 사용하면, 명령 타자 치는 수고를 많이
덜 수 있습니다.  하지만 부주의하게 사용한다면 많은 문제를 일으킬겁니다.

파일을 저장할 때마다, 파일 맨 마지막의 날짜 정보를 바꾸고 싶다고 합시다.  먼저
다음과 같이 함수를 정의합니다:
<code class="example"></code>
<code class="example">	:function DateInsert()</code>
<code class="example">	:  $delete</code>
<code class="example">	:  read !date</code>
<code class="example">	:endfunction</code>
<code class="example"></code>
이 함수가 버퍼를 저장하기 직전에 매번 불려야겠지요.  다음과 같이 하면 됩니다:

<code class="example">	:autocmd BufWritePre *  call DateInsert()</code>
<code class="example"></code>
"BufWritePre"는 자동명령을 작동시키는 이벤트입니다.  버퍼를 파일에 쓰기
직전(pre)을 의미하지요.  "*"은 자동명령을 적용할 파일명 패턴입니다.  이
경우에는 모든 파일에 적용됩니다.
   이 명령이 수행되면, ":write"를 할 때마다 Vim은 해당되는 BufWritePre
자동명령이 있는지 검사합니다.  그래서 자동명령을 수행한 후, 실제로 ":write"를
수행합니다.
   :autocmd 명령의 일반적인 형태는 다음과 같습니다:
<code class="example"></code>
<code class="example">	:autocmd [group] <code class="special">{events}</code> <code class="special">{file_pattern}</code> [nested] <code class="special">{command}</code></code>
<code class="example"></code>
그룹명을 나타내는 [group]은 생략해도 됩니다.  명령을 관리하거나 호출할 때
사용하는 이름입니다(뒤에서 더 살펴보겠습니다).  <code class="special">{events}</code>에는 명령을 작동시킬
이벤트들을 쉼표(,)로 구분하여 나열합니다.
   <code class="special">{file_pattern}</code>에는 파일명의 패턴이 들어갑니다.  보통 와일드카드가
포함되지요.  예를 들어, "*.txt"를 쓰면 ".txt"로 파일명이 끝나는 경우에만
자동명령이 동작합니다.  생략 가능한 옵션인 [nested]는 자동명령의 중첩을
허용할지를 나타냅니다(아래를 보세요).  마지막으로 <code class="special">{command}</code>는 실행할
명령입니다.


이벤트
------

BufReadPost는 가장 유용한 이벤트 중 하나입니다.  새로운 파일의 편집이 시작된
직후에 발생합니다.  옵션 값들을 조정하는데 흔히 사용합니다.  예를 들어,
"*.gsm" 파일은 GNU 어셈블리 언어 파일입니다.  문법 파일을 정확히 지정하기 위해
아래와 같이 자동명령을 정의합니다:
<code class="example"></code>
<code class="example">	:autocmd BufReadPost *.gsm  set filetype=asm</code>
<code class="example"></code>
만약 Vim이 파일 형식을 제대로 인식한다면, 'filetype' 옵션을 적절히 잡아줄
것입니다.  이때 Filetype 이벤트가 발생합니다.  이 이벤트로 특정 형식의 파일에
대해 정해진 일들을 할 수 있습니다.  예를 들어, 텍스트 파일에 대해 미리 만들어
놓은 약어 목록을 불러올 수 있습니다:
<code class="example"></code>
<code class="example">	:autocmd Filetype text  source ~/.vim/abbrevs.vim</code>
<code class="example"></code>
새로운 파일을 편집하기 시작했을 때, 기본 뼈대를 자동으로 넣을 수도 있겠죠:
<code class="example"></code>
<code class="example">	:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c</code>
<code class="example"></code>
|<code class="badlink">autocmd-events</code>|에서 전체 이벤트 목록을 참고하세요.


패턴
-----

<code class="special">{file_pattern}</code> 인자에는 파일 패턴들을 쉼표(,)로 구분하여 나열합니다.  예를
들어, "<b class="vimtag">*<a name=".c,">.c,</a>*</b>.h"는 ".c" 또는 ".h"로 끝나는 파일들을 의미합니다.
   일반적인 와일드카드 문자들도 사용가능합니다.  가장 많이 사용되는 것들을
보면 다음과 같습니다:

	*		모든 문자열
	?		문자 하나에 대응
	[abc]		a, b, c 중 하나에 대응
	.		마침표(.)에 대응
	a<code class="special">{b,c}</code>		"ab"나 "ac"에 대응

패턴 안에 슬래시(/)가 있는 경우, 디렉터리와 비교합니다.  슬래시가 없으면
파일명의 마지막 부분만 비교에 쓰입니다.  예를 들어, "*.txt" 패턴은
"/home/biep/readme.txt"와 일치합니다.  "/home/biep/*" 패턴도 일치합니다.
하지만 "home/foo/*.txt"는 일치하지 않습니다..
   슬래시를 넣으면 파일의 전체 경로("/home/biep/readme.txt")와 상대
경로("biep/readme.txt") 모두에 대해 일치하는지를 검사합니다.

	<code class="note">Note:</code>
	자동명령에서는 윈도와 같이 백슬래시를 구분자로 이용하는 시스템에서도
	슬래시(/)를 사용합니다.  백슬래시는 이미 특별한 용도로 사용되고 있기
	때문에, 좀 더 패턴을 쓰기 쉽게 하고, 이식이 용이하게 하기 위함입니다.


삭제하기
--------

자동명령을 삭제하려면, 정의할 때와 같이 쓰고, 대신 <code class="special">{command}</code> 부분을 지우고
명령 뒤에 !를 붙이십시오.  예:
<code class="example"></code>
<code class="example">	:autocmd! FileWritePre *</code>
<code class="example"></code>
위 명령은 "FileWritePre" 이벤트의 "*" 패턴에 대응된 모든 자동명령을 지웁니다.


나열하기
--------

현재 정의된 모든 자동명령을 보려면:
<code class="example"></code>
<code class="example">	:autocmd</code>
<code class="example"></code>
이 목록은 매우 길 겁니다.  특히 파일 형식 인식을 사용하고 있다면 말이죠.
자동명령 중 일부만 확인하려면, 그룹이나 이벤트, 패턴을 같이 쓰십시오.  예를
들어, 모든 BufNewFile 자동명령을 확인하려면:
<code class="example"></code>
<code class="example">	:autocmd BufNewFile</code>
<code class="example"></code>
"*.c" 패턴에 해당하는 모든 자동명령을 보려면:
<code class="example"></code>
<code class="example">	:autocmd <b class="vimtag">*<a name=" "> </a>*</b>.c</code>
<code class="example"></code>
모든 이벤트에 대해서 보려면 이벤트 자리에 "*"를 사용하세요.  cprograms 그룹의
모든 자동명령을 보려면:
<code class="example"></code>
<code class="example">	:autocmd cprograms</code>
<code class="example"></code>
<code class="example"></code>
그룹
-----

<code class="special">{group}</code>은 자동명령을 정의할 때 연관된 자동명령들을 하나로 묶습니다.  이렇게
묶인 자동명령들은 예를 들어 특정 그룹의 모든 자동명령을 지우거나 할 때 쓸 수
있습니다.
   한 그룹의 여러 자동명령을 한 번에 정의할 때는 ":augroup" 명령을 사용하세요.
예를 들어 C 프로그램을 위한 자동명령들을 정의해봅시다:
<code class="example"></code>
<code class="example">	:augroup cprograms</code>
<code class="example">	:  autocmd BufReadPost <b class="vimtag">*<a name=".c,">.c,</a>*</b>.h :set sw=4 sts=4</code>
<code class="example">	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3</code>
<code class="example">	:augroup END</code>
<code class="example"></code>
다음과 같이 하는 것과 마찬가지입니다:
<code class="example"></code>
<code class="example">	:autocmd cprograms BufReadPost <b class="vimtag">*<a name=".c,">.c,</a>*</b>.h :set sw=4 sts=4</code>
<code class="example">	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3</code>
<code class="example"></code>
"cprograms" 그룹의 모든 자동명령을 지우려면:
<code class="example"></code>
<code class="example">	:autocmd! cprograms</code>
<code class="example"></code>
<code class="example"></code>
중첩
-----

일반적으로, 자동명령 때문에 실행되는 명령들은 새로운 이벤트를 만들지 않습니다.
예를 들어, FileChangedShell 이벤트로 인해 실행되는 자동명령에서 파일을
읽어들인 경우, 문법을 지정하는 자동명령이 실행되지 않습니다.  자동명령이
이벤트를 발생시키도록 하려면, "nested" 인자를 추가하십시오:
<code class="example"></code>
<code class="example">	:autocmd FileChangedShell * nested  edit</code>
<code class="example"></code>
<code class="example"></code>
자동명령 실행하기
-----------------

마치 어떤 이벤트가 일어난 것처럼 자동명령을 실행시킬 수 있습니다.  어떤
자동명령 안에서 다른 자동명령을 실행시키고 싶을 때 유용하지요.  예:
<code class="example"></code>
<code class="example">	:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("<code class="special">&lt;afile&gt;</code>:r")</code>
<code class="example"></code>
위 명령은 새로운 파일이 편집될 때 동작하는 자동명령을 정의합니다.  파일명은
".new"로 끝나야 합니다.  ":execute" 명령은 표현식을 평가하여 새로운 명령을
만들고 실행합니다.  "tryout.c.new" 파일을 편집할 때 실행되는 명령은:
<code class="example"></code>
<code class="example">	:doautocmd BufReadPost tryout.c</code>
<code class="example"></code>
expand() 함수는 "<code class="special">&lt;afile&gt;</code>" 인자를 받는데, 이는 자동명령이 실행되는 대상
파일명을 의미합니다.  그리고 ":r" 수식어로 인해 파일명에서 확장자를 제외한
부분만을 취합니다.

":doautocmd"는 현재 버퍼에 대해서만 동작합니다.  ":doautoall" 명령은 모든
버퍼에 대해서 동작한다는 점만 빼고 ":doautocmd"와 동일합니다.


보통 모드 명령 사용하기
-----------------------

자동명령에서 실행되는 명령들은 명령줄 명령입니다.  보통 모드 명령을
사용하려면, ":normal" 명령을 사용하면 됩니다.  예:
<code class="example"></code>
<code class="example">	:autocmd BufReadPost *.log normal G</code>
<code class="example"></code>
이 명령을 사용하면 *.log 파일을 열면 커서가 항상 맨 마지막 줄로 이동합니다.
   ":normal" 명령을 사용하는 것은 약간 까다로운 점이 있습니다.  먼저 인자가
보통 모드 명령의 인자를 포함하여 완전한 명령인지 확인해야 합니다.  입력
모드로 들어가기 위해 "i"를 사용했다면, 입력 모드를 떠나는 <code class="special">&lt;Esc&gt;</code>도 반드시
있어야 합니다.  찾기 패턴을 입력하기 위해 "/"를 사용했다면, 이를 이용하기
위한 <code class="special">&lt;CR&gt;</code>도 반드시 있어야 합니다.
   ":normal" 명령은 모든 인자의 내용을 명령으로 사용합니다.  따라서 |나 다른
명령이 뒤에 올 수 없습니다.  이 문제를 비켜가려면 ":normal" 명령을 ":execute"
명령 안에서 사용하십시오.  이 방법을 사용하면 인쇄불가능한 문자도 편리하게
입력할 수 있습니다.  예:
<code class="example"></code>
<code class="example">	:autocmd BufReadPost *.chg execute "normal ONew entry:\<code class="special">&lt;Esc&gt;</code>" |</code>
<code class="example">		\ 1read !date</code>
<code class="example"></code>
위 예는 긴 명령을 여러 줄로 나눠 넣기 위해 백슬래시를 사용하고 있습니다.  이건
Vim 스크립트에서만 됩니다 (명령줄에서는 안됩니다).

자동명령에서 뭔가 복잡한 일을 하고 싶으시다고요?  파일 여기 저기를 헤집고
다니다가 다시 처음의 위치로 돌아와서 처음에 보이던 상태대로 보여주고 싶다면,
|<code class="badlink">restore-position</code>|의 예를 참고하세요.


이벤트 무시하기
---------------

때때로, 자동명령을 사용하지 않고 싶을 수도 있습니다.  'eventignore' 옵션에
무시할 이벤트 목록을 넣으면 됩니다.  예를 들어, 다음 설정은 창에 들어가거나
나오는 이벤트를 무시하도록 만듭니다:
<code class="example"></code>
<code class="example">	:set eventignore=WinEnter,WinLeave</code>
<code class="example"></code>
모든 이벤트를 무시하려면, 다음 명령을 사용하세요:
<code class="example"></code>
<code class="example">	:set eventignore=all</code>
<code class="example"></code>
일반적인 동작으로 되돌리려면, 'eventignore' 옵션에 빈 값을 주면 됩니다:
<code class="example"></code>
<code class="example">	:set eventignore=</code>
<code class="example"></code>
</pre><hr><pre><code class="example"></code>
다음 장: |<a href="usr_41.html#usr_41.txt">usr_41</a>|  Vim 스크립트 만들기

저작권: |<a href="usr_01.html#manual-copyright">manual-copyright</a>| 참고  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2013. 12. 14. (토) 19:53:58 KST</i></p>
</body>
</html>
