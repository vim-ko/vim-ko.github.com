<!DOCTYPE html>
<html>
<head>
<title>VIM: usr_07</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>USR_07</h2>
<pre>
<b class="vimtag">*<a name="usr_07.txt">usr_07.txt</a>*</b>	Vim version 7.4 대상.   새로 고침 : 2006년 4월 24일

		      VIM 사용설명서 - Bram Moolenaar 씀
				       박용운 번역

			  여러 파일 편집하기


아무리 편집할 파일이 많다고 하더라도 Vim에서 나가지 않고 편집할 수 있습니다.
작업할 파일들의 목록을 정의하고 한 파일에서 다른 파일로 이동하십시오.
한 파일에서 내용을 복사하고 다른 파일에 붙여 넣으십시오.

|<a href="usr_07.html#07.1">07.1</a>|	다른 파일 편집하기
|<a href="usr_07.html#07.2">07.2</a>|	파일 목록
|<a href="usr_07.html#07.3">07.3</a>|	파일에서 파일로 이동하기
|<a href="usr_07.html#07.4">07.4</a>|	백업 파일
|<a href="usr_07.html#07.5">07.5</a>|	파일 간에 내용 복사하기
|<a href="usr_07.html#07.6">07.6</a>|	파일 보기
|<a href="usr_07.html#07.7">07.7</a>|	파일 이름 바꾸기

     다음 장 : |<code class="badlink">usr_08</code>|   창 나누기
     이전 장 : |<code class="badlink">usr_06</code>|   문법 강조 사용하기
        차례 : |<code class="badlink">usr_toc</code>|

</pre><hr><pre><b class="vimtag">*<a name="07.1">07.1</a>*</b>	다른 파일 편집하기

지금까지는 편집하고자하는 모든 파일 각각에 대해 Vim을 시작해야만 했습니다.  더
간단한 방법이 있습니다.  다른 파일의 편집을 시작하려면 다음 명령을
사용하십시오:
<code class="example"></code>
<code class="example">	:edit foo.txt</code>
<code class="example"></code>
"foo.txt" 대신 어떤 파일 이름이든 사용할 수 있습니다.  Vim은 현재 파일을 닫고
새 파일을 열 것입니다.  그렇지만 만약 현재 파일의 바뀐 내용이 저장되지
않았다면 Vim은 에러 메시지를 보여주고 새 파일을 열지 않습니다.

<code class="section">     E37: 마지막으로 바꾼 다음 쓰지 않았습니다.(무시하려면 !를 사용하십시오.)</code>

	<code class="note">Note:</code>
	Vim은 각 에러 메시지의 시작부분에 에러 ID를 넣습니다.
	에러 메시지나 에러의 원인을 이해할 수 없다면
	에러 ID를 도움말에서 찾아보십시오.  이런 경우에는:
<code class="example"></code>
<code class="example">		:help E37</code>
<code class="example"></code>
이에 대해 많은 대처방안들이 있습니다.  다음 명령을 이용해서 파일에 쓸 수
있습니다:
<code class="example"></code>
<code class="example">	:write</code>
<code class="example"></code>
또는 강제 문자(!)를 사용해서 바꾼 내용을 무시하고 새 파일을 편집할 수
있습니다:
<code class="example"></code>
<code class="example">	:edit! foo.txt</code>
<code class="example"></code>
현재 편집중인 파일에 바뀐 내용을 쓰지 않고 다른 파일을 편집하고 싶다면 파일을
감출 수 있습니다:
<code class="example"></code>
<code class="example">	:hide edit foo.txt</code>
<code class="example"></code>
바뀐 내용은 여전히 이전 파일에 존재하지만 볼 수는 없습니다.  이에 대해서는
|<a href="usr_22.html#22.4">22.4</a>|: 버퍼 목록에서 설명할 것입니다.

</pre><hr><pre><b class="vimtag">*<a name="07.2">07.2</a>*</b>	파일목록

일련의 파일을 편집하기 위해 Vim을 시작할 수 있습니다.  예를 들어:
<code class="example"></code>
<code class="example">	vim one.c two.c three.c</code>
<code class="example"></code>
이 명령은 Vim을 시작하고 3개의 파일을 편집할 것임을 알려줍니다.  Vim은 첫 번째
파일만 보여줍니다.  첫 번째 파일에 대해 작업을 완료한 이후 아래 명령을
사용해서 그 다음 파일을 편집할 수 있습니다:
<code class="example"></code>
<code class="example">	:next</code>
<code class="example"></code>
현재 파일에 바꾼 내용을 저장하지 않았다면 에러 메시지를 받을 것이고 ":next"
명령은 실행되지 않을 것입니다.  이전 절에서 언급했던 ":edit"와 같은
문제입니다.  바꾼 내용을 버리려면:
<code class="example"></code>
<code class="example">	:next!</code>
<code class="example"></code>
그렇지만 바뀐 내용을 저장하고 다음 파일로 이동하는 것이 일반적입니다.  이를
위해 특별한 명령이 있습니다:
<code class="example"></code>
<code class="example">	:wnext</code>
<code class="example"></code>
이것은 단일 명령 2개를 사용한 것과 같습니다:
<code class="example"></code>
<code class="example">	:write</code>
<code class="example">	:next</code>
<code class="example"></code>
<code class="example"></code>
여기는 어디입니까?
------------------

인자목록 중 어느 파일을 편집하고 있는지를 보려면 창 제목을 보십시오.  "(2 of
3)" 과 같은 것이 보일 것입니다.  이는 3개의 파일 중 2번째 파일이라는 뜻입니다.
파일 목록을 보고 싶다면 다음의 명령을 사용하십시오:
<code class="example"></code>
<code class="example">	:args</code>
<code class="example"></code>
이것은 "arguments"의 짧은 표현입니다.  결과는 다음과 같습니다:

<code class="section">	one.c [two.c] three.c </code>

이 파일들은 Vim을 시작할 때 인자로 준 것들입니다.  현재 편집 중인 파일
"two.c"는 대괄호로 묶여 있습니다.


다른 인자들로 이동하기
----------------------

이전 파일로 돌아가려면:
<code class="example"></code>
<code class="example">	:previous</code>
<code class="example"></code>
이 명령은 다른 방향으로 움직인다는 것을 제외하면 ":next" 명령과 같습니다.
이동하기 전, 파일에 먼저 쓰길 원할 때 사용하는 단축 명령입니다:
<code class="example"></code>
<code class="example">	:wprevious</code>
<code class="example"></code>
목록의 가장 마지막 파일로 이동하려면:
<code class="example"></code>
<code class="example">	:last</code>
<code class="example"></code>
그리고 다시 첫 번째 파일로 돌아가려면:
<code class="example"></code>
<code class="example">	:first</code>
<code class="example"></code>
":wlast"나 ":wfirst" 명령은 없습니다!

":next"와 ":previous"에 횟수를 적용할 수 있습니다.  2파일 앞으로 이동하려면:
<code class="example"></code>
<code class="example">	:2next</code>
<code class="example"></code>
<code class="example"></code>
자동 쓰기
---------

파일들을 돌아다니며 바꾼 내용이 있을 때 ":write"를 사용해야하는 것을
기억하십시오.  그렇지 않으면 에러 메시지가 나옵니다.  수정된 파일을 항상 쓰고
싶다면 Vim이 자동으로 쓰게 할 수 있습니다:
<code class="example"></code>
<code class="example">	:set autowrite</code>
<code class="example"></code>
쓰기 원하지 않는 파일을 편집하고 있을 때에는 다시 자동쓰기 기능을 끄십시오:
<code class="example"></code>
<code class="example">	:set noautowrite</code>
<code class="example"></code>
<code class="example"></code>
다른 파일 목록 편집하기
-----------------------

Vim을 재시작할 필요 없이 파일 목록을 재정의 할 수 있습니다.  3개의 다른
파일을 편집하려면 다음 명령을 사용하십시오:
<code class="example"></code>
<code class="example">	:args five.c six.c seven.h</code>
<code class="example"></code>
혹은 셸에서 쓰는 것처럼 와일드카드 문자를 사용할 수 있습니다:
<code class="example"></code>
<code class="example">	:args *.txt</code>
<code class="example"></code>
Vim은 목록의 첫 번째 파일을 보여줄 것입니다.  현재 파일에 바뀐 내용이 있다면
먼저 파일에 쓰거나 ":args!"(! 가 추가되었습니다.)를 사용해서 바뀐 내용을
포기합니다.


마지막 파일을 편집했었습니까?
-----------------------------
							<b class="vimtag">*<a name="arglist-quit">arglist-quit</a>*</b>
파일 목록을 사용할 때 Vim은 목록에 있는 모든 파일을 편집한다고 가정합니다.
너무 일찍 종료하는 것을 방지하기 위해서 목록의 마지막 파일을 편집하지 않았을
때 다음 에러가 발생합니다:

<code class="section">	E173: 고칠 파일이 46 개 더 있습니다 </code>

만약 정말 종료하길 원한다면 단지 다시 시도하기만 하면 됩니다.  그러면 종료될
것입니다.  (그렇지만 중간에 다른 명령들을 실행했다면 되지 않습니다.)

</pre><hr><pre><b class="vimtag">*<a name="07.3">07.3</a>*</b>	파일에서 파일로 이동하기

두 개의 파일 사이를 빠르게 이동하려면, CTRL-^를 누르십시오.  (일반 키보드에서
^는 6키 위에 있습니다.)  예를 들어:
<code class="example"></code>
<code class="example">	:args one.c two.c three.c</code>
<code class="example"></code>
지금 one.c에 있습니다:
<code class="example"></code>
<code class="example">	:next</code>
<code class="example"></code>
이제는 two.c에 있습니다.  여기서 CTRL-^를 사용하면 one.c로 돌아갑니다.  다시
CTRL-^를 사용하면 two.c로 돌아갑니다.  한 번 더 CTRL-^를 사용하면 one.c로 다시
돌아갑니다.  만약 지금 다음을 실행한다면:
<code class="example"></code>
<code class="example">	:next</code>
<code class="example"></code>
three.c로 이동합니다.  CTRL-^ 명령은 파일 목록에서의 위치 개념을 바꾸지
않는다는 것에 유의하십시오.  파일 목록에서의 위치를 바꾸는 것은 오직 ":next"와
":previous"만이 가능합니다.

이전에 편집했던 파일을 "교대(alternate)" 파일이라 부릅니다.  Vim을 막 시작했을
때 CTRL-^가 동작하지 않는 것은 이전 파일이 없기 때문입니다.


미리 정의된 마크들
------------------

다른 파일로 건너뛴 다음에는 미리 정의된 매우 유용한 두 개의 마크를 사용할 수
있습니다:
<code class="example"></code>
<code class="example">	`"</code>
<code class="example"></code>
이것은 이전에 파일을 나갔을 때 커서가 있던 위치로 옮겨줍니다.  다른 마크는
마지막으로 바꾼 내용의 위치를 기억하고 있습니다:
<code class="example"></code>
<code class="example">	`.</code>
<code class="example"></code>
"one.txt"를 편집하고 있다고 생각해봅시다.  그 파일의 중간쯤에서 문자를
삭제하는 "x"를 사용하십시오.  그러고 나서 "G"를 이용해 마지막 줄로 이동하고
":w"로 파일을 쓰십시오.  몇 개의 다른 파일들을 편집하고 ":edit one.txt"을
사용하여 "one.txt"로 돌아가십시오.  여기서 `" 를 사용하면 파일의 마지막 줄로
이동합니다.  `.를 사용하면 삭제했던 문자의 위치로 이동합니다.  파일의
여기저기를 돌아다니는 중에도 다른 내용을 바꾸거나 파일을 나가기 전까지 `"과
`.는 기억되어있는 위치로 이동시켜줍니다.


파일 마크
---------

4장에서 어떻게 "mx"로 파일에 마크를 남기고 "`x"로 마크한 위치로 이동하는 것을
설명했습니다.  이런 방법은 한 파일에서만 동작합니다.  다른 파일을 편집하고 그
파일에 마크(표시)들를 남겼다면 그 마크(표시)들은 그 파일 내에서만 유효합니다.
그러므로 각각의 파일은 그 파일에만 한정되는 자신만의 마크 모음을 가집니다.
   지금까지는 마크에 소문자를 사용했습니다.  물론 대문자를 이용한 마크도
있습니다.  대문자를 이용한 마크들은 전역적이어서 어떤 파일에서든 사용할 수
있습니다.  예를 들어 "foo.txt"를 편집하고 있다고 합시다.  파일의
중간("50%")으로 가서 거기에 F 마크를 해두십시오.  (foo의 F):
<code class="example"></code>
<code class="example">	50%mF</code>
<code class="example"></code>
이제 "bar.txt" 파일을 편집하고 마지막 줄에 B 마크를 해두십시오.(bar의 B):
<code class="example"></code>
<code class="example">	GmB</code>
<code class="example"></code>
여기서 "'F" 명령을 사용해서 foo.txt의 중간으로 이동할 수 있습니다.  또는 다른
파일을 편집하다가도 "'B"를 입력하면 다시 bar.txt의 끝으로 이동합니다.  파일
마크들은 어딘가 다른 곳으로 옮겨지기 전까지 기억됩니다.  그러므로 마크를 할 수
있고 편집 중에 시간이 지나도 마크를 해둔 곳으로 이동할 수 있습니다.
   마크에 사용하는 문자와 그것이 어디에 있는지에 대해 간단한 연관성을 생각하는
것은 꽤 유용합니다.  예를 들어 H마크는 헤더 파일에 M은 Makefile 그리고 C는 C
코드 파일에 사용하십시오.

특정 마크의 위치를 보려면 ":marks" 명령에 인자를 주십시오:
<code class="example">	:marks M</code>
<code class="example"></code>
물론 여러 개의 인자를 줄 수도 있습니다:
<code class="example">	:marks MCP</code>
<code class="example"></code>
그곳에 마크가 없더라도 이전이나 새로운 위치로 이동하기 위해서 <code class="keystroke">CTRL-O</code>와
<code class="keystroke">CTRL-I</code>를 사용할 수 있다는 것을 잊지 마십시오.

</pre><hr><pre><b class="vimtag">*<a name="07.4">07.4</a>*</b>	백업 파일

일반적으로 Vim은 백업 파일을 만들지 않습니다.  백업 파일이 필요하다면 다음
명령을 실행하십시오:
<code class="example"></code>
<code class="example">	:set backup</code>
<code class="example"></code>
백업 파일의 이름은 원본 파일 이름의 마지막에 ~를 추가한 것입니다.  예를 들어
data.txt이라는 이름을 가진 파일이 있다면 백업 파일의 이름은 data.txt~입니다.
   백업파일의 끝에 ~가 붙는 것이 싫다면 확장자를 바꿀 수 있습니다:
<code class="example"></code>
<code class="example">	:set backupext=.bak</code>
<code class="example"></code>
이제 data.txt~ 대신에 data.txt.bak를 사용할 것입니다.
   다른 옵션은 'backupdir'입니다.  이 옵션은 백업파일을 어디에 쓸 것인지를
지정합니다.  기본적으로 원본 파일과 같은 디렉터리에 백업파일을 쓰는데 대체로
맞습니다.

        <code class="note">Note:</code>
	'backup' 옵션이 설정되어 있지 않아도  'writebackup'이 설정되어 있다면
	Vim은 여전히 백업파일을 만들 것입니다.  그러나 파일에 쓰는 것이 성공적
	완료되는 즉시 삭제됩니다.  이 기능은 어떤 이유(디스크가 꽉 찬 것은
	가장 흔한 이유입니다.  흔하지는 않지만 번개에 맞는 경우도
	있습니다.)에서든 쓰기에 실패했을 때 원본 파일의 소실에 대비하기 위한
	것입니다.


원본 파일 보존하기
------------------

소스 파일을 편집한다면 내용을 바꾸기 전에 파일을 보존하고 싶을 것입니다.
그렇지만 백업 파일은 파일에 쓸 때마다 덮어쓰게 됩니다.  처음의 파일이 아닌
단지 이전 버전이 유지되는 것입니다.
   Vim이 원본 파일을 보존하게 하려면 'patchmode' 옵션을 설정하십시오.
'patchmode' 옵션은 바뀐 파일의 첫 번째 백업에 사용되는 확장자를 지정합니다.
이렇게 하십시오 :
<code class="example"></code>
<code class="example">	:set patchmode=.orig</code>
<code class="example"></code>
data.txt파일을 처음으로 편집할 때 파일을 바꾸고 쓰면, Vim은 바뀌지 않은 파일의
복사본을 "data.txt.orig"라는 이름으로 유지할 것입니다.
   파일을 좀 더 바꾼다면 Vim은 "data.txt.orig"가 이미 존재한다는 것을 알려주고
그냥 놔둘 것입니다.  이후의 백업파일들은 "data.txt~"으로 불립니다.  (혹은
'backupext'로 설정해 놓은 것으로 불립니다.)
   'patchmode'를 비워둔다면(이것이 기본입니다.), 원본 파일은 유지되지 않을
것입니다.

</pre><hr><pre><b class="vimtag">*<a name="07.5">07.5</a>*</b>	파일 사이에 내용 복사하기

여기에서는 하나의 파일에서 다른 파일로 내용을 어떻게 복사하는지
설명하겠습니다.  간단한 예제로 시작해봅시다.  복사하고자 하는 내용을 포함하고
있는 파일을 편집하십시오.  커서를 복사하려는 내용의 첫 부분에 놓고 "v"를
눌러서 시각 모드를 시작하십시오.  내용의 마지막 부분에 커서를 이동시키고 "y"를
누르십시오.  이렇게 해서 선택된 내용을 복사합니다.
   바로 위 단락을 복사해보려면 다음과 같이 하십시오:
<code class="example"></code>
<code class="example">	:edit thisfile</code>
<code class="example">	/여기에서는</code>
<code class="example">	vjjjj$y</code>
<code class="example"></code>
이제 내용을 붙여 넣길 원하는 파일을 편집하십시오.  내용이 뒤에 오길 원하는
문자에 커서를 옮긴 다음 "p"를 사용해서 거기에 내용을 붙여 넣으십시오:
<code class="example"></code>
<code class="example">	:edit otherfile</code>
<code class="example">	/저기에</code>
<code class="example">	p</code>
<code class="example"></code>
물론 내용을 뽑아내는 수많은 다른 명령을 사용할 수 있습니다.  예를 들면 몇 줄을
선택하기 위해서 "V"로 시각 모드를 시작한다거나 <code class="keystroke">CTRL-V</code>를 사용해서 사각형 영역을
선택할 수도 있고 "Y"를 사용해서 한 줄을 복사할 수도, "yaw"를 사용해서
한 단어를 복사할 수도 있습니다.

"p" 명령은 커서의 뒤에 내용을 넣습니다.  "P"를 사용하면 커서의 앞에 내용을
넣습니다.  Vim은 복사한 줄이나 블록을 기억하고 있고 그것을 위의 방법으로
붙여 넣는다는 것에 유의하십시오.


레지스터 사용하기
-----------------

본문의 여러 조각을 한 파일에서 다른 파일로 복사하고 싶을 때, 파일 사이를
이동하고 대상 파일에 쓰는데 많은 시간이 걸립니다.  이것을 피하기 위해, 각
조각을 각각의 레지스터에 복사합니다.
   레지스터는 Vim이 내용을 저장하는 공간입니다.  여기에서는 a에서 z까지
이름붙인 레지스터를 사용할 것입니다.(나중에 다른 것들도 찾아낼 것입니다.) f
레지스터에 문장을 복사해봅시다.(First의 f):
<code class="example"></code>
<code class="example">	"fyas</code>
<code class="example"></code>
이전처럼 "yas" 명령은 문장을 뽑아냅니다.  "f는 Vim에게 내용을 f레지스터에
위치시킬 것을 지시합니다.  이것은 반드시 복사하는 명령 앞에 와야 합니다.
이제 3개의 줄을 l 레지스터에 복사하십시오(line의 l) :
<code class="example"></code>
<code class="example">	"l3Y</code>
<code class="example"></code>
"l 앞에 개수가 있을 수 있습니다.  본문 블록을 b(block의 b) 레지스터에
복사하려면:
<code class="example"></code>
<code class="example">	<code class="keystroke">CTRL-Vjjww</code>"by</code>
<code class="example"></code>
"y" 명령 바로 앞에 레지스터 지시자 "b가 있다는 것에 주의하십시오.  필수입니다.
"w" 명령 이전에 그것을 넣으면 동작하지 않습니다.
   이제 3개의 조각을 f, l, b 레지스터에 가지고 있습니다.  다른 파일들을
편집하고 돌아다니다가 원하는 위치에 내용을 넣으십시오:
<code class="example"></code>
<code class="example">	"fp</code>
<code class="example"></code>
여기서도 "p" 명령 앞에 레지스터 지시자 "f 가 옵니다.
   어떤 명령에도 레지스터들을 넣을 수 있습니다.  그리고 다른 것을 복사해 넣기
전에는 그 내용은 레지스터 안에 있습니다.  그래서 레지스터에 있는 내용을
원하는 대로 붙여 넣을 수 있습니다.

내용을 지울 때도 레지스터를 명시할 수 있습니다.  이를 몇 개의 조각을 옮기는데
사용하십시오.  예를 들어, 한 단어를 지우고 그것을 w 레지스터에 쓰려면:
<code class="example"></code>
<code class="example">	"wdaw</code>
<code class="example"></code>
여기서도 삭제 명령 "d" 앞에 레지스터 지시자가 옵니다.


파일에 추가하기
---------------

여러 줄들을 하나의 파일로 모을 때 다음의 명령을 사용할 수 있습니다:
<code class="example"></code>
<code class="example">	:write &gt;&gt; logfile</code>
<code class="example"></code>
이렇게 하면 "logfile"의 끝에 현재 파일의 내용을 씁니다.  그래서 추가라고
합니다.  여러 줄을 복사하고 로그파일을 열어서 거기에 붙여 넣어야 하는 것을
피할 수 있습니다.  그렇게 2단계를 절약할 수 있습니다.  그렇지만 파일을
끝부분에만 추가할 수 있습니다.
   몇 줄만 추가하려고 한다면 ":write"를 입력하기 전에 시각 모드에서 추가할
줄을 선택하십시오.  10장에서 줄의 범위를 선택하는 다른 방법들을 배울 것입니다.

</pre><hr><pre><b class="vimtag">*<a name="07.6">07.6</a>*</b>	파일 보기

가끔 쓰지 않고 파일 내용만을 보고 싶을 때가 있습니다.  그렇지만 그런 경우에
생각 없이 ":w"를 치고 원본 파일에 덮어쓸 위험이 있습니다.  이런 위험을 피하기
위해 파일을 읽기 전용으로 편집할 수 있습니다.  읽기 전용 모드로 Vim을
시작하려면 다음 명령을 사용하십시오:
<code class="example"></code>
<code class="example">	vim -R file</code>
<code class="example"></code>
유닉스에서 다음 명령도 같은 역할을 합니다:
<code class="example"></code>
<code class="example">	view file</code>
<code class="example"></code>
이제 "file"을 읽기 전용 모드로 편집하고 있습니다.  ":w"를 사용하려고하면
에러 메시지를 받을 것이고 파일에는 써지지는 않습니다.
파일 내용을 바꾸려고 하면 Vim은 다음과 같이 경고할 것입니다.

<code class="section">        W10: 경고: 읽기 전용 파일을 고치고 있습니다</code>

경고에도 불구하고 파일은 바뀔 것입니다.  이런 사실을, 예를 들어, 파일을 읽기
좋게 하기 위해 형식화할 때 고려할 수 있습니다.
   파일이 읽기 전용인 것을 잊고 파일을 바꾸었다고 해도 파일에 쓸 수 있습니다.
강제로 쓰려면 쓰기 명령에 !를 붙이십시오.

정말로 파일을 변경할 수 없게 하고 싶다면 다음과 같이 하십시오:
<code class="example"></code>
<code class="example">	vim -M file</code>
<code class="example"></code>
이제 내용을 바꾸려고 하면 실패할 것입니다.  예를 들면, 도움말 파일이 이렇게
되어 있습니다.  만약 변경하려 한다면 다음 에러 메시지를 받을 것입니다.

<code class="section">        E21: 바꿀 수 없음, 'modifiable'이 꺼져있습니다</code>

Vim이 관찰모드로 동작하게 설정하려면 -M 인자를 사용할 수 있습니다.  의도적으로
한 것이긴 하지만 다음 명령들로 보호를 제거할 수 있습니다:
<code class="example"></code>
<code class="example">	:set modifiable</code>
<code class="example">	:set write</code>
<code class="example"></code>
</pre><hr><pre><b class="vimtag">*<a name="07.7">07.7</a>*</b>	파일 이름 바꾸기

새로운 파일의 편집을 시작하는 현명한 방법은 원하는 내용을 대부분 포함하고 있는
기존 파일을 사용하는 것입니다.  예를 들어, 파일을 옮기는 프로그램을 새로
작성한다고 합시다.  이미 파일을 복사하는 프로그램이 있다고 가정하고 이렇게
시작합시다:
<code class="example"></code>
<code class="example">	:edit copy.c</code>
<code class="example"></code>
원하지 않는 내용은 삭제할 수 있습니다.  그 파일을 새 이름으로 저장하고 싶을 때
"saveas" 명령을 사용합니다:
<code class="example"></code>
<code class="example">	:saveas move.c</code>
<code class="example"></code>
Vim은 주어진 이름(move.c)으로 파일을 쓰고 그 파일(move.c)을 편집합니다.
그러므로 다음에 ":write"를 사용하면 "move.c"에 쓸 것입니다.  "copy.c"는 바뀌지
않습니다.
   편집 중에 파일을 쓰지 않고 이름만 바꾸고 싶다면 다음 명령을 사용할 수
있습니다:
<code class="example"></code>
<code class="example">	:file move.c</code>
<code class="example"></code>
Vim은 파일에 "편집되지 않음"이라고 표시할 것입니다.  이것은 이 파일이 편집을
시작했던 파일이 아니라는 것을 Vim이 알고 있다는 것을 의미합니다.  그 파일을
쓰려고 하면 다음 메시지를 받게 됩니다:

<code class="section">	E13: 파일이 있습니다 (덮어쓰려면 ! 사용)</code>

이것은 실수로 다른 파일에 덮어쓰는 것을 막아줍니다.

</pre><hr><pre>
다음 장: |<a href="usr_08.html#usr_08.txt">usr_08</a>|	창 나누기
저작권: |<a href="usr_01.html#manual-copyright">manual-copyright</a>|참고  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2013. 12. 14. (토) 19:53:58 KST</i></p>
</body>
</html>
