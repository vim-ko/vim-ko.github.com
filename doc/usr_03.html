<!DOCTYPE html>
<html>
<head>
<title>VIM: usr_03</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>USR_03</h2>
<pre>
<b class="vimtag">*<a name="usr_03.txt">usr_03.txt</a>*</b>	Vim version 7.4 대상.  새로 고침: 2006년 6월 21일

		      VIM 사용설명서 - Bram Moolenaar 저
				       정지용 역

				  돌아다니기


무언가 입력하거나 지우기 전에, 먼저 커서를 정확한 위치로 옮겨야 합니다.
Vim에는 커서를 움직이는 많은 명령이 있습니다.  이번 장에서는 이들 중 가장
중요한 것들을 어떻게 사용하는지 살펴봅니다.  이 명령들의 목록은 |<a href="quickref.html#Q_lr">Q_lr</a>|에서 볼
수 있습니다.

|<a href="usr_03.html#03.1">03.1</a>|	어절 이동
|<a href="usr_03.html#03.2">03.2</a>|	줄의 처음이나 끝으로 이동
|<a href="usr_03.html#03.3">03.3</a>|	특정 문자로 이동
|<a href="usr_03.html#03.4">03.4</a>|	괄호 짝 맞추기
|<a href="usr_03.html#03.5">03.5</a>|	특정 줄로 이동
|<a href="usr_03.html#03.6">03.6</a>|	어디에 있는지 알아보기
|<a href="usr_03.html#03.7">03.7</a>|	주위로 스크롤하기
|<a href="usr_03.html#03.8">03.8</a>|	간단한 찾기
|<a href="usr_03.html#03.9">03.9</a>|	간단한 찾기 패턴
|<a href="usr_03.html#03.10">03.10</a>|	마크 사용하기

다음 장: |<a href="usr_04.html#usr_04.txt">usr_04</a>|  약간 고치기
이전 장: |<a href="usr_02.html#usr_02.txt">usr_02</a>|  Vim 첫걸음
   차례: |<a href="usr_toc.html#usr_toc.txt">usr_toc</a>|

</pre><hr><pre><b class="vimtag">*<a name="03.1">03.1</a>*</b>	어절 이동

커서를 한 어절 앞으로 움직이려면, "w" 명령을 사용하세요.  다른 대부분의 Vim
명령들과 마찬가지로, 명령 앞에 숫자를 붙여서 여러 어절을 움직일 수 있습니다.
예를 들어 "3w"는 세 어절을 움직입니다.  아래 그림이 동작을 보여줍니다:

<code class="section">	여기는 예제 문장이 하나 적혀 있는 줄입니다 </code>
	  -----&gt;----&gt;------&gt;--------------&gt;
	    w     w    w         3w

이미 어절의 처음에 있다면 "w"가 다음 어절의 처음으로 움직인다는 데 주목하세요.
   "b" 명령은 뒤로 움직여서 앞 어절의 처음으로 갑니다:

<code class="section">	여기는 예제 문장이 하나 적혀 있는 줄입니다 </code>
	&lt;------&lt;----&lt;------&lt;---------&lt;-
	    b     b     b       2b    b

다음에 오는 어절의 끝으로 움직이는 "e" 명령과 앞 어절의 끝으로 움직이는 "ge"
명령도 있습니다:

<code class="section">	여기는 예제 문장이 하나 적혀 있는 줄입니다 </code>
	    <code class="special">&lt;----&lt;-- ---&gt;</code>----&gt;
	      ge  ge  e   e

만약 줄의 마지막 단어에 있다면, "w" 명령은 다음 줄의 첫 단어로 이동합니다.
따라서 이 명령으로 "l"보다 훨씬 빨리 단락 전체를 이동할 수 있습니다.  "b"는
같은 동작을 반대 방향으로 합니다.

Vim에서 어절은 "."나 "-", ")" 같은 특수 문자에서 끝납니다.  Vim이 어절로
생각하는 기준을 바꾸려면 'iskeyword' 옵션을 확인해보세요.
   특수 문자를 일반 문자와 동일하게 취급하여 움직이는 것도 가능합니다.  아래
그림에서와 같이 대문자 명령을 사용하여 움직이면 됩니다:

	            ge          b   w			       e
	           <code class="special">&lt;-          &lt;-  --&gt;</code>			      --&gt;
<code class="section">	여기는 예제-문장이 하나, 적혀/있는/줄입니다 (특수 문자도요). </code>
	       <code class="special">&lt;-----      &lt;-----  -----------------&gt;</code>         -----&gt;
	          gE           B	 W			E


이 소문자와 대문자 명령들을 조합하면, 단락 내에서 앞뒤로 빠르게 움직일 수
있습니다.

</pre><hr><pre><b class="vimtag">*<a name="03.2">03.2</a>*</b>	줄의 처음이나 끝으로 이동

"$" 명령은 커서를 줄의 맨 끝으로 움직입니다.  키보드에 <code class="special">&lt;End&gt;</code> 키가 있다면
동일한 동작을 합니다.

"^" 명령은 줄의 공백이 아닌 첫 문자로 움직입니다.  "0"(영) 명령은 줄의 맨 첫
문자로 움직입니다.  <code class="special">&lt;Home&gt;</code> 키도 동일한 동작을 합니다.  그림으로 보시죠:

		  ^
	     &lt;------------
<code class="section">	.....여기는 예제 문장이 하나 적혀 있는 줄입니다 </code>
	<code class="special">&lt;-----------------   -------------------------&gt;</code>
		0		   $

(여기서 "....."는 공백을 의미합니다)

   "$" 명령에는 대부분의 이동 명령과 마찬가지로 숫자를 붙일 수 있습니다.
하지만 같은 줄의 끝으로 여러 번 이동하는 것은 말이 안되겠지요.  그래서
여기서는 다른 줄의 끝으로 움직입니다.  예를 들어 "1$"은 첫 번째 줄(현재 위치한
줄)의 끝으로 움직이고, "2$"은 그 다음 줄의 끝으로 움직이는 식입니다.
   "0" 명령은 "0" 자체가 숫자인 관계로 숫자를 붙일 수 없습니다.  의외로, "^"
앞에 숫자를 붙이는 것은 아무런 효과가 없습니다.

</pre><hr><pre><b class="vimtag">*<a name="03.3">03.3</a>*</b>	특정 문자로 이동

아주 유용한 이동 명령 중 하나로 한 문자 찾기 명령이 있습니다.  "fx" 명령은
현재 줄에서 앞으로 가면서 문자 x 를 찾습니다.  힌트: "f"는 "찾기(Find)"를
의미합니다.
   예를 들어, 다음 줄의 맨 처음에 있다고 합시다.  human의 h로 이동하고 싶다고
해봅시다.  "fh"라고만 명령을 입력하면 커서가 h 위로 옮겨갈 것입니다:

<code class="section">	To err is human.  To really foul up you need a computer. </code>
	----------&gt;---------------&gt;
	    fh		 fy

위 예에서는 "fy" 명령으로 really의 끝으로 이동한 것도 볼 수 있습니다.
   숫자를 지정할 수도 있습니다.  즉, "3fl"로 "foul"의 "l"로 갈 수 있습니다:

<code class="section">	To err is human.  To really foul up you need a computer. </code>
		  ---------------------&gt;
			   3fl

"F" 명령은 왼쪽으로 찾습니다:

<code class="section">	To err is human.  To really foul up you need a computer. </code>
		  &lt;---------------------
			    Fh

"tx"는 "fx"와 유사하게 동작하지만, 찾는 문자 한 글자 앞에서 멈춘다는 점이
다릅니다.  힌트: "t"는 "~로(To)"를 의미합니다.  이 명령의 뒤쪽으로 찾는 버전은
"Tx"입니다.

<code class="section">	To err is human.  To really foul up you need a computer. </code>
		   <code class="special">&lt;------------  -------------&gt;</code>
			Th		tn

이 네 가지 명령은 ";"로 반복할 수 있습니다.  ","는 반대 방향으로 반복합니다.
커서는 절대 줄을 벗어나지 않습니다. 문장이 이어지더라도 말이지요.

때로는 찾기를 시작했지만, 명령을 잘못 입력한 것일 수도 있습니다.  예를 들어
뒤로 찾으려고 했는데 "f"를 눌러버린 것을 발견했다고 합시다.  사실은 "F"를
입력했어야 했지요.  찾기를 취소하려면 <code class="special">&lt;Esc&gt;</code>를 누르면 됩니다.  따라서
"f<code class="special">&lt;Esc&gt;</code>"는 앞으로 찾기를 취소한 것이고 아무 일도 일어나지 않습니다.  <code class="note">Note:</code>
<code class="special">&lt;Esc&gt;</code>는 찾기 뿐 아니라 대부분의 동작을 취소시킵니다.

</pre><hr><pre><b class="vimtag">*<a name="03.4">03.4</a>*</b>	괄호 짝 맞추기

프로그램을 작성하다보면 중첩된 ()에 둘러싸이는 경우가 종종 있습니다.  이때는
짝이 되는 괄호로 이동하는 명령인 "%"가 매우 좋습니다.  커서가 "("에 있다면,
짝이 되는 ")"로 이동할 겁니다.  커서가 ")"에 있다면 짝이 되는 "("로
이동합니다.

			    %
			 <code class="special">&lt;-----&gt;</code>
<code class="section">		if (a == (b * c) / d) </code>
		   <code class="special">&lt;----------------&gt;</code>
			    %

이 기능은 []와 <code class="special">{}</code>에도 마찬가지로 동작합니다.  (이 짝은 'matchpairs' 옵션으로
정의할 수 있습니다.)

커서가 짝을 이루는 문자 위에 있지 않다면, "%"는 그런 문자를 찾을 때까지 앞으로
이동합니다.  따라서 커서가 위 예의 줄 맨 처음에 있다면, "%"는 앞으로
나아가면서 첫 번째 "("를 찾을 겁니다.  그러고 나서는 그 짝으로 이동합니다:

<code class="section">		if (a == (b * c) / d) </code>
		---+----------------&gt;
			   %

</pre><hr><pre><b class="vimtag">*<a name="03.5">03.5</a>*</b>	특정 줄로 이동

당신이 C나 C++ 프로그래머라면, 다음과 같은 에러 메시지에 익숙할 겁니다:

<code class="section">	prog.c:33: j   undeclared (first use in this function) </code>

33번째 줄에 무언가 고쳐야할 듯한 것이 있다는 이야기지요.  자 그럼 33번째
줄을 어떻게 찾을까요?  한 가지 방법은 일단 "9999k"로 파일의 처음으로 간 다음,
"32j"로 32 줄을 내려오는 것입니다.  좋은 방법인 것 같지는 않지만 어쨌든
잘 될 겁니다.  훨씬 나은 방법은 "G" 명령을 사용하는 것입니다.  숫자와 함께
사용하면, 지정한 숫자 번째의 줄로 갑니다.  예를 들어, "33G"는 33번째 줄로
당신을 보내줄 겁니다.  (컴파일러의 에러 목록을 가지고 작업하는 더 좋은 방법은
|<a href="usr_30.html#usr_30.txt">usr_30</a>|에서 :make 명령에 대한 정보를 보면 알 수 있습니다.)
   인자 없이 "G" 명령을 실행하면 파일의 맨 끝으로 갑니다.  파일의 맨 처음으로
가는 빠른 방법은 "gg"를 사용하는 것입니다.  "1G"도 동일한 일을 합니다만 약간
더 손가락을 놀려야하지요.

	    |	파일의 맨 첫 줄        ^
	    |<code class="badlink">	내용 내용 내용 내용    </code>|
	    |<code class="badlink">	내용 내용 내용 내용    </code>|  gg
	7G  |<code class="badlink">	내용 내용 내용 내용    </code>|
	    |	내용 내용 내용 내용
	    |	내용 내용 내용 내용
	    V	내용 내용 내용 내용    |
		내용 내용 내용 내용    |  G
		내용 내용 내용 내용    |
		파일의 맨 마지막 줄    V

다른 줄로 이동하는 또 다른 방법은 "%" 명령을 숫자와 함께 사용하는 것입니다.
예를 들어 "50%"는 파일의 중간으로 이동합니다.  "90%"는 거의 끝부분이겠지요.

위 예에서는 당신이 파일의 어떤 줄로 이동하고 싶다고 가정하고 있습니다. 그게
화면에 보이고 있든지 말든지요.  만약 현재 화면에 보이는 영역 중 어딘가로
이동하고 싶다면 어떨까요?  아래 그림은 당신이 사용할 수 있는 세 가지 명령을
보여줍니다:

			+---------------------------+
		H --&gt;	|<code class="badlink"> 내용 예제 내용	    </code>|
			|<code class="badlink"> 예제 내용		    </code>|
			|<code class="badlink"> 내용 예제 내용	    </code>|
			|<code class="badlink"> 예제 내용		    </code>|
		M --&gt;	|<code class="badlink"> 내용 예제 내용	    </code>|
			|<code class="badlink"> 예제 내용		    </code>|
			|<code class="badlink"> 내용 예제 내용	    </code>|
			|<code class="badlink"> 예제 내용		    </code>|
		L --&gt;	|<code class="badlink"> 내용 예제 내용	    </code>|
			+---------------------------+

힌트: "H"는 처음(Home), "M"은 중간(Middle), "L"은 마지막(Last)를 의미합니다.

</pre><hr><pre><b class="vimtag">*<a name="03.6">03.6</a>*</b>	어디에 있는지 알아보기

지금 파일의 어느 부분에 있는지 알아보려면 세 가지 방법이 있습니다:

1.  <code class="keystroke">CTRL-G</code> 명령을 사용합니다.  다음과 같은 메시지를 볼 수 있습니다('ruler'
    옵션은 꺼져있다고 가정합시다):

<code class="section">	"usr_03.txt" 233 / 650 줄 --35%-- 칸 45-52 </code>

    먼저 편집 중인 파일의 이름이 나옵니다.  현재 커서가 있는 줄 번호와 전체 줄
    수, 파일에서의 위치가 퍼센트로 나오고, 커서가 몇 번째 칸에 있는지가
    나옵니다.
       때로는 나뉘어진 칸 번호가 나올텐데요.  예를 들어 "칸 2-9" 같이
    나옵니다.  이것은 커서가 두 번째 문자에 위치하고 있지만, 첫 번째 문자가
    탭이어서 여덟 칸 만큼을 잡아먹고, 화면에는 9번째 칸에 문자가 나온다는
    뜻입니다.

2.  'number' 옵션을 켭니다.  모든 줄의 앞에 줄 번호가 나올 겁니다:
<code class="example"></code>
<code class="example">	:set number</code>

    다시 끄려면:
<code class="example"></code>
<code class="example">	:set nonumber</code>

    'number'는 불린 옵션이므로, 이름의 앞에 "no"를 붙이면 끄는 효과가 납니다.
    불린 옵션은 켜진 것과 꺼진 것 두 가지 값밖에 가질 수 없습니다.
       Vim에는 다양한 옵션이 있습니다.  불린 옵션 외에도 여러 가지 숫자나
    문자열 값을 갖는 옵션들이 있습니다.  그런 것들이 사용되는 곳에 가면 보게
    될 겁니다.

3.  'ruler' 옵션을 켭니다.  그러면 Vim 창의 오른쪽 아래 구석에 커서의 위치가
    표시됩니다:
<code class="example"></code>
<code class="example">	:set ruler</code>
<code class="example"></code>
'ruler' 옵션을 사용하면 그리 공간을 많이 차지하지 않기 때문에 내용을 더 넓게
볼 수 있다는 장점이 있습니다.

</pre><hr><pre><b class="vimtag">*<a name="03.7">03.7</a>*</b>	주위로 스크롤하기

<code class="keystroke">CTRL-U</code>는 화면 절반만큼의 내용을 아래로 스크롤합니다.  어떤 창문을 통해서
파일의 내용을 보고있다고 상상해보세요.  이때 창문의 절반만큼 창문을 위(Up)로
올린 것입니다.  즉 창문이 내용 위에서 위로 올라갔으므로, 파일의 앞부분으로 간
것이 됩니다.  어느 쪽이 위인지 잠시 헷갈리더라도 걱정하지 마세요.  대부분의
사람들이 똑같이 헷갈려합니다.
   <code class="keystroke">CTRL-D</code>는 파일에서 창문을 화면 절반 만큼 내립니다.  즉, 내용을 화면 절반만큼
위로 스크롤합니다.

				       +----------------+
				       |<code class="badlink"> 내용 내용	</code>|
				       |<code class="badlink"> 내용 내용	</code>|
				       |<code class="badlink"> 내용 내용	</code>|
	+---------------+	       |<code class="badlink"> 내용 내용	</code>|
	|<code class="badlink"> 내용 내용	</code>|  <code class="keystroke">CTRL-U</code>  --&gt; |<code class="badlink">		</code>|
	|<code class="badlink">		</code>|	       |<code class="badlink"> 123456		</code>|
	|<code class="badlink"> 123456	</code>|	       +----------------+
	|<code class="badlink"> 7890		</code>|
	|<code class="badlink">		</code>|	       +----------------+
	|<code class="badlink"> 예제		</code>|  <code class="keystroke">CTRL-D</code> --&gt;  |<code class="badlink"> 7890		</code>|
	+---------------+	       |<code class="badlink">		</code>|
				       |<code class="badlink"> 예제		</code>|
				       |<code class="badlink"> 예제		</code>|
				       |<code class="badlink"> 예제		</code>|
				       |<code class="badlink"> 예제		</code>|
				       +----------------+

한 번에 한 줄 씩만 스크롤하려면 <code class="keystroke">CTRL-E</code>(위로 스크롤)와 <code class="keystroke">CTRL-Y</code>(아래로 스크롤)를
사용하세요.  <code class="keystroke">CTRL-E</code>는 한 줄을 추가로(Extra) 준다고 생각하세요.  (만약
마이크로소프트 윈도 호환 키매핑을 사용한다면 <code class="keystroke">CTRL-Y</code>는 스크롤이 아니라
다시하기일 것입니다.)

화면 전체(두 줄만 빼고)를 앞으로(Forward) 스크롤하려면 <code class="keystroke">CTRL-F</code>를 사용하세요.
반대방향은 뒤로(Backword)지요.  <code class="keystroke">CTRL-B</code>를 사용하면 됩니다.  다행히도 <code class="keystroke">CTRL-F</code>는
앞으로(Forward)이고, <code class="keystroke">CTRL-B</code>는 뒤로(Backward)이니 외우기 쉽지요.

자주 발생하는 문제로 여러 줄을 "j"로 내려가다보면 커서가 화면의 맨 아래에 있게
되는 것이 있습니다.  이때 커서 주위의 내용을 좀 더 보고 싶을 때가 많지요.
"zz" 명령을 사용하면 됩니다.

	+------------------+		 +------------------+
	|<code class="badlink"> 내용 내용	   </code>|		 |<code class="badlink"> 내용 내용	    </code>|
	|<code class="badlink"> 내용 내용	   </code>|		 |<code class="badlink"> 내용 내용	    </code>|
	|<code class="badlink"> 내용 내용	   </code>|		 |<code class="badlink"> 내용 내용	    </code>|
	|<code class="badlink"> 내용 내용	   </code>|   zz  --&gt;	 |<code class="badlink"> 커서가 있는 줄   </code>|
	|<code class="badlink"> 내용 내용	   </code>|		 |<code class="badlink"> 내용 내용	    </code>|
	|<code class="badlink"> 내용 내용	   </code>|		 |<code class="badlink"> 내용 내용	    </code>|
	|<code class="badlink"> 커서가 있는 줄   </code>|		 |<code class="badlink"> 내용 내용	    </code>|
	+------------------+		 +------------------+

"zt" 명령은 커서가 있는 줄을 화면 맨 위(Top)로 올리고, "zb"는 맨
밑(Bottom)으로 내립니다.  몇 가지 스크롤 명령이 더 있는데, |<a href="quickref.html#Q_sc">Q_sc</a>|를
확인하세요.  언제나 커서 주위의 몇 줄을 보이도록 만들려면 'scrolloff' 옵션을
사용하세요.

</pre><hr><pre><b class="vimtag">*<a name="03.8">03.8</a>*</b>	간단한 찾기

문자열을 찾으려면, "/문자열" 명령을 사용하세요.  예를 들어 "include"라는
단어를 찾으려면, 다음 명령을 사용하세요:
<code class="example"></code>
<code class="example">	/include</code>
<code class="example"></code>
"/"를 입력하면 커서가 Vim 창의 맨 바닥으로 이동하는 것을 보셨을 겁니다.  콜론
명령과 마찬가지지요.  거기서 단어를 입력하게 됩니다.  잘못 입력한 부분이
있으면 백스페이스 키(뒤쪽 화살표 또는 <code class="special">&lt;BS&gt;</code>)를 눌러서 고치면 됩니다.
필요하다면 <code class="special">&lt;Left&gt;</code>나 <code class="special">&lt;Right&gt;</code> 화살표 키를 사용할 수도 있습니다.
   <code class="special">&lt;Enter&gt;</code>를 눌러 명령을 실행합시다.

	<code class="note">Note:</code>
	.*[]^%/\?~$ 문자에는 특수한 뜻이 있습니다.  이 문자들을 찾고 싶다면
	문자 앞에 \를 붙여야 합니다.  아래에서 더 설명하겠습니다.

같은 문자열이 다음으로 나타나는 곳을 또 찾고 싶다면 "n" 명령을 사용하세요.
커서 뒤의 첫 번째 #include를 찾고 싶다면 다음 명령을 사용하세요:
<code class="example"></code>
<code class="example">	/#include</code>
<code class="example"></code>
그리고 "n"을 여러 번 눌러보세요.  파일 내용 중 #include가 나타나는 곳들로
이동하게 됩니다.  몇 번째 나오는 것을 원하는지 알고 있다면 앞에 숫자를 붙일
수도 있습니다.  즉, "3n"은 세 번째 일치하는 곳으로 갑니다.  "/"에는 숫자를
붙일 수 없습니다.

"?" 명령은 "/"와 유사하지만 거꾸로 가면서 찾습니다:
<code class="example"></code>
<code class="example">	?word</code>
<code class="example"></code>
"N" 명령은 마지막 찾기를 반대 방향으로 반복합니다.  즉 "/" 명령 후 "N"을
사용하면 거꾸로 가면서 찾고, "?" 명령 후 "N"을 사용하면 앞으로 가면서
찾습니다.


대소문자 구별하지 않기
----------------------

일반적으로는 찾고 싶은 것을 정확하게 입력해야 합니다.  만약 글자가 대문자인지
소문자인지가 중요하지 않다면, 'ignorecase' 옵션을 켜면 됩니다:
<code class="example"></code>
<code class="example">	:set ignorecase</code>
<code class="example"></code>
이제 "word"를 찾으면, "Word"나 "WORD"도 함께 찾아집니다.  대소문자를 다시
구별하도록 하려면:
<code class="example"></code>
<code class="example">	:set noignorecase</code>
<code class="example"></code>
<code class="example"></code>
히스토리
--------

세 번 찾기를 했다고 해봅시다:
<code class="example"></code>
<code class="example">	/one</code>
<code class="example">	/two</code>
<code class="example">	/three</code>
<code class="example"></code>
이제 단순히 "/"를 입력하여 찾기를 시작해봅시다.  아직 <code class="special">&lt;Enter&gt;</code>는 누르지 말고요.
<code class="special">&lt;Up&gt;</code>(위쪽 화살표 키)을 누르면, Vim은 명령줄에 "/three"를 표시할 겁니다.  이때
<code class="special">&lt;Enter&gt;</code>를 누르면 "three"를 찾습니다.  <code class="special">&lt;Enter&gt;</code>를 누르지 않고, <code class="special">&lt;Up&gt;</code>을 또 누르면
Vim은 명령줄을 "/two"로 다시 바꿉니다.  <code class="special">&lt;Up&gt;</code>을 또 다시 누르면 "/one"이
나옵니다.
   <code class="special">&lt;Down&gt;</code>(아래쪽 화살표 키)를 눌러서 찾기 명령의 히스토리를 반대 방향으로
살펴볼 수도 있습니다.

만약 앞서 사용했던 패턴이 어떻게 시작하는지 기억이 나고 다시 사용하고 싶다면,
<code class="special">&lt;Up&gt;</code>을 누르기 전에 시작 부분을 입력하세요.  앞의 예를 다시 보자면,
"/o<code class="special">&lt;Up&gt;</code>"이라고 입력하면 Vim이 명령줄에 "/one"을 넣어줄 겁니다.

":"로 시작하는 명령도 히스토리가 있습니다.  예전에 실행한 명령을 불러내서 다시
실행할 수 있게 해주지요.  이 두 가지 히스토리는 별개입니다.


내용에서 어절 찾기
------------------

파일 내용 중 "TheLongFunctionName" 이라는 어절이 있고, 이 어절이 다음에 나오는
곳을 찾고 싶다고 합시다.  "/TheLongFunctionName"라고 입력할 수도 있겠지만,
타자를 많이 쳐야겠지요.  만약 오타라도 내면 찾기 결과가 없을 수도 있습니다.
   더 쉬운 방법이 있습니다.  어절 위에 커서를 놓은 채 "*" 명령을 사용하세요.
Vim은 커서 위치의 어절을 읽어낸 뒤 그 어절로 찾기를 합니다.
   "#" 명령은 같은 찾기를 반대 방향으로 합니다.  숫자를 붙일 수도 있습니다.
"3*"는 커서가 위치한 어절이 세 번째로 나타나는 곳을 찾습니다.


전체 어절 일치 찾기
-------------------

만약 "/the"를 입력하면 "there"도 찾게 됩니다.  "the"로 어절이 끝나는 부분만
찾으려면 다음과 같이 하세요:
<code class="example"></code>
<code class="example">	/the\&gt;</code>
<code class="example"></code>
"\&gt;"는 어절의 끝에만 대응되는 특별한 표시입니다.  비슷하게 "\&lt;"는 어절의
시작에만 대응됩니다.  즉 "the" 자체만 찾으려면:
<code class="example"></code>
<code class="example">	/\<code class="special">&lt;the\&gt;</code></code>
<code class="example"></code>
이러면 "there"나 "soothe"는 찾지 않게 됩니다.  "*"나 "#" 명령을 사용 하면
어절의 시작과 끝 표시를 사용해서 어절 전체만을 찾는 것을 볼 수 있습니다
("g*"와 "g#"을 이용하면 어절의 일부만 일치하는 것도 찾을 수 있습니다).


일치 하는 곳을 강조하기
-----------------------

프로그램을 고칠 때 "nr"이라는 변수를 보고있다고 합시다.  이 변수가 어디에서
사용되는지 보고 싶습니다.  커서를 "nr"로 옮긴 후, "*" 명령을 사용하고 "n"을
눌러서 전체 일치하는 것을 쭉 볼 수 있을 겁니다.
   아니면 다른 방법이 있는데요, 다음 명령을 사용해보세요:
<code class="example"></code>
<code class="example">	:set hlsearch</code>
<code class="example"></code>
이제 "nr"을 찾으면, Vim이 일치하는 모든 곳을 강조해서 보여줍니다.  변수가
어디에서 사용되는지를 보기에 아주 좋은 방법이지요.  다른 명령을 사용할 필요
없이요.
   강조를 끄려면:
<code class="example"></code>
<code class="example">	:set nohlsearch</code>
<code class="example"></code>
이러면 다음 번 찾기를 할 때 다시 옵션을 켜야 강조가 됩니다.  그냥 현재
강조 되어있는 것만을 없애려면 다음 명령을 사용하세요:
<code class="example"></code>
<code class="example">	:nohlsearch</code>
<code class="example"></code>
이 명령은 옵션을 끄지는 않습니다.  대신 강조만을 지웁니다.  찾기를 하는 순간
강조가 다시 이루어집니다.  "n"이나 "N" 명령으로도요.


찾는 방법 조정하기
------------------

찾는 방법을 바꾸는 몇 가지 옵션이 있습니다.  필수적인 것들이지요:

<code class="example">	:set incsearch</code>
<code class="example"></code>
이 옵션은 Vim이 찾는 문자열을 입력하는 중에도 찾기를 해서 결과를 보여주도록
합니다.  찾는 결과가 있는지를 바로 알고 싶다면 이 옵션을 사용하세요.  그리고
나서 <code class="special">&lt;Enter&gt;</code>를 누르면 보여지는 결과로 진짜 이동을 합니다.  아니면 찾는
문자열을 바꾸기 위해 뭔가 더 입력하거나요.

<code class="example">	:set nowrapscan</code>
<code class="example"></code>
이 옵션은 파일의 맨 끝에서 찾기를 중단하도록 합니다.  혹시 반대 방향으로 찾고
있다면 파일의 맨 처음에서요.  'wrapscan' 옵션의 기본 값은 켜져있는 것으로,
파일의 끝을 만나면 반대쪽 끝으로 가서 계속 찾습니다.


막간
-----

만약 위에서 살펴본 옵션들 중 하나가 좋아서 Vim을 사용할 때마다 설정하고
싶다면, 해당하는 명령을 Vim 구동 파일에 넣으면 됩니다.
   |<a href="usr_01.html#not-compatible">not-compatible</a>|에 언급된 것과 같이 파일을 편집하세요.  혹은 파일이
어디있는지 알고 싶다면 다음 명령을 사용하세요:
<code class="example"></code>
<code class="example">	:scriptnames</code>
<code class="example"></code>
파일을 여세요.  예를 들어 다음과 같이요:
<code class="example"></code>
<code class="example">	:edit ~/.vimrc</code>
<code class="example"></code>
그리고 옵션을 설정하는 명령을 Vim에서 입력한 것과 똑같이 넣으세요.  예:
<code class="example"></code>
<code class="example">	Go:set hlsearch<code class="special">&lt;Esc&gt;</code></code>
<code class="example"></code>
"G"로 파일의 맨 마지막으로 이동합니다.  "o"로 새 줄을 시작하고, ":set" 명령을
입력하세요.  <code class="special">&lt;Esc&gt;</code>로 입력 모드를 나옵니다.  그리고 파일에 쓰세요:
<code class="example"></code>
<code class="example">	ZZ</code>
<code class="example"></code>
이제 Vim을 다시 시작하면 'hlsearch' 옵션이 언제나 켜져있을 겁니다.

</pre><hr><pre><b class="vimtag">*<a name="03.9">03.9</a>*</b>	간단한 찾기 패턴

Vim에서는 찾는 대상을 정규표현식(Regular expression)으로 지정합니다.
정규표현식은 찾기 패턴을 지정하는 매우 강력하면서도 간결한 방식입니다.
불행하게도 이런 강력함에는 대가가 있으니 정규 표현식은 배우기 약간 어렵습니다.
   이번 절에서는 필수적인 몇 가지만 살펴보겠습니다.  더 자세한 찾기 패턴과
명령에 대해서는 27장 |<a href="usr_27.html#usr_27.txt">usr_27</a>|에서 살펴보겠습니다.  전체 설명은 |<code class="badlink">pattern</code>|에
있습니다.


줄의 시작과 끝
--------------

^ 문자는 줄의 시작에 대응됩니다.  영어-US 키보드에서는 숫자 6 위에 있는
문자입니다.  "include"라는 패턴은 줄의 어디에 있는 "include"든 모두 찾습니다.
하지만 "^include"라는 패턴은 줄의 시작 위치에 있는 "include"만 찾습니다.
   $ 문자는 줄의 끝에 대응됩니다.  따라서 "was$"는 줄의 맨 끝에 있는 "was"만
찾습니다.

다음 예제에서는 "the"가 일치하는 곳을 "x"로 표시해보았습니다:

<code class="section">	the solder holding one of the chips melted and the </code>
	xxx			  xxx		       xxx

"/the$"를 사용하면 다음과 같이 찾습니다:

<code class="section">	the solder holding one of the chips melted and the </code>
						       xxx

그리고 "/^the"를 사용하면 다음과 같습니다:
<code class="section">	the solder holding one of the chips melted and the </code>
	xxx

"/^the$"와 같이 찾을 수도 있습니다.  그러면 줄에 딱 "the"만 있는 경우를 찾게
됩니다.  여기서는 공백도 의미가 있습니다.  즉 "the "와 같이 단어 뒤에 공백이
하나 있는 경우, 패턴이 일치하지 않는 것입니다.


임의의 문자 하나에 대응
-----------------------

. (마침표) 문자는 임의의 문자 하나에 대응됩니다.  예를 들어, "c.m"이란 패턴은
문자열의 첫 글자가 c이고, 두 번째 글자는 무엇이든 상관 없고, 세 번째 글자가
m이면 일치하는 것입니다.  예:

<code class="section">	We use a computer that became the cummin winter. </code>
		 xxx		 xxx	  xxx


특수문자 찾기
-------------

진짜 마침표를 찾고 싶다면 어떻게 해야 할까요?  앞에 백슬래시를 넣어서 특수한
의미를 없애면 됩니다.
   "ter." 패턴으로 찾으면 다음과 같이 찾아집니다:

<code class="section">	We use a computer that became the cummin winter. </code>
		      xxxx			    xxxx

하지만 "ter\."로 찾으면 두 번째 결과만 찾게 될 겁니다.

</pre><hr><pre><b class="vimtag">*<a name="03.10">03.10</a>*</b>	마크 사용하기

"G" 명령으로 다른 위치로 뛰면(jump), Vim은 뛰기 전의 위치를 기억합니다.  이
위치는 마크라고 부르는데요, 다시 원래 위치로 돌아가려면 다음 명령을
사용하세요:
<code class="example"></code>
<code class="example">	``</code>
<code class="example"></code>
이 `는 백틱(backtick) 혹은 여는 작은 따옴표, 악상 그라브 등으로 부르는
문자입니다.
   이 명령을 다시 사용하면, 다시 이전 위치로 뜁니다.  이는 ` 명령 자체도
뛰기(jump)이므로 뛰기 전 위치를 다시 기억하기 때문입니다.

일반적으로 현재 줄 밖으로 커서를 움직일 수 있는 명령을 실행할 때, 뛴다(jump)고
표현합니다.  여기에는 찾기 명령인 "/"와 "n" (찾은 결과가 얼마나 멀리있는지는
상관없습니다)도 포함됩니다.  하지만 문자 찾기인 "fx"나 "tx", 단어 단위 이동인
"w"와 "e"는 포함되지 않습니다.
   또한 "j"와 "k"는 뛰는 것이 아닙니다.  비록 앞에 숫자를 붙이면 꽤나 멀리
이동을 하긴 하지만요.

`` 명령은 두 지점을 왔다갔다 하면서 뜁니다.  <code class="keystroke">CTRL-O</code> 명령은 더 오래된(Older)
위치로 뜁니다 (힌트: O는 Older를 의미합니다).  <code class="keystroke">CTRL-I</code>는 반대로 더 최근의
위치로 뜁니다 (힌트: I는 키보드에서 O 옆의 키입니다).  아래 순서로 명령을
실행했다고 해봅시다:
<code class="example"></code>
<code class="example">	33G</code>
<code class="example">	/^여기</code>
<code class="example">	<code class="keystroke">CTRL-O</code></code>
<code class="example"></code>
첫 번째 명령으로 33번째 줄로 뜁니다.  그리고 "여기"로 시작하는 줄이 있는 곳으로
뜁니다.  그 다음 <code class="keystroke">CTRL-O</code>를 누르면 33번째 줄로 돌아갑니다.  여기서 <code class="keystroke">CTRL-O</code>를 다시
한 번 누르면 맨 처음 시작한 곳으로 돌아갑니다.  이번에는 <code class="keystroke">CTRL-I</code>를 누르면
33번째 줄로 다시 뜁니다.  <code class="keystroke">CTRL-I</code>를 또 누르면 "여기"를 찾은 위치로 뜁니다.


	     |<code class="badlink">	예제 내용      ^	     </code>|
	33G  |<code class="badlink">	예제 내용      </code>|  <code class="keystroke">CTRL-O</code>     | <code class="keystroke">CTRL-I</code>
	     |<code class="badlink">	예제 내용      </code>|	     |
	     V	33번째 줄 내용 ^	     V
	     |<code class="badlink">	예제 내용      </code>|	     |
       /^여기|<code class="badlink">	예제 내용      </code>|  <code class="keystroke">CTRL-O</code>     | <code class="keystroke">CTRL-I</code>
	     V	여기가 바로    |	     V
		예제 내용

	<code class="note">Note:</code>
	<code class="keystroke">CTRL-I</code>는 <code class="special">&lt;Tab&gt;</code>과 같습니다.

":jumps" 명령으로 뛰어다닌 위치의 목록을 볼 수 있습니다.  마지막으로 사용한
항목이 "&gt;"로 표시됩니다.


명칭이 붙여진 마크						<b class="vimtag">*<a name="bookmark">bookmark</a>*</b>
------------------

Vim에서는 내용 안에 자신만의 마크를 놓을 수 있습니다.  "ma" 명령은 현재 커서가
위치한 곳을 마크 a로 기억시킵니다.  내용 안에 a에서 z까지 26개의 마크를 놓을
수 있습니다.  이건 Vim이 기억하는 위치일 뿐이므로 눈으로 볼 수는 없습니다.
   마크로 이동하려면 `<code class="special">{mark}</code> 명령을 이용하세요.  여기서 <code class="special">{mark}</code>는 마크
문자입니다.  즉 마크 a로 이동하려면:

<code class="example">	`a</code>
<code class="example"></code>
'<code class="special">{mark}</code>(작은 따옴표 혹은 아포스트로피) 명령은 커서를 마크가 있는 줄의 처음으로
이동시킵니다.  `<code class="special">{mark}</code> 명령이 기억시킨 열로 이동시키는 것과 차이가 있습니다.

마크는 파일에서 연관된 두 부분을 작업할 때 매우 유용합니다.  파일의 시작
부분에 참고할 내용이 있고, 파일의 끝 부분에 쓰고 있는 내용이 있다고 합시다.
   시작 부분의 내용으로 가서 시작(start)을 의미하는 s 마크를 놓읍시다:
<code class="example"></code>
<code class="example">	ms</code>
<code class="example"></code>
그리고 쓰고 있는 부분으로 와서 끝(end)을 의미하는 e 마크를 놓읍시다:
<code class="example"></code>
<code class="example">	me</code>
<code class="example"></code>
이제 돌아다니다가 파일의 시작 부분이 보고 싶으면 다음 명령으로 바로 갈 수
있습니다:
<code class="example"></code>
<code class="example">	's</code>
<code class="example"></code>
그리고서는 ''로 원래 있던 곳으로 돌아가거나, 'e로 끝부분의 작업하던 곳으로 갈
수 있습니다.
   여기서 꼭 시작 부분은 s를 쓰고 끝 부분은 e를 써야하는 것은 아닙니다.  그냥
외우기 쉬우라고 쓴 것 뿐입니다.

다음 명령으로 마크 목록을 볼 수 있습니다:
<code class="example"></code>
<code class="example">	:marks</code>
<code class="example"></code>
몇 가지 특수 마크를 보셨을 겁니다.  다음과 같은 것들이 있습니다:

	'	뛰기 전 커서의 위치
	"	지난 번 파일 편집 시 커서의 위치
	[	마지막 변경한 곳의 시작
	]	마지막 변경한 곳의 끝

</pre><hr><pre>
다음 장: |<a href="usr_04.html#usr_04.txt">usr_04</a>|  약간 고치기

저작권: |<a href="usr_01.html#manual-copyright">manual-copyright</a>| 참고  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2013. 12. 14. (토) 19:53:58 KST</i></p>
</body>
</html>
