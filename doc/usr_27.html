<!DOCTYPE html>
<html>
<head>
<title>VIM: usr_27</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>USR_27</h2>
<pre>
<b class="vimtag">*<a name="usr_27.txt">usr_27.txt</a>*</b>	Vim version 7.0 대상.  새로고침: 2006 Apr 24

		      VIM 사용설명서 - Bram Moolenaar 저
				       정지용 역

			       찾기 명령과 패턴


3장에서는 몇 가지 간단한 찾기 패턴을 살펴보았습니다 |<code class="badlink">03.9</code>|.  하지만 훨씬 더
복잡한 찾기도 할 수 있습니다.  이번 장에서는 가장 자주 사용되는 것들을
살펴보도록 하겠습니다.  더 자세한 세부사항은 |<code class="badlink">pattern</code>|을 참조하십시오.

|<a href="usr_27.html#27.1">27.1</a>|	대소문자 무시하기
|<a href="usr_27.html#27.2">27.2</a>|	파일의 끝에서 처음으로 넘어가기
|<a href="usr_27.html#27.3">27.3</a>|	오프셋(Offset)
|<a href="usr_27.html#27.4">27.4</a>|	반복되는 문자열
|<a href="usr_27.html#27.5">27.5</a>|	여럿 중 하나
|<a href="usr_27.html#27.6">27.6</a>|	문자 범위
|<a href="usr_27.html#27.7">27.7</a>|	문자 종류
|<a href="usr_27.html#27.8">27.8</a>|	줄 바꿈 찾기
|<a href="usr_27.html#27.9">27.9</a>|	예제

다음 장: |<a href="usr_28.html#usr_28.txt">usr_28</a>|  접기
이전 장: |<a href="usr_26.html#usr_26.txt">usr_26</a>|  반복하기
   차례: |<a href="usr_toc.html#usr_toc.txt">usr_toc</a>|

</pre><hr><pre><b class="vimtag">*<a name="27.1">27.1</a>*</b>	대소문자 무시하기

기본 설정인 경우, 빔의 검색은 대소문자를 구별합니다.  따라서 "include"와
"INCLUDE", "Include"는 모두 다른 단어입니다.
   이제 'ignorecase'(대소문자무시) 설정을 켜봅시다:
<code class="example"></code>
<code class="example">	:set ignorecase</code>
<code class="example"></code>
"include"를 다시 찾아봅시다.  이제 "Include", "INCLUDE", "InClUDe"를 모두 찾을
수 있습니다.  (어느 부분이 패턴과 일치하는 지 빠르게 확인하려면
'hlsearch'(찾기강조) 설정을 켜십시오.)
   다음 명령으로 다시 설정을 끌 수 있습니다:
<code class="example"></code>
<code class="example">	:set noignorecase</code>
<code class="example"></code>
일단 설정을 끄지는 말고, "INCLUDE"로 찾아봅시다.  "include"와 마찬가지로
대소문자 구별없이 모두 찾을 것입니다.  이제 'smartcase'(자동대소문자) 설정을
켜봅시다:
<code class="example"></code>
<code class="example">	:set ignorecase smartcase</code>
<code class="example"></code>
패턴에 한 글자라도 대문자가 있으면, 대소문자를 구별하여 찾습니다.  그러니까,
필요도 없는데 괜히 대문자를 입력하지는 않았을 테고, 대문자인 것을 찾기 원했기
때문에 그렇게 입력했을 거라고 추측하는 것입니다.  영리(smart)하지 않습니까!
    이 두 설정을 켜면, 찾기 결과는 다음과 같습니다:

<code class="section">	패턴			결과	</code>
	word			word, Word, WORD, WoRd 등
	Word			Word
	WORD			WORD
	WoRd			WoRd


잠깐 대소문자 구별 바꾸기

딱 한 패턴에서만 대소문자를 구별하지 않고 찾고 싶다면, 패턴 앞에 "\c"를 붙이면
됩니다.  반대로 "\C"를 앞에 붙이면 대소문자까지 일치하는 것만 찾게 됩니다.
"\c"나 "\C"가 패턴 앞에 붙으면 'ignorecase'와 'smartcase' 설정은 무시됩니다.

<code class="section">	패턴			결과	</code>
	\Cword			word
	\CWord			Word
	\cword			word, Word, WORD, WoRd 등
	\cWord			word, Word, WORD, WoRd 등

"\c"나 "\C"를 쓸 때의 장점은 패턴에 대소문자 구별 정보가 함께 따라다닌다는
것입니다.  따라서 찾기 히스토리에서 패턴을 가져와서 다시 사용할 때, 항상 같은
문자열들을 찾을 수 있습니다.  'ignorecase'나 'smartcase' 설정이 바뀌었더라도
말이지요.

	<code class="note">Note:</code>
	찾기 패턴에서 "\"의 의미는 'magic'(매직) 설정에 따라 달라집니다.
	이 장에서는 'magic' 설정이 켜져 있다고 가정합니다.  켜는 것이
	일반적이기도 하고, 추천하는 설정입니다.  'magic' 설정을 바꾼다면, 많은
	찾기 패턴이 동작하지 않게 될 것입니다.

	<code class="note">Note:</code>
	예상보다 찾는 데 시간이 더 걸린다면, 유닉스에서는 <code class="keystroke">CTRL-C</code>로, MS-DOS나
	MS-윈도우에서는 <code class="keystroke">CTRL-Break</code>로 멈출 수 있습니다.

</pre><hr><pre><b class="vimtag">*<a name="27.2">27.2</a>*</b>	파일의 끝에서 처음으로 넘어가기

기본 설정인 경우, 주어진 문자열을 아래쪽으로 가면서 찾는 경우는 현재 커서의
위치부터 찾게 됩니다.  파일의 끝까지 먼저 찾은 다음, 그때까지 찾은 것이
없다면, 문서의 처음으로 넘어갑니다.  파일의 처음부터 현재 커서 위치까지를
계속해서 찾습니다.
   "n" 명령으로 찾기를 계속 반복하는 경우, 맨 처음 찾은 결과로 돌아오게 된다는
것을 기억하십시오.  아무 생각 없이 "n"만 누르다보면 똑같은 결과만 계속 보면서
끝없이 찾을 수도 있습니다.  파일이 끝났음을 알려주기 위해 빔에서는 다음
메시지를 보여줍니다:

<code class="section">	끝까지 찾았음, 처음부터 계속 </code>

"?" 명령을 쓰면, 반대방향(문서의 처음 방향)으로 가면서 찾을 수 있습니다.  이
때는 다음 메시지를 볼 수 있습니다:

<code class="section">	처음까지 찾았음, 끝에서 계속 </code>

아직도 맨 처음 찾은 결과로 돌아왔는 지 잘 모르겠다면, 'ruler'(자) 설정을 켜서
확인할 수도 있습니다:
<code class="example"></code>
<code class="example">	:set ruler</code>
<code class="example"></code>
창의 오른쪽 아래 구석에 (상태표시줄이 있다면 상태표시줄 안에) 현재 커서의
위치가 표시됩니다.  다음과 같이 생겼습니다:

<code class="section">	101,29       84% </code>

첫 번째 숫자가 커서의 줄번호입니다.  찾기를 시작할 때의 줄번호를 기억하면 이
위치를 지나간 적이 있는 지 확인할 수 있습니다.


파일의 끝을 넘어가지 않기

파일의 끝에서 처음으로 넘어가지 않게 하려면 다음 명령을 사용하십시오:
<code class="example"></code>
<code class="example">	:set nowrapscan</code>
<code class="example"></code>
이제는 찾다가 파일의 끝에 도달한 경우 다음과 같은 에러 메시지가 나옵니다:

<code class="section">	E385: 끝까지 맞는 문자열이 없습니다: 영원히 </code>

따라서 "gg" 명령으로 파일의 처음으로 간 다음, 이 메시지를 볼 때까지 계속
찾으면 됩니다.
   "?"를 써서 반대방향으로 찾을 때는 다음 메시지가 나옵니다:

<code class="section">	E384: 처음까지 맞는 문자열이 없습니다: 영원히 </code>

</pre><hr><pre><b class="vimtag">*<a name="27.3">27.3</a>*</b>	오프셋(Offset)

기본 설정인 경우, 찾기를 하면 패턴과 일치하는 문자열이 시작하는 곳에 커서가
옵니다.  오프셋을 지정하면 커서가 다른 곳에 위치하도록 할 수 있습니다.
아래쪽으로 가면서 찾는 명령인 "/"는 패턴 뒤에 슬래시(/)와 오프셋 값을 지정하면
됩니다:
<code class="example"></code>
<code class="example">	/기본/2</code>
<code class="example"></code>
위 명령은 "기본" 패턴을 찾은 다음, 패턴에서 두 줄 아래 줄의 시작지점으로
커서를 이동시킵니다.  이 명령을 위 문단에 사용하면, 빔은 첫 번째 줄의 "기본"을
찾습니다.  그리고 커서가 두 줄 아래로 내려와서 "아래쪽으로" 위치에 옵니다.

오프셋이 그냥 숫자이면, 찾은 곳에서 지정한 숫자만큼 아래 줄 첫 번째 글자에
커서가 옵니다.  오프셋은 양수이거나 음수일 수 있습니다.  양수이면 커서가
지정한 수만큼 아래로 내려오고, 음수이면 올라갑니다.


문자 오프셋

"e" 오프셋은 찾은 문자열의 끝을 기준으로 한다는 의미입니다.  즉, 찾은 문자열의
맨 마지막 문자에 커서가 옵니다.  다음 명령을 봅시다:
<code class="example"></code>
<code class="example">	/홍길동/e</code>
<code class="example"></code>
위 명령은 커서를 "홍길동"의 "동"에 오도록 합니다.
   이 위치에서, 숫자를 더하면, 그 숫자만큼 몇 문자 앞으로 이동합니다.  예를
들어 다음 명령은 찾은 문자열 바로 다음으로 커서를 옮깁니다:
<code class="example"></code>
<code class="example">	/홍길동/e+1</code>
<code class="example"></code>
양수는 커서를 오른쪽으로 옮기고, 음수는 커서를 왼쪽으로 옮깁니다.  예를 들어:

<code class="example"></code>
<code class="example">	/홍길동/e-1</code>
<code class="example"></code>
위 명령은 커서를 "홍길동"의 "길"로 옮깁니다.

오프셋이 "b"로 시작하면, 커서가 패턴의 시작 위치로 움직입니다.  "b"를 붙이지
않아도 어차피 시작위치로 움직이므로 이것만으로는 쓸 데가 없습니다.  하지만
여기에 숫자가 더해지거나 빼질 때는 그 숫자만큼 커서가 앞으로 가거나 뒤로
옵니다.  예를 들어:
<code class="example"></code>
<code class="example">	/홍길동/b+2</code>
<code class="example"></code>
위 명령은 커서를 찾은 문자열의 시작 위치로 옮긴다음, 두 문자만큼 오른쪽으로
움직입니다.  그래서 "동"에 커서가 옵니다.


반복

앞에서 사용한 찾기 패턴을 다시 사용하면서, 오프셋만 다르게 하고 싶다면, 패턴
부분을 빼놓고 쓰면 됩니다:
<code class="example"></code>
<code class="example">	/that</code>
<code class="example">	//e</code>
<code class="example"></code>
위 예는 다음과 똑같습니다:
<code class="example"></code>
<code class="example">	/that/e</code>
<code class="example"></code>
같은 오프셋으로 반복하려면:
<code class="example"></code>
<code class="example">	/</code>
<code class="example"></code>
물론 "n"도 같은 결과를 보입니다.  앞에서 사용한 패턴으로 찾으면서 오프셋만
없애고 싶다면:
<code class="example"></code>
<code class="example">	//</code>
<code class="example"></code>
<code class="example"></code>
파일의 앞쪽으로 가면서 찾기

"?" 명령에서도 같은 방식으로 오프셋을 사용할 수 있습니다.  이번에는 패턴과
오프셋 사이에 "/"가 아니라 "?"를 넣어서 구분해 줍니다:
<code class="example"></code>
<code class="example">	?홍길동?e-2</code>
<code class="example"></code>
"b"와 "e"의 의미는 "?" 때문에 찾는 방향이 바뀌더라도 전과 마찬가지입니다.


시작 위치

찾기는 일반적으로 현재 커서 위치에서 시작합니다.  그런데 몇 줄을 이동하도록
했을 때 문제가 되는 경우가 있습니다.  예를 들어:
<code class="example"></code>
<code class="example">	/홍길동/-2</code>
<code class="example"></code>
위 명령은 "홍길동"이란 단어를 찾은 다음, 두 줄 위로 올라갑니다.  이 상황에서
또 "n"을 누르면, 빔은 현재 위치에서 찾기 시작하고 금방 찾은 "홍길동"을 다시
찾습니다.  그리고 다시 오프셋에 따라 두 줄 위로 올라가고 결국 방금의 위치로
되돌아오게 됩니다.  결과적으로 아무리 "n"을 눌러도 움직이지 않게 되지요.
   더 꼬이는 경우도 있습니다: "홍길동"이란 단어가 현재 커서의 다음 줄에 있다고
해봅시다.  찾기를 하면 다음 줄에서 "홍길동"을 찾은 후, 두 줄 위로 올라가게
되고 결과적으로는 한 줄 거꾸로 가게 됩니다.

반면, 문자단위 오프셋을 사용하는 경우("b"나 "e"로)는 빔이 알아서 처리해줍니다.
찾기를 현재 위치 몇 글자 앞이나 뒤에서 시작함으로써, 같은 문자열에서 빙빙 도는
것을 막아줍니다.

</pre><hr><pre><b class="vimtag">*<a name="27.4">27.4</a>*</b>	반복되는 문자열

"*"은 바로 앞에 나오는 것이 몇 번이든 나와도 된다는 의미입니다.
따라서:
<code class="example"></code>
<code class="example">	/a*</code>
<code class="example"></code>
는 "a", "aa", "aaa" 등에 모두 대응(match)됩니다.  그리고 "" (빈 문자열)에도
대응됩니다. "*"의 "몇 번"에는 0번도 포함되기 때문입니다.
   "<b class="vimtag">*<a name="%22는 바로 앞에 있는 것에만 적용됩니다.  따라서 %22ab">"는 바로 앞에 있는 것에만 적용됩니다.  따라서 "ab</a>*</b>"로는 "a", "ab", "abb",
"abbb" 등을 찾을 수 있습니다.  문자열 전체를 여러 번 반복하려면, 문자열이
하나의 그룹으로 묶여야합니다.  그룹으로 묶는 것은 앞에 "\("를, 뒤에 "\)"를
넣으면 됩니다.  다음 명령을 봅시다:
<code class="example"></code>
<code class="example">	/\(ab\)*</code>
<code class="example"></code>
위 명령에는 "ab", "abab", "ababab" 등이 대응됩니다.  물론 ""도 대응됩니다.

빈 문자열이 대응되는 것을 막으려면, "\+"를 사용하십시오.  바로 앞에 나오는
것이 한 번 이상 반복된다는 의미입니다.
<code class="example"></code>
<code class="example">	/ab\+</code>
<code class="example"></code>
는 "ab", "abb", "abbb" 등에 대응됩니다.  하지만 뒤에 "b"가 오지 않는 "a"에는
대응되지 않습니다.

있어도 없어도 상관없는 것은 "\="를 사용하십시오.  예제:
<code class="example"></code>
<code class="example">	/folders\=</code>
<code class="example"></code>
위 패턴은 "folder"와 "folders"에 대응됩니다.


특정 횟수

특정 횟수만큼 반복되는 것을 나타내려면 "\<code class="special">{n,m}</code>" 형태를 사용하십시오.  "n"과
"m"에는 숫자를 넣으시면 됩니다.  바로 앞에 나오는 것이 "n"에서 "m" 번 반복되는
것이 대응됩니다.  ("n"번과 "m"번인 것도 포함됩니다 |<code class="badlink">inclusive</code>|)
예제:
<code class="example"></code>
<code class="example">	/ab\<code class="special">{3,5}</code></code>
<code class="example"></code>
는 "abbb", "abbbb", "abbbbb"에 대응됩니다.
  "n"이 생략되면, 0이 지정된 것으로 간주합니다. "m"이 생략되면 무한히 큰 값이
지정된 것으로 간주합니다. ",m"이 생략되면, 정확히 "n"번 반복된 것만 찾습니다.
예제:

<code class="section">	패턴		반복 횟수 </code>
	\<code class="special">{,4}</code>		0, 1, 2, 3, 4
	\<code class="special">{3,}</code>		3, 4, 5, 등
	\<code class="special">{0,1}</code>		0 또는 1, \=와 동일
	\<code class="special">{0,}</code>		0 이상, *와 동일
	\<code class="special">{1,}</code>		1 이상, \+와 동일
	\<code class="special">{3}</code>		3


최소한만 대응되도록 하기

지금까지 말한 것들은 최대한 길게 대응되는 문자열을 찾습니다.  하지만 반대로
최소한의 문자열만 대응되도록 하고 싶다면 "\<code class="special">{-n,m}</code>"을 사용하십시오.  이 명령은
최소한의 문자열만 대응된다는 점만 빼면, "\<code class="special">{n,m}</code>"과 동일하게 동작합니다.
   예를 들어, 다음 명령은:
<code class="example"></code>
<code class="example">	/ab\<code class="special">{-1,3}</code></code>
<code class="example"></code>
"abbb"가 있으면 "ab"에만 대응됩니다.  사실, 위 패턴은 딱 하나의 b에만
대응됩니다.  최소한만 대응시키므로 그 이상을 찾을 필요가 없기 때문입니다.
제한 값 이상을 대응시키려면 무언가가 더 필요합니다.
   앞에서 설명한 "n"과 "m"을 생략하는 규칙도 동일하게 적용됩니다.  심지어는
"n"과 "m"을 모두 생략하고 "\<code class="special">{-}</code>"을 쓸 수도 있습니다.  이 패턴은 바로 앞의 것을
0번 이상 반복한 것에 대응되는데, 최소한에만 대응됩니다.  이 패턴 자체만으로는
항상 0번에 대응될 수 밖에 없습니다.  그래서 다른 패턴과 함께 사용되어야
유용합니다.  다음 예를 봅시다:
<code class="example"></code>
<code class="example">	/a.\<code class="special">{-}</code>b</code>
<code class="example"></code>
위 패턴은 "axbxb"란 문자열 안에서 "axb"에만 대응됩니다.  만약:
<code class="example"></code>
<code class="example">	/a.*b</code>
<code class="example"></code>
와 같은 패턴을 사용했다면, ".*"로 찾을 수 있는 최대한 긴 패턴을 찾으므로
"axbxb" 전체가 대응되었을 것입니다.

</pre><hr><pre><b class="vimtag">*<a name="27.5">27.5</a>*</b>	여럿 중 하나

패턴에서 "또는"에 해당하는 것은 "\|"입니다.  예제:
<code class="example"></code>
<code class="example">	/이거\|저거</code>
<code class="example"></code>
위 패턴은 "이거" 또는 "저거"에 대응됩니다.  더 많은 후보를 지정할 수도
있습니다:
<code class="example"></code>
<code class="example">	/하나\|<code class="badlink">둘\</code>|셋</code>
<code class="example"></code>
은 "하나"나 "둘", "셋"에 대응됩니다.
   여러 번 반복되는 것을 찾으려면, 전체를 "\(", "\)" 사이에 넣어야 합니다:
<code class="example"></code>
<code class="example">	/\(이거\|저거\)\+</code>
<code class="example"></code>
는 "이거", "이거저거", "이거이거", "저거이거저거" 등에 대응됩니다.
   다른 예:
<code class="example"></code>
<code class="example">	/end\(if\|<code class="badlink">while\</code>|for\)</code>
<code class="example"></code>
는 "endif", "endwhile", "endfor"에 대응됩니다.

좀 더 살펴보자면, "\&amp;"도 있습니다.  이 것은 한 위치에서 여러 패턴이 모두
대응되어야 한다는 것입니다.  대응되는 범위는 마지막 패턴에 따라 결정됩니다.
예제:
<code class="example"></code>
<code class="example">	/forever\&amp;...</code>
<code class="example"></code>
위 패턴은 "forever"의 "for"에 대응됩니다.  하지만 예를 들어 "fortuin"의
"for"에는 대응되지 않습니다.

</pre><hr><pre><b class="vimtag">*<a name="27.6">27.6</a>*</b>	문자 범위

"a"나 "b", "c"를 찾으려면, "/a\|<code class="badlink">b\</code>|c"를 쓰면 됩니다.  하지만 "a"부터 "z"까지를
모두 나열할 일이 있다면, 짜증이 좀 나겠지요.  하지만 다음과 같이 줄여쓸 수
있습니다:
<code class="example"></code>
<code class="example">	/[a-z]</code>
<code class="example"></code>
[]안의 내용은 하나의 문자에 대응됩니다.  괄호 안에 대응시킬 문자들을 넣으면
됩니다.  다음과 같이 여러 문자들을 넣을 수도 있습니다:
<code class="example"></code>
<code class="example">	/[0123456789abcdef]</code>
<code class="example"></code>
위 패턴에는 괄호 안에 있는 문자들 중 어느 것이나 다 대응됩니다.  이어져있는
문자들은 범위로 지정할 수도 있습니다.  "0-3"은 "0123"과 같고, "w-z"는 "wxyz"와
같습니다.  따라서 위 패턴은 다음과 같이 고쳐쓸 수 있습니다:
<code class="example"></code>
<code class="example">	/[0-9a-f]</code>
<code class="example"></code>
"-"문자 자체를 찾기 위해서는 괄호 안의 맨 앞이나 맨 뒤에 넣으면 됩니다.  다음
특수 기호들을 써서 [] 안에 특수문자를 더 쉽게 넣을 수 있습니다(사실 이
기호들은 패턴 어디에서든지 쓸 수 있습니다):

	\e	<code class="special">&lt;Esc&gt;</code>
	\t	<code class="special">&lt;Tab&gt;</code>
	\r	<code class="special">&lt;CR&gt;</code>
	\b	<code class="special">&lt;BS&gt;</code>

[] 범위 지정에는 몇 가지 특수 기능이 더 있습니다.  자세한 설명은 |<code class="badlink">/[]</code>|를
참고하십시오.


뺄 것을 지정하기

어떤 문자가 대응되는 것을 막으려면, 범위의 앞에 "^"를 사용하십시오.  []은 해당
문자를 제외한 모든 문자에 대응됩니다.  예제:
<code class="example"></code>
<code class="example">	/"[^"]*"</code>

	 "	  따옴표
	  [^"]	  따옴표가 아닌 모든 문자
	      *	  최대한 많이
	       "  따옴표

위 패턴은 따옴표까지 포함하여 "거시기" 나 "3!x" 등에 대응됩니다.


많이 쓰이는 문자 범위

몇 가지 문자 범위는 굉장히 자주 쓰입니다.  자주 쓰이는 문자 범위를 좀 더 쉽게
쓸 수 있도록 빔에는 몇 가지 단축표현이 있습니다.
예를 들어:
<code class="example"></code>
<code class="example">	/\a</code>
<code class="example"></code>
는 알파벳 문자를 찾습니다.  위 패턴은 "/[a-zA-Z]"와 동일합니다.  몇 가지 더
살펴봅시다:

<code class="section">      단축표현	결과			동일한 표현 </code>
	\d	숫자(digit)		[0-9]
	\D	숫자가 아님		[^0-9]
	\x	16진수 숫자		[0-9a-fA-F]
	\X	16진수 숫자가 아님	[^0-9a-fA-F]
	\s	공백(space)		[ 	]     (<code class="special">&lt;Tab&gt;</code>과 <code class="special">&lt;Space&gt;</code>)
	\S	공백이 아님		[^ 	]     (<code class="special">&lt;Tab&gt;</code>과 <code class="special">&lt;Space&gt;</code>이 아님)
	\l	소문자(lowercase)	[a-z]
	\L	소문자가 아님		[^a-z]
	\u	대문자(uppercase)	[A-Z]
	\U	대문자가 아님		[^A-Z]

	<code class="note">Note:</code>
	이 짧은 표현을 사용하면 직접 문자범위를 입력하는 것보다 훨씬 편합니다.
	하지만 이것들은 [] 안에서 쓸 수 없습니다.  즉, "[\d\l]"은 숫자나
	소문자가 아닙니다!  "\(\d\|\l\)"을 사용하십시오.

단축 표현 전체 목록은 |<code class="badlink">/\s</code>|에서 볼 수 있습니다.

</pre><hr><pre><b class="vimtag">*<a name="27.7">27.7</a>*</b>	문자 종류

문자 범위 기능을 써서 일정 종류의 문자들을 찾을 수 있습니다.  문자
종류(character class) 기능도 유사한 역할을 하지만, 결정적인 차이가 있습니다:
패턴을 바꾸지 않으면서 사용 환경에 따라 문자 종류를 재정의할 수 있다는
것입니다.
   예를 들어 다음 패턴을 봅시다:
<code class="example"></code>
<code class="example">	/\f\+</code>
<code class="example"></code>
"\f" 는 파일명 문자를 의미합니다.  따라서 위 패턴은 파일명으로 쓰일 수 있는
문자열에 대응됩니다.
   하지만 어떤 문자가 파일명에 쓰일 수 있는 지 여부는 사용하는 시스템에 따라
다릅니다.  MS-윈도우에서는 경로에 백슬래시가 쓰이지만, 유닉스에서는 쓰이지
않습니다.  이 문자는 'isfname'(파일명여부) 설정으로 지정됩니다.  유닉스에서의
기본 값은:
<code class="example"></code>
<code class="example">	:set isfname</code>
<code class="example">	isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=</code>
<code class="example"></code>
하지만 다른 시스템에서는 기본값이 다릅니다.  따라서 "\f"로 파일명을 찾는
패턴을 만들 수 있고, 사용 중인 시스템의 종류에 따라 자동으로 패턴이
조정됩니다.

	<code class="note">Note:</code>
	사실, 유닉스에서는 공백을 포함하여 거의 모든 문자를 파일명에 쓸 수
	있습니다.  이론적으로는 이런 문자들도 'isfname'에 포함시키는 것이 맞을
	것입니다.  하지만 그러면 문서에서 파일명의 끝을 찾는 것이 사실상
	불가능합니다.  그래서 'isfname'의 값을 많이 쓰이는 문자들로 적당히
	한정하였습니다.

문자 종류들은 다음과 같습니다:

<code class="section">      문자 종류	결과				관련 설정 </code>
	\i	이름 문자			'isident'(이름여부)
	\I	\i와 같으나 숫자 제외
	\k	키워드 문자			'iskeyword'(키워드여부)
	\K	\k와 같으나 숫자 제외
	\p	출력 가능한 문자		'isprint'(출력가능여부)
	\P	\p와 같으나 숫자 제외
	\f	파일명 문자			'isfname'
	\F	\f와 같으나 숫자 제외

</pre><hr><pre><b class="vimtag">*<a name="27.8">27.8</a>*</b>	줄 바꿈 찾기

줄 바꿈을 포함한 패턴으로 찾을 수도 있습니다.  지금까지 살펴본 것들에는
줄 바꿈을 지정하는 것이 없었고, 어디서 줄이 바뀌는 지는 따로 지정해야합니다.
   특정 위치에 줄 바꿈이 있다고 지정하려면 "\n"을 사용하십시오:
<code class="example"></code>
<code class="example">	/단어\n정보</code>
<code class="example"></code>
위 패턴은 "단어"로 줄이 끝나고, 다음 줄이 "정보"로 시작하는 경우에 대응됩니다.
"단어 정보"도 찾으려면, 두 단어 사이에서 공백이나 줄 바꿈을 찾으면 됩니다.  이
때는 "\_s"를 쓰면 됩니다:
<code class="example"></code>
<code class="example">	/단어\_s정보</code>
<code class="example"></code>
공백이 여러 개 나오는 경우도 찾으려면:
<code class="example"></code>
<code class="example">	/단어\_s\+정보</code>
<code class="example"></code>
위 패턴으로 "단어   "로 줄이 끝나고, 그 다음 줄이 "   정보"로 시작하는 경우도
찾을 수 있습니다.

"\s"는 공백에 대응되고, "\_s"는 공백이나 줄 바꿈에 대응됩니다.  비슷하게
"\a"는 알파벳 문자에 대응되고, "\_a"는 알파벳 문자 또는 줄 바꿈에 대응됩니다.
다른 문자 종류나 범위도 마찬가지로 "_"를 넣어서 쓸 수 있습니다.

다른 것에도 앞에 "\_"를 붙여서 줄 바꿈에 대응되도록 할 수 있습니다.  예를
들어, "\_."은 줄 바꿈을 포함한 아무 문자에나 대응됩니다.

	<code class="note">Note:</code>
	"\_.*" 패턴에는 파일의 끝까지 전체 내용이 대응됩니다.  하지만 찾기
	명령이 매우 느려질 수 있으니 주의하십시오.

또 다른 예는 "\_[]"로, 문자 범위에 줄 바꿈도 포함시키는 것입니다:
<code class="example"></code>
<code class="example">	/"\_[^"]*"</code>
<code class="example"></code>
위 패턴은 따옴표로 싸인 문장이 여러 줄에 나뉘어 있는 경우도 찾을 수 있습니다.

</pre><hr><pre><b class="vimtag">*<a name="27.9">27.9</a>*</b>	예제

몇 가지 유용한 찾기 패턴들을 모아보았습니다.  앞에서 설명한 것들이 어떻게
조합되어 사용되는 지 살펴보시기 바랍니다.


캘리포니아 자동차 번호판 찾기

"1MGU103" 같은 번호판을 생각해 봅시다.  하나의 숫자가 있고, 세 개의 대문자와
세 개의 숫자가 나옵니다.  바로 패턴으로 표현해보면 다음과 같습니다:
<code class="example"></code>
<code class="example">	/\d\u\u\u\d\d\d</code>
<code class="example"></code>
숫자와 대문자를 반복해서 쓰지 말고 숫자로 표시할 수도 있습니다:
<code class="example"></code>
<code class="example">	/\d\u\<code class="special">{3}</code>\d\<code class="special">{3}</code></code>
<code class="example"></code>
줄인 표현이 기억나지 않는다면 [] 범위를 써도 됩니다:
<code class="example"></code>
<code class="example">	/[0-9][A-Z]\<code class="special">{3}</code>[0-9]\<code class="special">{3}</code></code>
<code class="example"></code>
어떤 것을 사용하든 지 상관없습니다.  조금 길더라도 그냥 쉽게 머리 속에
떠오르는 방법을 사용하는 것이 외우기도 힘든 복잡한 방법을 쓰는 것보다 훨씬
빠릅니다.  하지만 단축표현을 외우고 있다면, 마지막 패턴은 피하는 것이
좋습니다.  타이핑하기에도 길고, 실행 속도도 느립니다.


이름 찾기

C 프로그램에서는(물론 다른 프로그래밍 언어에서도) 변수나 함수의 이름이 알파벳
문자로 시작하고, 그 뒤에는 알파벳 문자나 숫자가 나옵니다.  아, 밑줄도
나올 수 있습니다.  이런 이름은 다음 패턴으로 찾을 수 있습니다:
<code class="example"></code>
<code class="example">	/\<code class="special">&lt;\h\w*\&gt;</code></code>
<code class="example"></code>
"\<code class="special">&lt;"와 "\&gt;</code>"는 단어 전체인 경우만 찾기 위해 사용되었습니다.  "\h"는
"[A-Za-z_]"를 의미하고, "\w"는 "[0-9A-Za-z_]"를 의미합니다.

	<code class="note">Note:</code>
	"\<code class="special">&lt;"와 "\&gt;</code>"의 동작은 'iskeyword' 설정의 값에 따라 달라집니다.  예를 들어
	"-"가 포함되어 있다면, "ident-"가 대응되지 않을 것입니다.  이런
	상황이라면 다음 패턴을 사용하십시오:
<code class="example"></code>
<code class="example">		/\w\@&lt;!\h\w*\w\@!</code>

	위 패턴은 이름 앞 뒤에 "\w"가 오는 지를 확인하여 오지 않는 경우만
	대응되도록 합니다.
	|<code class="badlink">/\@&lt;!</code>|와 |<code class="badlink">/\@!</code>|를 참고하십시오.

</pre><hr><pre>
다음 장: |<a href="usr_28.html#usr_28.txt">usr_28</a>|  접기

저작권: |<a href="usr_01.html#manual-copyright">manual-copyright</a>| 참고  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Fri Dec 23 22:48:56 PST 2011</i></p>
</body>
</html>
