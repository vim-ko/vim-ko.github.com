<!DOCTYPE html>
<html>
<head>
<title>VIM: usr_10</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>USR_10</h2>
<pre>
<b class="vimtag">*<a name="usr_10.txt">usr_10.txt</a>*</b>	Vim version 7.4 대상.  새로 고침: 2006년 11월 5일

		      VIM 사용설명서 - Bram Moolenaar 저
				       정지용 역

				 많이 고치기


4장에서는 조금씩 바꾸는 다양한 방법을 살펴보았습니다.  이번 장에서는 반복해서
고치거나, 많은 양의 내용을 고치는 방법에 대해 살펴보겠습니다.  시각 모드는
블록으로 된 부분에 대해 다양한 일을 할 수 있게 해줍니다.  외부 프로그램을
사용해서 매우 복잡한 일도 해보세요.

|<a href="usr_10.html#10.1">10.1</a>|	명령 기록하고 재생하기
|<a href="usr_10.html#10.2">10.2</a>|	바꾸기
|<a href="usr_10.html#10.3">10.3</a>|	명령 범위
|<a href="usr_10.html#10.4">10.4</a>|	global 명령
|<a href="usr_10.html#10.5">10.5</a>|	블록 시각 모드
|<a href="usr_10.html#10.6">10.6</a>|	파일의 일부를 읽고 쓰기
|<a href="usr_10.html#10.7">10.7</a>|	서식에 맞추기
|<a href="usr_10.html#10.8">10.8</a>|	대소문자 바꾸기
|<a href="usr_10.html#10.9">10.9</a>|	외부 프로그램 사용하기

다음 장: |<a href="usr_11.html#usr_11.txt">usr_11</a>|  작업 복구하기
이전 장: |<a href="usr_09.html#usr_09.txt">usr_09</a>|  GUI 사용하기
   차례: |<a href="usr_toc.html#usr_toc.txt">usr_toc</a>|

</pre><hr><pre><b class="vimtag">*<a name="10.1">10.1</a>*</b>	명령 기록하고 재생하기

"." 명령은 바로 전의 변경사항을 반복합니다.  하지만 한 가지 동작이 아니라 더
복잡한 일을 반복하고 싶다면 어떻게 해야 할까요?  명령 기록이 필요해지는
순간입니다.  다음 세 가지 단계로 이루어집니다:

1. "q<code class="special">{register}</code>" 명령으로 <code class="special">{register}</code>라는 이름의 레지스터에 키 입력 기록을
   시작합니다.  레지스터 이름은 a와 z 사이의 알파벳이어야 합니다.
2. 원하는 명령을 입력하세요.
3. 기록이 끝나면 q를 누르세요 (뒤에 다른 문자를 붙이지 않습니다).

이제 기록한 매크로는 "@<code class="special">{register}</code>" 명령으로 실행할 수 있습니다.

실제로 이 명령들을 어떻게 사용하는지 살펴봅시다.  다음과 같은 파일명 목록이
있다고 합시다:

<code class="section">	stdio.h </code>
<code class="section">	fcntl.h </code>
<code class="section">	unistd.h </code>
<code class="section">	stdlib.h </code>

다음과 같이 바꾸고 싶다고 합시다:

<code class="section">	#include "stdio.h" </code>
<code class="section">	#include "fcntl.h" </code>
<code class="section">	#include "unistd.h" </code>
<code class="section">	#include "stdlib.h" </code>

먼저 첫 번째 줄의 첫 글자로 커서를 움직입시다.  그리고 다음 명령들을
실행해보세요:

	qa			레지스터 a에 매크로 기록을 시작합니다.
	^			줄의 처음으로 이동합니다.
	i#include "<code class="special">&lt;Esc&gt;</code>	줄의 맨 앞에 문자열 #include "를 삽입합니다.
	$			줄의 끝으로 이동합니다.
	a"<code class="special">&lt;Esc&gt;</code>			줄의 맨 끝에 큰따옴표(")를 덧붙입니다.
	j			다음 줄로 이동합니다.
	q			매크로 기록을 끝냅니다.

여기까지 잘 따라 했다면, 이제 "@a" 명령만 세 번 입력하면 원하는 작업이
끝날 겁니다.
   "@a" 명령 앞에는 숫자를 붙일 수 있습니다.  매크로가 수행될 횟수를 지정할 수
있는 것이지요.  위의 경우에는 다음과 같이 입력하면 됩니다:
<code class="example"></code>
<code class="example">	3@a</code>
<code class="example"></code>
<code class="example"></code>
이동 후 실행하기
----------------

바꾸고 싶은 내용이 이곳저곳에 흩어져있을 수도 있을 겁니다.  그냥 커서를 각각의
위치로 이동한 후 "@a" 명령을 사용하세요.  한번이라도 하고 나면, "@@"로
반복해서 실행할 수 있습니다.  타자 치기가 약간 더 쉽지요.  이후에 "@b"와 같이
레지스터 b에 기록한 명령을 실행했다면, 다음 "@@" 명령은 레지스터 b를
사용합니다.
   기록하고 재생하는 기능을 "." 명령과 비교해보면 몇 가지 차이점이 있습니다.
무엇보다, "."로는 한 가지 변경사항만 반복할 수 있습니다.  위의 예에서
보여주듯이 "@a"는 여러 변경사항을 기록할 수 있고, 이리 저리 움직일 수도
있습니다.  두 번째로, "."는 마지막 변경사항만 기억합니다.  레지스터에 명령을
기록해놓으면, 그 이후 다른 부분을 더 고치더라도 여전히 "@a"를 써서 기록한
내용을 재생할 수 있습니다.  마지막으로, 레지스터는 26개가 있습니다.  따라서
26가지 다른 일련의 명령들을 기록할 수 있습니다.


레지스터 사용하기
-----------------

기록을 위해 사용하는 레지스터는 복사와 지우기를 할 때 쓰이는 레지스터와 같은
것입니다.  따라서 기록하는 기능을 다른 레지스터 관리 명령과 조합해서 사용할 수
있습니다.
   레지스터 n에 몇 개의 명령을 기록했다고 해봅시다.  "@n"으로 기록한 내용을
실행해보니 무언가 잘못된 것을 발견했습니다.  다시 처음부터 기록을 다시 할 수도
있겠지만, 아마 이번에는 또 다른 실수를 하기가 일쑤이겠지요.  대신 다음과 같이
해보면 어떨까요?:

	G			파일의 끝으로 갑니다.
	o<code class="special">&lt;Esc&gt;</code>			빈 줄을 하나 만듭니다.
	"np			레지스터 n의 내용을 붙입니다.  입력한 명령들이
				파일에 문자열로 나타날 겁니다.
	<code class="special">{edits}</code>			잘못된 명령을 수정합니다.  보통 파일을
				편집하듯이 말이지요.
	0			줄의 처음으로 이동합니다.
	"ny$			수정한 명령을 레지스터 n에 복사합니다.
	dd			임시로 붙인 내용을 지웁니다.

이제 옳게 수정한 명령을 "@n"로 실행하면 됩니다.  (만약 기록한 명령 중 줄
바꿈이 있다면, 예제의 마지막 두 명령은 여러 줄에 대한 명령으로 바꾸어
사용하세요.)


레지스터에 덧붙이기
-------------------

지금까지 레지스터 이름은 항상 소문자만을 사용해 왔습니다.  레지스터에 내용을
덧붙이려면, 대문자를 사용하세요.
   예를 들어, 단어를 바꾸는 명령을 레지스터 c에 기록했다고 합시다.  적절히
동작은 하는데, 여기에 다음 단어를 찾는 동작을 추가하고 싶다고 해보지요.
다음과 같이 하면 됩니다:
<code class="example"></code>
<code class="example">	qC/단어<code class="special">&lt;Enter&gt;</code>q</code>
<code class="example"></code>
"qC"로 시작했습니다.  c 레지스터에 덧붙여서 기록하라는 것이지요.  즉, 대문자
레지스터 이름에 쓰는 것은, 같은 문자의 소문자 레지스터에 덧붙이라는
의미입니다.

이 동작은 복사나 지우기 명령을 사용할 때도 동일합니다.  예를 들어, 몇몇 줄의
내용을 한 레지스터에 모으고 싶다고 합시다.  첫 번째 줄을 다음 명령으로
복사하세요:
<code class="example"></code>
<code class="example">	"aY</code>
<code class="example"></code>
이제 모을 두 번째 줄로 가서 다음 명령을 입력하세요:
<code class="example"></code>
<code class="example">	"AY</code>
<code class="example"></code>
모든 줄에 대해 이 명령을 반복하면 됩니다.  레지스터 a에는 모든 줄의 내용이
복사한 순서대로 들어갑니다.

</pre><hr><pre><b class="vimtag">*<a name="10.2">10.2</a>*</b>	바꾸기							<b class="vimtag">*<a name="find-replace">find-replace</a>*</b>

":substitute" 명령은 줄 범위 전체에 대하여 문자열 대치를 하는 명령입니다.  이
명령의 일반형은 다음과 같습니다:
<code class="example"></code>
<code class="example">	:<code class="special">[range]</code>substitute/현재 내용/바꿀 내용/[플래그]</code>
<code class="example"></code>
이 명령은 <code class="special">[range]</code> 범위에 지정된 줄에서 "현재 내용" 문자열을 "바꿀 내용"
문자열로 바꿉니다.  예를 들어, 다음 명령은 모든 줄에서 "Professor"를
"Teacher"로 바꿉니다:
<code class="example"></code>
<code class="example">	:%substitute/Professor/Teacher/</code>

	<code class="note">Note:</code>
	":substitute" 명령은 명령 전체를 입력할 일이 거의 없습니다.  대부분의
	경우 ":s"로 줄여서 씁니다.  이후의 내용에서도 줄여서 쓰도록
	하겠습니다.

명령 앞의 "%"는 명령을 전체 줄에 적용하라는 것입니다.  범위를 붙이지 않으면
":s"는 현재 줄에 대해서만 동작합니다.  범위에 대한 더 자세한 내용은 다음 절
|<a href="usr_10.html#10.3">10.3</a>|에서 살펴보겠습니다.

기본적으로 ":substitute" 명령은 각 줄에서 처음 나오는 문자열만을 바꿉니다.
예를 들어, 앞선 명령은 다음과 같은 줄을:

<code class="section">	Professor Smith criticized Professor Johnson today. </code>

다음과 같이 바꿉니다:

<code class="section">	Teacher Smith criticized Professor Johnson today. </code>

줄에 나오는 모든 문자열을 바꾸려면, g (global, 전역) 플래그를 붙여야 합니다.
다음 명령을 실행하면:
<code class="example"></code>
<code class="example">	:%s/Professor/Teacher/g</code>
<code class="example"></code>
다음과 같이 바꿉니다(맨 처음 문장에 적용했습니다):

<code class="section">	Teacher Smith criticized Teacher Johnson today. </code>

그 밖에 다른 플래그를 살펴봅시다.  p (print, 인쇄) 플래그는 ":substitute"
명령이 마지막으로 바꾼 줄을 화면에 출력합니다.  c (confirm, 확인) 플래그는
":substitute"가 실제로 바꾸기 전에 확인을 받도록 합니다.  다음 명령을
입력해봅시다:
<code class="example"></code>
<code class="example">	:%s/Professor/Teacher/c</code>
<code class="example"></code>
Vim은 "Professor"가 처음으로 나오는 곳을 찾은 후, 바뀔 내용이 있는 곳을
보여줍니다.  그리고 다음과 같은 프롬프트가 나옵니다:
<code class="example"></code>
<code class="example">	Teacher(으)로 바꿈 (y/n/a/q/l/^E/^Y)?</code>
<code class="example"></code>
이때, 다음 중 하나로 대답을 입력해야 합니다:

	y		네(Yes). 바꿉니다.
	n		아니요(No). 이번 것은 바꾸지 않습니다.
	a		모두(All). 남아있는 모든 문자열을 확인 없이 모두
			바꿉니다.
	q		중지(Quit). 더 이상 바꾸지 않습니다.
	l		마지막(Last). 이번 것만 바꾸고 중단합니다.
	<code class="keystroke">CTRL-E</code>		한 줄 위로 스크롤 합니다.
	<code class="keystroke">CTRL-Y</code>		한 줄 아래로 스크롤 합니다.


바꾸기 명령의 "현재 내용" 부분은 사실 패턴입니다.  찾기 명령에서 사용하는 패턴
말입니다.  예를 들어, 다음 명령은 줄의 맨 앞에 나오는 "the"만을 바꿉니다:
<code class="example"></code>
<code class="example">	:s/^the/these/</code>
<code class="example"></code>
만약 "현재 내용"이나 "바꿀 내용" 부분에 슬래시(/)가 포함되어있다면, 매번 그
앞에 백슬래시를 넣어줘야 합니다.  아니면 슬래시 대신에 다른 문자를 사용하면 더
간단합니다.  예를 들어 더하기 기호를 써보지요:
<code class="example"></code>
<code class="example">	:s+one/two+one or two+</code>
<code class="example"></code>
</pre><hr><pre><b class="vimtag">*<a name="10.3">10.3</a>*</b>	명령 범위

":substitute" 명령을 비롯한 많은 : 명령들은 일부 줄에만 적용할 수도 있습니다.
이것을 명령 범위(range)라고 부릅니다.
   단순한 형태의 범위는 <code class="special">{숫자}</code>,<code class="special">{숫자}</code> 형식으로 이루어집니다.  예:
<code class="example"></code>
<code class="example">	:1,5s/이것/저것/g</code>
<code class="example"></code>
바꾸기 명령을 1번째 줄에서 5번째 줄까지 실행합니다.  5번째 줄도 포함됩니다.
범위는 언제나 명령 앞에 붙습니다.

줄 하나만 지정할 때는 숫자 하나만 쓰면 됩니다:
<code class="example"></code>
<code class="example">	:54s/President/Fool/</code>
<code class="example"></code>
몇몇 명령은 범위를 지정하지 않을 경우 전체 파일에 대하여 동작합니다.  현재
줄에 대해서만 동작하게 하려면 "."을 줄 번호로 쓰면 됩니다.  ":write" 명령이
이와 같이 동작합니다.  범위 없이는 전체를 파일에 씁니다.  현재 줄만 파일에
쓰도록 하려면:
<code class="example"></code>
<code class="example">	:.write otherfile</code>
<code class="example"></code>
파일의 맨 첫 줄은 언제나 줄 번호가 1입니다.  마지막 줄은 어떨까요?  마지막
줄을 가리키기 위해 "$" 문자를 씁니다.  예를 들어, 현재 커서가 있는 줄부터
파일의 마지막까지에 대하여 바꾸기를 하려면:
<code class="example"></code>
<code class="example">	:.,$s/yes/no/</code>
<code class="example"></code>
앞에서 사용했던 "%" 범위는 사실 "1,$" 즉, 첫 번째 줄부터 마지막 줄까지를 짧게
표현한 것입니다.


범위에 패턴 사용하기
--------------------

책에서 한 장(Chapter)을 편집하고 있다고 합시다.  그리고 "grey"를 모두 "gray"로
바꾸고 싶다고 해보지요.  단, 이번 장만 바꾸고 다음 장은 그대로 놔두고 싶다고
합시다.  당신은 장이 바뀌는 곳에만 "Chapter"가 줄의 맨 첫 칸에 나온다는 걸
알고 있습니다.  그렇다면 다음 명령을 사용하면 됩니다:
<code class="example"></code>
<code class="example">	:?^Chapter?,/^Chapter/s=grey=gray=g</code>
<code class="example"></code>
찾기 패턴을 두 번 사용한 것을 볼 수 있는데요.  첫 번째 "?^Chapter?"는 현재
위치에서 위쪽에 패턴과 일치하는 것이 있는지 찾습니다.  즉 ?패턴? 범위는 거꾸로
가면서 찾을 때 씁니다.  비슷하게 "/^Chapter/"는 아래로 가면서 다음 장의 시작을
찾는데 사용합니다.
   슬래시로 인해 헷갈리는 것을 피하기 위해 위 명령의 바꾸기 패턴 부분에는 "="
문자를 사용했습니다.  그냥 슬래시를 쓰거나 아니면 또 다른 문자를 써도 상관
없습니다.


더하기와 빼기
-------------

사실 앞서의 명령에는 약간 틀린 점이 있습니다.  만약 다음 장의 제목에 "grey"가
있다면, 이것도 바뀌어 버릴 겁니다.  의도한 것일 수도 있지만, 그렇게 하고 싶지
않다면 어떻게 해야 할까요?  이때는 오프셋을 주면 됩니다.
   패턴을 찾고, 그보다 한 줄 위를 사용하려면:
<code class="example"></code>
<code class="example">	/Chapter/-1</code>
<code class="example"></code>
1 대신 어떤 숫자든 쓸 수 있습니다.  찾은 위치에서 두 줄 아래를 지정하려면:
<code class="example"></code>
<code class="example">	/Chapter/+2</code>
<code class="example"></code>
오프셋은 범위의 다른 요소에도 사용할 수 있습니다.  다음 예를 보세요:
<code class="example"></code>
<code class="example">	:.+3,$-5</code>
<code class="example"></code>
위 범위는 커서가 있는 줄에서 세 줄 아래에서 시작하여, 파일의 마지막 줄에서
다섯 줄 위에서 끝납니다.


마크 사용하기
-------------

특정 위치의 줄 번호를 보고 기억해놓았다가 이걸 다시 범위로 입력하는 복잡한
단계를 거치는 대신, 마크를 사용할 수 있습니다.
   3장에서 살펴본 것과 같이 마크를 지정합니다.  예를 들어, 영역의 처음은
"mt"로 표시하고, 끝은 "mb"로 표시합시다.  그리고 다음 범위를 사용하면 두 마크
사이의 줄들을 지정할 수 있습니다 (마크가 위치한 줄도 포함됩니다):
<code class="example"></code>
<code class="example">	:'t,'b</code>
<code class="example"></code>
<code class="example"></code>
시각 모드와 범위
----------------

시각 모드에서는 원하는 부분을 선택할 수 있습니다.  이때 ":"를 누르고 콜론
명령을 입력하기 시작하면 다음과 같이 표시됩니다:
<code class="example"></code>
<code class="example">	:'<code class="special">&lt;,'&gt;</code></code>
<code class="example"></code>
이제 명령을 입력하면, 이 명령은 시각 모드에서 선택된 범위의 줄들에 적용될
겁니다.

	<code class="note">Note:</code>
	시각 모드에서 줄의 일부만 선택했거나, <code class="keystroke">CTRL-V</code>를 이용하여 블록으로
	선택했더라도, 콜론 명령은 선택한 부분이 있는 줄 전체에 적용됩니다.  이
	동작은 Vim의 차후 버전에서는 바뀔 수도 있습니다.

'<code class="special">&lt;와 '&gt;</code>는 사실은 마크입니다.  시각 모드 선택 범위의 시작과 끝에 놓이지요.  이
마크는 다시 시각 모드에서 선택을 하기 전까지는 그대로입니다.  따라서 "'&lt;"
명령으로 시각 모드의 시작 위치로 갈 수 있습니다.  이 마크를 다른 요소들과
조합해서 사용할 수도 있고요:
<code class="example"></code>
<code class="example">	:'&gt;,$</code>
<code class="example"></code>
위 범위는 시각 모드의 선택 영역이 끝나는 줄에서 파일의 맨 끝까지를 의미합니다.


줄의 수
-------

몇 개의 줄을 바꿀 것인지 알고 있다면 숫자를 입력한 후 ":"을 누르면 됩니다.
예를 들어, "5:"를 입력하면 다음과 같이 나옵니다:
<code class="example"></code>
<code class="example">	:.,.+4</code>
<code class="example"></code>
이제 사용하고 싶은 명령을 입력하면 됩니다.  이 명령은 "."(현재 줄)에서
".+4"(네 줄 아래) 사이의 범위에 적용됩니다.  다섯 줄에 적용되는 것이지요.

</pre><hr><pre><b class="vimtag">*<a name="10.4">10.4</a>*</b>	global 명령

":global" 명령은 Vim에서 가장 강력한 기능들 중 하나입니다.  패턴으로 일치하는
곳을 찾고, 거기서 명령을 실행하는 기능이지요.  일반형은 다음과 같습니다:
<code class="example"></code>
<code class="example">	:<code class="special">[range]</code>global/<code class="special">{pattern}</code>/<code class="special">{command}</code></code>
<code class="example"></code>
언뜻 보면 ":substitute" 명령과 비슷합니다.  하지만, 일치하는 부분을 다른
내용으로 바꾸지 않고, <code class="special">{command}</code>에 지정된 명령을 실행합니다.

	<code class="note">Note:</code>
	":global" 로 실행되는 명령은 콜론으로 시작하는 명령이어야 합니다.
	보통 모드 명령은 바로 쓸 수 없습니다.  |<code class="badlink">:normal</code>| 명령을 사용해서
	써야 합니다.

"거시기머시기"를 "머시기거시기"로 바꾸고 싶은데, C++ 형식 주석에서만 바꾸고
싶다고 합시다.  이런 주석들은 "//"로 시작하는데요, 다음 명령을 사용하면
됩니다:
<code class="example"></code>
<code class="example">	:g+//+s/거시기머시기/머시기거시기/g</code>
<code class="example"></code>
":g"로 시작하는데요, ":global"을 줄여서 쓴 것입니다.  ":substitute"를 ":s"로
줄여서 쓴 것처럼 요.  그 뒤에는 더하기 기호로 둘러싼 패턴이 나옵니다.  찾고자
하는 패턴에 슬래시가 포함되어있어서 패턴 부분을 가리키기 위해 더하기 기호를
사용했습니다.  그 뒤에는 "거시기머시기"를 "머시기거시기"로 바꾸는 명령이
옵니다.
   global 명령의 기본 범위는 전체 파일입니다.  그래서 위 예에는 범위를
지정하지 않았습니다.  이는 ":substitute"에 범위를 지정하지 않으면 현재 줄에만
적용되는 것과 다르지요.
   이 명령은 사실 완벽하지 않습니다.  왜냐하면 "//"가 줄 중간에 있는 경우에도
바꾸기가 적용 되는데, 이때 "//"의 앞에 나오는 "거시기머시기"도 바뀌기
때문입니다.

":substitute"와 마찬가지로 어떤 패턴이든 쓸 수 있습니다.  나중에 복잡한 패턴을
쓸 수 있게 된다면, 여기에 사용할 수 있습니다.

</pre><hr><pre><b class="vimtag">*<a name="10.5">10.5</a>*</b>	블록 시각 모드

<code class="keystroke">CTRL-V</code>를 사용하면 사각형 범위의 내용을 선택할 수 있습니다.  블록에 대하여
특별한 일들을 할 수 있는 몇 가지 명령이 있습니다.

블록 시각 모드에서 "$" 명령을 사용하면 동작이 조금 다릅니다.  만약 마지막
움직임 명령이 "$"이었다면, 선택 영역이 있는 모든 줄에서 줄의 끝까지가 선택
영역에 포함됩니다.  커서가 있는 줄의 길이가 다른 줄보다 더 짧더라도 말이지요.
이런 상태는 커서를 좌우로 움직이는 움직임 명령을 사용할 때까지 계속 됩니다.
즉 "j"로는 상태가 유지되지만, "h"를 누르면 끝납니다.


내용 입력하기
-------------

"I<code class="special">{string}</code><code class="special">&lt;Esc&gt;</code>" 명령은 <code class="special">{string}</code> 부분의 내용을 각 줄의 블록 왼쪽에 삽입합니다.
먼저 <code class="keystroke">CTRL-V</code>를 눌러 블록 시각 모드에 들어갑시다.  그리고 커서를 움직여 블록을
선택하세요.  이제 I를 눌러 입력 모드로 바꾼 후, 원하는 내용을 입력하세요.  이
때는 입력한 내용이 첫 번째 줄에만 표시됩니다.
   입력을 끝낸 후 <code class="special">&lt;Esc&gt;</code>를 눌러보세요.  짜잔.  선택영역에 들어있던 나머지 다른
줄에도 동일한 내용이 삽입됩니다.  예:

<code class="section">	include one </code>
<code class="section">	include two </code>
<code class="section">	include three </code>
<code class="section">	include four </code>

커서를 "one"의 "o"에 놓고 <code class="keystroke">CTRL-V</code>를 누르세요.  "3j"로 "four"까지 내려오세요.
이제 네 줄에 걸친 선택 영역이 생겼을 겁니다.  이제 다음 내용을 입력하세요:
<code class="example"></code>
<code class="example">	Imain.<code class="special">&lt;Esc&gt;</code></code>
<code class="example"></code>
결과는:

<code class="section">	include main.one </code>
<code class="section">	include main.two </code>
<code class="section">	include main.three </code>
<code class="section">	include main.four </code>

만약 블록이 블록 범위에 들어가지 못하는 짧은 내용의 줄을 지난다면, 그런 줄에는
내용이 삽입되지 않습니다.  예를 들어, 다음 예에서 첫 번째 줄과 마지막 줄의
"long" 단어를 포함하도록 블록을 만들어보세요.  두 번째 줄에서는 선택된 부분이
없도록 말이지요:

<code class="section">	This is a long line </code>
<code class="section">	short </code>
<code class="section">	Any other long line </code>

		  ^^^^ 선택한 블록

이제 "Ivery <code class="special">&lt;Esc&gt;</code>" 명령을 입력해보세요.  결과는:

<code class="section">	This is a very long line </code>
<code class="section">	short </code>
<code class="section">	Any other very long line </code>

짧은 줄에는 아무런 내용도 들어가지 않았습니다.

만약 입력한 문자열에 줄 바꿈이 포함되어있다면, "I"는 보통 모드명령과 동일하게
동작해서 오직 블록의 첫 번째 줄에만 영향을 줍니다.

"A" 명령도 블록의 오른쪽에 내용을 삽입하는 것을 빼면 같은 방식으로 동작합니다.
그리고 "A"는 짧은 줄에도 내용을 삽입한다는 점도 다릅니다.  따라서 짧은 줄에
내용을 넣고 싶은지 아닌지에 따라 명령을 고르면 되겠습니다.
   "A" 명령을 사용할 때 또 한 가지 특별한 경우가 있습니다.  블록을 선택한 후,
"$"를 눌러서 블록이 각 줄의 끝까지 가도록 만듭시다.  이때 "A"를 사용하면
내용이 각 줄의 끝에 삽입됩니다.
   위에서와 동일한 예를 사용해봅시다.  그리고 "$A XXX<code class="special">&lt;Esc&gt;</code>"를 입력하면 다음과
같은 결과가 나옵니다:

<code class="section">	This is a long line XXX </code>
<code class="section">	short XXX </code>
<code class="section">	Any other long line XXX </code>

여기에 "$" 명령을 사용할 가치가 있습니다.  Vim은 "$"를 사용했다는 것을
기억하는 것이지요.  가장 긴 줄의 끝까지 다른 움직임 명령으로 이동해서 동일한
선택 범위를 만들더라도, 명령의 결과는 다릅니다.


내용 바꾸기
-----------

블록 시각 모드에서 "c" 명령을 누르면, 해당 블록이 지워지고 새로운 내용을
입력할 수 있는 입력 모드로 바뀝니다.  입력하는 문자열은 블록의 각 줄에
삽입됩니다.
   앞서의 예와 똑같이 "long"을 선택한 상태라고 합시다.  여기서
"c_LONG_<code class="special">&lt;Esc&gt;</code>"를 입력하면, 다음과 같이 됩니다:

<code class="section">	This is a _LONG_ line </code>
<code class="section">	short </code>
<code class="section">	Any other _LONG_ line </code>

"I"와 마찬가지로 짧은 줄은 바뀌지 않습니다.  또, 새로 입력하는 내용에
줄 바꿈을 입력할 수 없습니다.

"C" 명령은 블록의 왼쪽 끝에서부터 각 줄의 끝까지의 내용을 지웁니다.  그리고는
각 줄의 뒤에 붙을 내용을 입력하는 입력 모드로 바뀝니다.
   다시 같은 내용을 예로 들어보지요.  "Cnew text<code class="special">&lt;Esc&gt;</code>"를 입력하면 다음과 같이
됩니다:

<code class="section">	This is a new text </code>
<code class="section">	short </code>
<code class="section">	Any other new text </code>

"long" 부분만 선택했지만, 그 이후의 부분도 함께 지워진 데 주목하세요.  즉
블록으로 선택한 부분 중 왼쪽 끝의 위치만 중요합니다.
   역시 이번에도 블록에 닿지 않는 짧은 줄은 아무 변화가 없습니다.

블록의 문자를 바꾸는 다른 명령을 보면:

	~	대소문자 바꿈	(a -&gt; A 그리고 A -&gt; a)
	U	대문자로 바꿈  (a -&gt; A 그리고 A -&gt; A)
	u	소문자로 바꿈  (a -&gt; a 그리고 A -&gt; a)


문자로 채우기
-------------

블록 전체를 하나의 문자로 채우려면 "r" 명령을 사용하세요.  다시 한 번 위에서
본 예를 가져와 봅시다.  "rx"를 입력하면:

<code class="section">	This is a xxxx line </code>
<code class="section">	short </code>
<code class="section">	Any other xxxx line </code>


	<code class="note">Note:</code>
	블록에서 줄의 끝을 지나서 문자를 입력하고 싶다면, 25장에서
	가상 편집('virtualedit') 기능을 확인해보세요.


들여쓰기
--------

"&gt;" 명령은 선택한 부분을 들여쓰기 한 번만큼 공백을 넣어 오른쪽으로
이동시킵니다.  이동시키는 시작점은 블록의 왼쪽 경계입니다.
   앞의 예에서 "&gt;"를 누르면 다음과 같이 됩니다:

<code class="section">	This is a	  long line </code>
<code class="section">	short </code>
<code class="section">	Any other	  long line </code>

들여쓰기 하는 정도는 'shiftwidth' 옵션으로 지정합니다.  공백 네 개만큼
들여 쓰도록 바꾸려면:
<code class="example"></code>
<code class="example">	:set shiftwidth=4</code>
<code class="example"></code>
"&lt;" 명령은 블록의 왼쪽 경계에서부터 들여쓰기 한 번만큼의 공백을 지웁니다.  이
명령은 지울 위치에 있는 내용에 따라 제약을 받습니다.  만약 들여쓰기 한 번
만큼의 공백이 없다면, 지울 수 있는 만큼만 지웁니다.


여러 줄을 붙이기
----------------

"J" 명령은 선택한 줄들을 한 줄로 이어 붙입니다.  즉, 줄 바꿈을 없앱니다.
실제로는 줄 바꿈과 맨 앞이나 맨 뒤의 공백들을 모아서 하나의 공백으로 바꿉니다.
단, 문장이 끝나는 곳에는 두 개의 공백으로 바꿉니다 (이 기능은 'joinspaces'
옵션으로 바꿀 수 있습니다).
   어느덧 익숙해져버린 예제를 다시 봅시다.  "J" 명령을 사용했을 때의 결과는:

<code class="section">	This is a long line short Any other long line </code>

"J" 명령은 사실 블록으로 선택할 필요가 없습니다.  "v"나 "V"로 선택했을 때와
완전히 동일하게 동작합니다.

공백을 유지한 채로 붙이고 싶다면, "gJ" 명령을 사용하세요.

</pre><hr><pre><b class="vimtag">*<a name="10.6">10.6</a>*</b>	파일의 일부를 읽고 쓰기

이메일을 쓰다보면, 다른 파일의 내용을 넣고 싶을 때가 있습니다.  이건 ":read
<code class="special">{파일명}</code>" 명령을 사용하면 됩니다.  파일의 내용이 커서가 있는 줄 밑으로
삽입됩니다.
   다음 내용으로 시작해봅시다:

<code class="section">	영표야 안녕? </code>
<code class="section">	네가 말한 버그를 고치는 디프야: </code>
<code class="section">	그럼 이만.  지성. </code>

커서를 두 번째 줄로 옮긴 후 다음을 입력하세요:
<code class="example"></code>
<code class="example">	:read patch</code>
<code class="example"></code>
"patch"란 이름의 파일이 삽입되어 다음과 같이 됩니다:

<code class="section">	영표야 안녕? </code>
<code class="section">	네가 말한 버그를 고치는 디프야: </code>
<code class="section">	2c2 </code>
<code class="section">	&lt;	for (i = 0; i &lt;= length; ++i) </code>
<code class="section">	--- </code>
<code class="section">	&gt;	for (i = 0; i &lt; length; ++i) </code>
<code class="section">	그럼 이만.  지성. </code>

":read" 명령은 범위를 받습니다.  파일이 범위의 마지막 줄 밑으로 삽입됩니다.
즉 ":$r patch"는 "patch" 파일의 내용을 현재 파일의 끝에 넣습니다.
   만약 첫 번째 줄 위로 파일의 내용을 넣고 싶다면 어떻게 해야 할까요?  줄
번호로 0을 사용하면 됩니다.  0번째 줄이라는 것은 없으므로, 대부분의 명령에서는
0번째 줄을 지정하면 에러가 날 겁니다.  하지만 ":read" 명령에서는 사용할 수
있습니다:
<code class="example"></code>
<code class="example">	:0read patch</code>
<code class="example"></code>
"patch" 파일의 내용이 첫 번째 줄 위로 삽입됩니다.


범위의 줄들을 쓰기
------------------

파일에 특정 범위의 줄들을 쓰려면, ":write" 명령을 사용하면 됩니다.  범위를
지정하지 않으면 이 명령은 파일 전체를 씁니다.  범위를 지정하면 지정한 범위
내의 줄들만 씁니다:
<code class="example"></code>
<code class="example">	:.,$write tempo</code>
<code class="example"></code>
위 명령은 현재 커서가 있는 줄에서 파일의 끝까지를 "tempo"라는 파일에 씁니다.
만약 이 파일이 이미 존재한다면 에러가 발생합니다.  Vim이 실수로 파일을
덮어쓰는 것을 막아주는 것이지요.  실수가 아니고 정말로 덮어쓰고 싶은 거라면
!를 덧붙이면 됩니다:
<code class="example"></code>
<code class="example">	:.,$write! tempo</code>
<code class="example"></code>
주의: !는 ":write" 직후에 공백 없이 바로 와야 합니다.  그렇지 않으면 이번
장에서 나중에 살펴볼 필터 명령으로 해석됩니다.


파일에 덧붙이기
---------------

이번 장 첫 번째 절에서 여러 줄들을 하나의 레지스터에 모으는 방법에 대해
설명했었습니다.  비슷하게 여러 줄들을 하나의 파일에 모을 수도 있습니다.  먼저
첫 번째 줄을 다음 명령으로 저장하세요:
<code class="example"></code>
<code class="example">	:.write collection</code>
<code class="example"></code>
이제 모을 두 번째 줄로 가서 다음 명령을 입력하세요:
<code class="example"></code>
<code class="example">	:.write &gt;&gt;collection</code>
<code class="example"></code>
"&gt;&gt;"는 "collection"라는 새로운 파일에 쓰는 것이 아니라 파일의 뒤에
덧붙여야한다는 의미입니다.  이제 이 명령을 필요한 만큼 반복하면 됩니다.

</pre><hr><pre><b class="vimtag">*<a name="10.7">10.7</a>*</b>	서식에 맞추기

서식이 없는 단순한 글을 입력할 때, 자동으로 화면의 폭에 맞게 줄이 바뀐다면
멋지겠지요.  내용을 입력하는 도중에 이렇게 되게 하려면 'textwidth' 옵션을
설정하면 됩니다:
<code class="example"></code>
<code class="example">	:set textwidth=72</code>
<code class="example"></code>
아마도 예제 vimrc 파일에서 이 명령을 모든 텍스트 파일에 대해 적용했던 기억이
나실 겁니다.  그 vimrc 파일을 아직 사용하고 있다면, 이미 이 옵션도 사용하고
있는 것입니다.  현재 'textwidth'의 값을 확인하고 싶다면:
<code class="example"></code>
<code class="example">	:set textwidth</code>
<code class="example"></code>
이제 각 줄이 72글자 이상이 되지 않도록 자동으로 끊어질 겁니다.  하지만 줄의
중간에 새로운 내용을 넣거나, 몇 단어를 지우거나 하면 줄이 너무 길어지거나
짧아지게 됩니다.  Vim은 이런 경우에는 자동으로 맞춰주지 않습니다.
   Vim에게 현재 단락을 다시 맞추도록 하려면:
<code class="example"></code>
<code class="example">	gqap</code>
<code class="example"></code>
이 명령은 "gq" 명령으로 시작하는데, 이 명령은 오퍼레이터입니다.  그 뒤에 "ap",
즉 "단락 하나(a paragraph)"를 의미하는 텍스트 오브젝트가 오지요.  단락은 다음
단락과 빈 줄로 구분됩니다.

	<code class="note">Note:</code>
	공백 문자를 포함하고 있는 빈 줄은 단락 간 구분으로 인정되지 않습니다.
	눈으로 보고 구별하기 어려운 부분이니 주의하세요.

"ap" 대신 다른 움직임 명령이나 텍스트 오브젝트를 사용할 수 있습니다.  단락이
잘 나누어져 있다면, 다음 명령으로 전체 파일의 서식을 맞출 수 있습니다:
<code class="example"></code>
<code class="example">	gggqG</code>
<code class="example"></code>
먼저 "gg"로 첫 번째 줄로 이동합니다.  "gq"는 서식을 맞추는 오퍼레이터이고,
"G"는 마지막 줄로 이동하는 움직임 명령입니다.

단락이 정확히 잘 나누어져있지 않은 경우라면, 직접 줄들을 선택해서 서식을
맞추면 됩니다.  커서를 맞출 부분의 첫 번째 줄로 옮기세요.  "gqj" 명령으로
서식 맞추기를 시작하세요.  이 명령은 현재 줄과 바로 아래 줄의 서식을 맞춥니다.
만약 첫 번째 줄이 짧았다면, 다음 줄의 어절들이 위로 올라갑니다.  너무
길었다면 뒤의 어절들이 다음 줄로 넘어가고요.  커서는 다음 줄로 넘어갑니다.
그 후에는 "."로 명령을 반복하면 됩니다.  서식을 맞출 부분의 끝에 갈 때까지
계속 반복하세요.

</pre><hr><pre><b class="vimtag">*<a name="10.8">10.8</a>*</b>	대소문자 바꾸기

절의 제목을 소문자로 썼다고 합시다.  여기서 "section"이라는 부분만 모두
대문자로 바꾸고 싶습니다.  이것은 "gU" 오퍼레이터를 사용하면 됩니다.  먼저
커서를 맨 첫 칸으로 옮깁니다:
<code class="example"></code>
<code class="example">			     gUw</code>
	section header	    ----&gt;      SECTION header

"gu" 오퍼레이터는 정확히 반대의 일을 합니다:
<code class="example"></code>
<code class="example">			     guw</code>
	SECTION header	    ----&gt;      section header

아니면 "g~"로 대소문자를 바꿀 수도 있습니다.  이 세 가지는 모두
오퍼레이터이므로, 움직임 명령어나 텍스트 오브젝트, 시각 모드와 함께 사용할 수
있습니다.
   한 줄에 대해 오퍼레이터를 적용하려면 두 번 입력하면 됩니다.  지우기
오퍼레이터가 "d"이므로 "dd"는 한 줄을 지우는 것입니다.  비슷하게 "gugu"는 줄
전체를 소문자로 만듭니다.  이 명령은 "guu"로 줄여서 쓸 수 있습니다.
마찬가지로 "gUgU"는 "gUU"로, "g~g~"는 "g~~"로 줄여서 쓸 수 있습니다.  예:
<code class="example"></code>
<code class="example"><code class="section">				g~</code></code>
<code class="section">	Some GIRLS have Fun    ----&gt;   sOME girls HAVE fUN </code>

</pre><hr><pre><b class="vimtag">*<a name="10.9">10.9</a>*</b>	외부 프로그램 사용하기

Vim에는 매우 강력한 명령들이 있습니다.  못할 일이 없지요.  하지만 여전히 외부
프로그램이 더 잘 하거나 빠르게 할 수 있는 일들이 남아있습니다.
   "!<code class="special">{motion}</code><code class="special">{program}</code>" 명령은 파일의 한 부분을 가져다가 외부 프로그램에 필터
시킵니다.  다른 말로 표현해보자면, <code class="special">{motion}</code> 움직임으로 표현되는 부분의 내용을
입력으로 <code class="special">{program}</code>이 가리키는 시스템 명령을 실행합니다.  이 명령의 결과가
선택한 부분을 대체하게 됩니다.
   유닉스의 필터 개념에 익숙하지 않다면 이 설명이 잘 이해가 되지 않을 겁니다.
예를 들어서 살펴봅시다.  sort 명령은 파일을 정렬합니다.  아래 명령을 실행하면,
정렬되지 않은 input.txt 파일을 정렬한 결과가 output.txt 파일에 저장됩니다.
(이 명령은 유닉스와 마이크로소프트 윈도 둘 다에서 동작합니다.)
<code class="example"></code>
<code class="example">	sort <code class="special">&lt;input.txt &gt;</code>output.txt</code>
<code class="example"></code>
이제 같은 일을 Vim에서 해 봅시다.  파일의 첫 번째 줄에서 다섯 번째 줄까지를
정렬하고 싶다고 합시다.  먼저 커서를 첫 번째 줄로 옮깁니다.  그리고 아래
명령을 실행합시다:
<code class="example"></code>
<code class="example">	!5G</code>
<code class="example"></code>
"!"은 필터 작업을 한다고 Vim에게 알려주는 명령입니다.  그러면 Vim은 파일에서
필터를 적용할 부분을 정의하는 움직임 명령을 기다리게 됩니다.  "5G" 명령은
Vim에게 5번째 줄로 가라고 알려줍니다.  이로써 필터를 적용하는 범위는 첫 번째
줄(현재 줄)에서 5번째 줄까지가 되는 것입니다.
   이제 필터를 입력받기 위해 화면의 맨 아래 줄에 커서가 나타나면서 !
프롬프트가 표시됩니다.  그러면 필터 프로그램의 이름, 이 예에서라면 "sort"를
입력하면 됩니다.  따라서 전체 명령은 다음과 같습니다:
<code class="example"></code>
<code class="example">	!5Gsort<code class="special">&lt;Enter&gt;</code></code>
<code class="example"></code>
그 결과로 첫 다섯 줄의 내용에 대하여 정렬 프로그램이 동작합니다.  프로그램의
출력이 이 다섯 줄을 대체하게 됩니다.

	line 55			      line 11
	line 33			      line 22
	line 11		--&gt;	      line 33
	line 22			      line 44
	line 44			      line 55
	last line		      last line

"!!" 명령은 현재 줄에 필터를 적용합니다.  유닉스에서는 "date" 명령이 현재
날짜와 시간을 출력하는데요, "!!date<code class="special">&lt;Enter&gt;</code>"는 현재 줄의 내용을 "date" 명령의
출력으로 바꿉니다.  파일에 시간을 기록하고 싶을 때 유용하지요.


명령이 작동하지 않을 때
-----------------------

셸을 시작하고, 내용을 보낸 후 출력을 얻어내려면 셸이 정확히 어떻게 동작하는지
Vim이 알아야 합니다.  필터가 잘 동작하지 않는다면, 다음 옵션들의 값을
확인해보세요:

	'shell'		Vim이 외부 프로그램을 실행할 때 사용할 프로그램을
			지정.
	'shellcmdflag'	셸에 명령을 보낼 때 붙일 인자
	'shellquote'	명령을 따옴표로 둘러싸야 하는지 여부
	'shellxquote'	명령과 리디렉션을 따옴표로 둘러싸야 하는지 여부
	'shelltype'	셸의 종류 (Amiga에서만 사용)
	'shellslash'	명령에서 그냥 슬래시를 사용해야하는지
			여부(마이크로소프트 윈도류에서만 사용)
	'shellredir'	명령의 출력을 파일에 쓰기 위해 사용하는 문자열

유닉스에서라면 문제가 생길 일이 별로 없습니다.  크게 "sh"류와 "csh"류, 두 가지
셸만 있기 때문이지요.  Vim은 'shell' 옵션을 확인해보고 옵션에 "csh"이
포함되어있는지에 따라 관련된 옵션들을 자동으로 설정합니다.
   하지만 마이크로소프트 윈도에서는 다양한 셸들이 있기 때문에 필터가 제대로
동작하려면 옵션들을 직접 맞춰야 할 수도 있습니다.  더 자세한 내용은 각 옵션의
도움말을 확인해보세요.


명령의 출력을 읽어 들이기
-------------------------

현재 디렉터리의 내용을 파일로 읽어 들이려면, 다음 명령을 사용하세요:

유닉스에서는:
<code class="example">	:read !ls</code>
마이크로소프트 윈도에서는:
<code class="example">	:read !dir</code>
<code class="example"></code>
"ls"나 "dir" 명령의 출력 내용이 그대로 현재 커서 밑에 삽입됩니다.  파일을 읽는
것과 비슷하지요?  파일 이름 대신 "!"과 함께 명령이 온다는 점만 다릅니다.
   명령에는 인자가 있을 수도 있습니다.  출력 내용을 어디에 삽입할 지를
지정하기 위해 범위를 지정할 수도 있습니다:
<code class="example"></code>
<code class="example">	:0read !date -u</code>
<code class="example"></code>
위 명령은 현재 날짜와 시간을 UTC 형식으로 파일의 맨 처음에 삽입합니다.  (물론
date 명령이 "-u" 인자를 지원해야겠지요.)  "!!date" 명령과의 차이점에
주의하세요.  "!!date"는 현재 줄을 대체하는 반면, ":read !date"는 새로운 줄을
삽입합니다.


명령에 내용을 쓰기
------------------

유닉스 명령 "wc"는 단어의 수를 세는 명령입니다.  현재 파일의 단어 수를 세려면:

<code class="example">	:write !wc</code>
<code class="example"></code>
그동안 사용해오던 write 명령과 동일한 명령입니다.  다만 파일 명을 지정하는
대신 "!"와 외부 명령의 이름을 사용했습니다.  명령에 쓴 내용은 명령의 표준
입력으로 들어갑니다.  출력은 다음과 같은 형태가 됩니다:

<code class="section">       4      47     249 </code>

"wc" 명령의 출력은 참 단순하지요?  위 출력은 4개의 줄, 47개의 단어, 249개의
문자가 있다는 뜻입니다.

다음과 같이 실수하지 않도록 주의하세요:
<code class="example"></code>
<code class="example">	:write! wc</code>
<code class="example"></code>
이 명령은 현재 디렉터리의 "wc"라는 파일에 무조건 쓰라는 것입니다.  여기서는
공백이 아주 중요합니다!


화면을 다시 그리기
------------------

만약 외부 명령이 에러 메시지를 내보냈다면, 화면이 약간 엉킬 수 있습니다.
Vim은 매우 효율적이어서 다시 그릴 필요가 있다는 걸 알 때만 해당 부분을 다시
그리는데요, 다른 프로그램이 내보낸 출력에 대해서는 Vim이 알 수가 없습니다.
Vim이 화면을 다시 그리도록 하려면:
<code class="example"></code>
<code class="example">	<code class="keystroke">CTRL-L</code></code>
<code class="example"></code>
</pre><hr><pre><code class="example"></code>
다음 장: |<a href="usr_11.html#usr_11.txt">usr_11</a>|  작업 복구하기

저작권: |<a href="usr_01.html#manual-copyright">manual-copyright</a>| 참고  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2013. 12. 14. (토) 19:53:58 KST</i></p>
</body>
</html>
