<!DOCTYPE html>
<html>
<head>
<title>VIM: intro</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>INTRO</h2>
<pre>
<b class="vimtag">*<a name="intro.txt">intro.txt</a>*</b>     Vim version 7.4 대상.  새로 고침: 2013년 6월 17일


		     VIM 상세 설명서 - Bram Moolenaar 저
				       정지용 역


Vim 소개						<b class="vimtag">*<a name="ref">ref</a>*</b> <b class="vimtag">*<a name="reference">reference</a>*</b>

1. 소개				|<a href="intro.html#intro">intro</a>|
2. 인터넷 상의 Vim		|<a href="intro.html#internet">internet</a>|
3. 공헌하신 분			|<a href="intro.html#credits">credits</a>|
4. 표기법			|<a href="intro.html#notation">notation</a>|
5. 모드 소개			|<a href="intro.html#vim-modes-intro">vim-modes-intro</a>|
6. 모드 바꾸기			|<a href="intro.html#mode-switching">mode-switching</a>|
7. 화면 내용			|<a href="intro.html#window-contents">window-contents</a>|
8. 용어 정의			|<a href="intro.html#definitions">definitions</a>|

</pre><hr><pre>1. 소개							<b class="vimtag">*<a name="intro">intro</a>*</b>

Vim(빔)은 Vi IMproved(개선된 Vi)를 의미합니다.  Vi IMitation(Vi 모방품)이던
시절도 있었지만, 이제는 지금의 이름이 어울릴만큼 많은 개선이 있었습니다.
Vim은 텍스트 편집기로, 유닉스 프로그램 "Vi"의 거의 대부분의 명령을 지원합니다.
뿐만 아니라 많은 새로운 기능도 갖고 있습니다.  프로그램이나 다른 일반 텍스트
문서를 편집하기에 아주 좋습니다.
   모든 명령은 키보드로 입력합니다.  손은 키보드에, 눈은 화면에 항상 고정할 수
있다는 장점이 있지요.  혹시나 원하신다면 마우스를 쓸 수도 있고, 스크롤바와
메뉴가 있는 GUI 버전도 쓸 수 있습니다 (|<code class="badlink">gui</code>|를 참고하세요).

이 설명서의 전체적인 구성은 "help.txt" 파일에서 확인하세요 |<a href="help.html#help.txt">help</a>|.  Vim
안에서 <code class="special">&lt;Help&gt;</code>나 <code class="special">&lt;F1&gt;</code> 키, 혹은 |<code class="badlink">:help</code>| 명령(따옴표나 세로줄 없이 ":help"만
입력하세요)으로 보실 수 있습니다.
   도움말 파일이 기본 위치에 있지 않은 경우에는 'helpfile' 옵션에 도움말
파일의 이름을 지정하면 됩니다.  태그를 사용할 때 처럼 주제들 사이를 이동할 수
있습니다.  커서가 위치한 곳의 주제로 이동하려면 CTRL-]를 사용하고, 돌아오려면
<code class="keystroke">CTRL-T</code>를 사용하세요.

설명서 전체에 걸쳐 Vi와 Vim의 차이점은 중괄호 안에 표시하였습니다.  다음과
같이요.  <code class="special">{Vi에는 온라인 도움말이 없습니다}</code>.  |<code class="badlink">vi_diff</code>|에 Vim과 Vi의
차이점을 요약해 두었습니다.

이 설명서는 다양한 환경의 Vim을 다룹니다.  컴퓨터나 터미널에 따라 조금씩 다른
점들이 있을 수 있습니다.  이 문서에서 언급하는 것 외에도, 지원하는 시스템 별로
각각 별도의 문서가 있습니다.  |<a href="help.html#sys-file-list">sys-file-list</a>|를 참고하세요.

							<b class="vimtag">*<a name="pronounce">pronounce</a>*</b>
Vim은 한 단어 '빔'으로 발음합니다.  Jim을 '짐'으로 읽는 것처럼요.
브이-아이-엠이 아닙니다.  이름이기 때문에 첫 글자를 대문자로 씁니다.
Jim같이 말이지요.

이 설명서는 Vim의 모든 명령과 옵션을 다룹니다.  Vi나 Vim을 사용하는 법을
설명하는 것이 아니라서 여기저기 좀 복잡한 것들이 나옵니다.  Vim이 처음
이시라면, |<a href="usr_01.html#tutor">tutor</a>|로 직접 체험해보세요.  Vim 사용법을 배우려면 사용설명서
|<a href="usr_toc.html#usr_toc.txt">usr_toc</a>|를 보세요.

							<b class="vimtag">*<a name="book">book</a>*</b>
초보자를 위한 부분이 들어있는 Vi에 관한 책이 많이 있습니다.  이 중에서 제가
추천할만한 책이 두 개 있습니다:

	Steve Oualline의 "Vim - Vi Improved"

이 책은 Vim만을 다룬 최초의 책입니다.  초보자에게 아주 좋습니다.  가장 많이
사용하는 명령들을 그림과 예제를 곁들여 설명하고 있습니다.  덜 자주 사용하는
명령들도 역시 설명하고 있고, 더 고급인 명령들을 요약해두었습니다.  전체에 대한
색인과 빠르게 찾아볼 수 있는 요약표도 있습니다.  이 책의 일부는 사용설명서에
포함되어있기도 합니다 |<a href="usr_01.html#frombook">frombook</a>|.
New Riders Publishing에서 나왔습니다. ISBN: 0735710015.
더 자세한 정보는 다음 링크를 참고하세요:
	http://iccf-holland.org/click5.html
	http://www.vim.org/iccf/click5.html

	Linda Lamb과 Arnold Robbins의 "Learning the Vi editor"

Vi에 관한 책이지만, Vim에 관한 장이 있습니다(6판).  처음 Vi를 배우는 부분이
아주 잘 설명되어 있습니다.  Vim에서 추가된 명령은 간단하게만 언급하고
있습니다.  독일어판 번역본도 있습니다.
O'Reilly에서 나왔습니다.  ISBN: 1-56592-426-6.

</pre><hr><pre>2. 인터넷 상의 Vim						<b class="vimtag">*<a name="internet">internet</a>*</b>

			<b class="vimtag">*<a name="www">www</a>*</b> <b class="vimtag">*<a name="WWW">WWW</a>*</b>  <b class="vimtag">*<a name="faq">faq</a>*</b> <b class="vimtag">*<a name="FAQ">FAQ</a>*</b> <b class="vimtag">*<a name="distribution">distribution</a>*</b> <b class="vimtag">*<a name="download">download</a>*</b>
Vim 홈페이지에 Vim에 대한 최신 정보가 올라옵니다.  최신 버전의 Vim 링크도
있습니다.  FAQ는 자주 물어보는 질문들 목록입니다.  문제가 있다면 이것부터
읽어보세요.

	VIM 홈페이지:	  http://www.vim.org/
	VIM FAQ:	  http://vimdoc.sf.net/
	다운로드:	  ftp://ftp.vim.org/pub/vim/MIRRORS


Vim에 대한 유즈넷 뉴스 그룹:				<b class="vimtag">*<a name="news">news</a>*</b> <b class="vimtag">*<a name="usenet">usenet</a>*</b>
	comp.editors
이 그룹은 다른 편집기들도 다룹니다.  Vim에 대해 글을 쓸 때 Vim에 관한 것이라고
꼭 언급하세요.

						<b class="vimtag">*<a name="mail-list">mail-list</a>*</b> <b class="vimtag">*<a name="maillist">maillist</a>*</b>
Vim에 대한 몇 가지 메일링 리스트가 있습니다:
<code class="special">&lt;vim@vim.org&gt;</code>
	Vim의 발표된 버전들에 대한 논의를 위한 리스트.  유용한 매핑, 질문,
	답변, 특정 버전을 어디서 얻을 수 있는지 등.  리스트를 보면서 질문에
	대답을 해주는 몇몇 사람들이 있습니다.  초보자를 위해서도요.  여기에
	질문하세요.
<code class="special">&lt;vim-dev@vim.org&gt;</code>				<b class="vimtag">*<a name="vim-dev">vim-dev</a>*</b> <b class="vimtag">*<a name="vimdev">vimdev</a>*</b>
	Vim을 바꾸는 것에 대한 논의를 위한 리스트.  새로운 기능, 이식, 패치,
	베타 테스트 등.
<code class="special">&lt;vim-announce@vim.org&gt;</code>				<b class="vimtag">*<a name="vim-announce">vim-announce</a>*</b>
	Vim의 새 버전 및 베타 테스트 버전과 새로운 시스템으로의 이식 등에 대한
	공지.  읽기만 할 수 있습니다.
<code class="special">&lt;vim-multibyte@vim.org&gt;</code>				<b class="vimtag">*<a name="vim-multibyte">vim-multibyte</a>*</b>
	Vim의 멀티바이트 관련 기능의 사용 및 개선에 대한 논의를 위한 리스트.
<code class="special">&lt;vim-mac@vim.org&gt;</code>				<b class="vimtag">*<a name="vim-mac">vim-mac</a>*</b>
	Vim 맥 버전의 사용 및 개선에 대한 논의를 위한 리스트.

최신 정보는 http://www.vim.org/maillist.php 를 참고하세요.

<code class="note">NOTE:</code>
- 이 메일링 리스트를 구독했을 때만 메시지를 보낼 수 있습니다!
- 또한 구독을 한 곳과 동일한 곳에서만 메시지를 보낼 수 있습니다 (스팸 메일을
  피하기 위함입니다).
- 메시지의 최대 크기는 40000 글자입니다.

						<b class="vimtag">*<a name="subscribe-maillist">subscribe-maillist</a>*</b>
구독하고 싶다면 아래 주소로 메일을 보내세요.
	<code class="special">&lt;vim-subscribe@vim.org&gt;</code>
보내는 사람의 주소("From:")가 정확한지 확인하세요.  그러면 메일링 리스트
서버가 어떻게 구독하는지 알려줄겁니다.

						<b class="vimtag">*<a name="maillist-archive">maillist-archive</a>*</b>
더 자세한 정보나 그동안의 리스트 내용을 보려면 Vim 메일링 리스트 페이지를
참고하세요.  http://www.vim.org/maillist.php


버그 신고:				<b class="vimtag">*<a name="bugs">bugs</a>*</b> <b class="vimtag">*<a name="bug-reports">bug-reports</a>*</b> <b class="vimtag">*<a name="bugreport.vim">bugreport.vim</a>*</b>

버그 신고는 다음 이메일 주소로 해주세요: Vim Developers <code class="special">&lt;vim_dev@vim.org&gt;</code>
이 주소는 메일링 리스트여서 많은 사람들이 메시지를 볼 수 있습니다.  보안 등의
문제로 이를 원하지 않으신다면, <code class="special">&lt;bugs@vim.org&gt;</code>로 보내주세요.  이 메일은 Vim
관리자(Bram입니다)에게만 갑니다.
부디 간단하게 써주세요.  답변하는데 쓰이는 시간만큼 Vim을 개선하는데 쓸 시간이
줄어듭니다!  언제나 재현 가능한 예시를 알려주시고, 어떤 설정이나 다른 부분이
버그를 일으키는지 찾아내려고 해봐주세요.  가능하다면 다른 환경에서도
시도해보세요.  할 수 있다면 패치를 보내주세요!

사용하는 Vim 버전이나 설정에 대한 정보를 포함시키면 도움이 됩니다.  다음
명령으로 이런 정보들을 얻을 수 있습니다:
<code class="example">   :so $VIMRUNTIME/bugreport.vim</code>
이 명령은 현재 디렉터리에 "bugreport.txt"라는 파일을 만들고, 작업 환경에 대한
많은 정보를 저장합니다.  파일을 보내기 전에 그 안에 비밀인 정보가 있지는
않은지 확인해보세요!

만약 Vim이 죽는다면, 어디에서 죽는지 찾아보세요.  찾을 때 도움이 될만한 정보가
|<code class="badlink">debug</code>|에 있습니다.

만약 문제가 이미 고쳐진 것일 것 같은데 고치는 패치를 찾지 못하겠는 경우라면,
vim-dev 메일링 리스트에 가입해서 질문을 해보세요.  |<a href="intro.html#maillist">maillist</a>|

							<b class="vimtag">*<a name="year-2000">year-2000</a>*</b> <b class="vimtag">*<a name="Y2K">Y2K</a>*</b>
Vim 내부적으로 편집 시에는 날짜를 사용하지 않기 때문에 Y2K 문제는 걱정하지
않아도 됩니다.  Vim은 1970년 1월 1일 이후로 지난 초의 수 형태로 시간을
사용합니다.  이 시간 정보는 편집한 파일과 스왑 파일의 고친 시각을 비교하기
위해 사용하며, 매우 중요한 것은 아니고 그저 경고 메시지를 보여주는 정도일
겁니다.

어쩌면 2038년에 문제가 생길 수 있습니다.  초의 수가 32비트 int안에 들어가지
않게 되는 때이지요.  이 문제는 컴파일러와 라이브러리, 운영 체제에 따라
다릅니다.  구체적으로, time_t와 ctime() 함수를 사용하고 있는데요.  time_t는
스왑 파일에 4 바이트 크기로 저장됩니다.  하지만 이것은 복구 시 날짜와 시간을
보여주기 위한 것 뿐이므로, 일반적인 편집에는 영향이 없을 것입니다.

Vim의 strftime() 함수는 시스템 함수 strftime() 함수를 바로 사용합니다.
localtime() 함수는 시스템 함수 time()을 사용합니다.  getftime()은 시스템 함수
stat()이 반환하는 값을 사용합니다.  사용하는 시스템의 라이브러리에 Y2K 문제가
없다면, Vim도 문제 없습니다.

어쩌면 다른 사용자가 외부 명령을 사용하는 Vim 스크립트를 만들었을 수도
있습니다.  이런 경우 Y2K 문제가 생길 수도 있지만, Vim 자체의 문제는 아닙니다.

</pre><hr><pre>3. 공헌하신 분				<b class="vimtag">*<a name="credits">credits</a>*</b> <b class="vimtag">*<a name="author">author</a>*</b> <b class="vimtag">*<a name="Bram">Bram</a>*</b> <b class="vimtag">*<a name="Moolenaar">Moolenaar</a>*</b>

Vim은 대부분 Bram Moolenaar <code class="special">&lt;Bram@vim.org&gt;</code>가 만들었습니다.

문서의 일부는 몇 가지 Vi 설명서에서 가져왔습니다.  이를 작성한 사람은:
	W.N. Joy
	Alan P.W. Hewett
	Mark Horton

Vim 편집기는 Stevie에 기반하고 있고, 다른 소프트웨어들로부터 (아이디어를
포함하여) 가져온 부분들이 있습니다.  이들을 작업한 사람들을 여기에
언급하였습니다.  다른 사람들도 패치를 보내거나, 제안을 하거나, 무엇이 Vim에게
좋거나 혹은 나쁜지 검토를 해주었습니다.

이런 분들의 도움이 없었다면, Vim은 결코 지금의 Vim이 될 수 없었을 것입니다!

	Ron Aaron		Win32 GUI 변경
	Mohsin Ahmed		암호화
	Zoltan Arpadffy		VMS 이식 작업
	Tony Andrews		Stevie
	Gert van Antwerpen	마이크로소프트 도스에서의 DJGPP 대응
	Berkeley DB(3)		스왑 파일 구현에 대한 아이디어
	Keith Bostic		Nvi
	Walter Briscoe		Makefile 변경 및 다양한 패치
	Ralf Brown		마이크로소프트 도스를 위한 SPAWNO 라이브러리
	Robert Colon		많은 유용한 언급
	Marcin Dalecki		GTK+ GUI 이식, 도구막대 아이콘, gettext()
	Kayhan Demirel		우간다 소식을 전해줌
	Chris &amp; John Downey	xvi (다중 창 버전에 대한 아이디어)
	Henk Elbers		최초의 VMS 이식
	Daniel Elstner		GTK+ 2 이식
	Eric Fischer		Mac 이식, 'cindent', 기타 다른 개선들
	Benji Fisher		많은 사용자 질문에 대답
	Bill Foster		Athena GUI 이식
	Google			일주일에 하루씩 Vim 일을 할 수 있게 해 줌
	Loic Grenie		xvim (다중 창 버전에 대한 아이디어)
	Sven Guckes		Vim 옹호자 및 전 웹 페이지 관리자
	Darren Hiebert		Exuberant ctags
	Jason Hildebrand	GTK+ 2 이식
	Bruce Hunsaker		VMS 이식 판 개선
	Andy Kahn		Cscope 지원, GTK+ GUI 이식
	Oezguer Kesim		Vim 메일링 리스트 관리자
	Axel Kielhorn		매킨토시 이식 작업
	Steve Kirkendall	Elvis
	Roger Knobbe		원조 윈도 NT 이식
	Sergey Laskavy		모스크바의 Vim 도움말
	Felix von Leitner	전 Vim 메일링 리스트 관리자
	David Leonard		Python 확장의 유닉스 이식
	Avner Lottem		오른쪽에서 왼쪽으로 쓰기 편집
	Flemming Madsen		X11 클라이언트-서버, 다양한 기능과 패치
	Tony Mechelynck		많은 사용자 질문에 응답
	Paul Moore		Python 인터페이스 확장, 많은 패치
	Katsuhito Nagano	멀티바이트 버전 작업
	남성현			멀티바이트 버전 작업
	Vince Negri		Win32 GUI과 일반 콘솔 개선
	Steve Oualline		최초의 Vim 책 |<a href="usr_01.html#frombook">frombook</a>| 저자
	Dominique Pelle		valgrind 결과 및 많은 패치
	A.Politz		많은 버그 보고 및 몇몇 패치
	George V. Reilly	Win32 이식, Win32 GUI 시작
	Stephen Riehm		버그 수집가
	Stefan Roemer		다양한 패치와 사용자 도움
	Ralf Schandl		IBM OS/390 이식
	Olaf Seibert		DICE와 BeBox 버전, 정규표현식 개선
	Mortaza Shiran		Farsi 패치
	Peter da Silva		termlib
	Paul Slootman		OS/2 이식
	Henry Spencer		정규 표현식
	Dany St-Amant		매킨토시 이식
	Tim Thompson		Stevie
	G. R. (Fred) Walter	Stevie
	Sven Verdoolaege	Perl 인터페이스
	Robert Webb		명령줄 자동 완성, GUI 버전 및 많은 패치
	Ingo Wilken		Tcl 인터페이스
	Mike Williams		PostScript 프린트
	Juergen Weigert		Lattice 버전, AUX 개선, 유닉스 및
				마이크로소프트 도스 이식, autoconf
	Stefan 'Sec' Zehl	vim.org 관리자

저에게 버그 리포트와 제안을 보내준 모든 사람에게 감사하고 싶습니다.  여기에
언급하기에는 너무 깁니다.  이 모든 사람들의 아이디어가 없었다면 Vim은 지금과
같지 않았을 겁니다.  그들이 Vim을 살아있게 합니다!
<b class="vimtag">*<a name="love">love</a>*</b> <b class="vimtag">*<a name="peace">peace</a>*</b> <b class="vimtag">*<a name="friendship">friendship</a>*</b> <b class="vimtag">*<a name="gross-national-happiness">gross-national-happiness</a>*</b>


이 문서에는 몇 가지 다른 버전의 Vi에 대한 참조가 있습니다:
							<b class="vimtag">*<a name="Vi">Vi</a>*</b> <b class="vimtag">*<a name="vi">vi</a>*</b>
Vi	"원조".  따로 언급하지 않는다면, Sun OS 4.x에서 나타난 Vi 버전을
	말합니다.  ":version"이 "Version 3.7, 6/7/85"를 반환합니다.  때로는
	다른 버전을 언급할 때도 있습니다.  오직 유닉스에서만 동작합니다.  소스
	코드는 라이선스 해야 얻을 수 있습니다.  Vi에 대한 더 많은 정보는
	아래에서 찾을 수 있습니다.
		http://vi-editor.org	[지금은 없어짐...]
							<b class="vimtag">*<a name="Posix">Posix</a>*</b>
Posix	"IEEE standard 1003.2, Part 2: Shell and utilities"의 일부입니다.
	일반적으로 "Posix"라고 알려져있습니다.  Vi가 어떻게 동작해야하는지에
	대해 글로 설명한 것입니다.  |<code class="badlink">posix-compliance</code>|를 참고하세요.
							<b class="vimtag">*<a name="Nvi">Nvi</a>*</b>
Nvi	"New"(새로운) Vi.  BSD 4.4와 FreeBSD에 포함된 Vi 버전입니다.  원조
	Vi와 매우 좋은 호환성을 갖추고 있고, 몇 가지 확장도 있습니다.  사용한
	버전은 1.79로, ":version"은 "Version 1.79 (10/23/96)"를 반환합니다.
	지난 몇 년간 새로운 버전이 없었지만, 개발 중인 1.81버전이 존재합니다.
	소스 코드는 무료로 얻을 수 있습니다.
							<b class="vimtag">*<a name="Elvis">Elvis</a>*</b>
Elvis	또 다른 Vi 복제품입니다.  Steve Kirkendall이 만들었습니다.  매우
	작지만, Vim같이 유연하지 못합니다.
	사용한 버전은 2.1입니다.  여전히 개발되고 있으며, 소스 코드는 무료로
	얻을 수 있습니다.

</pre><hr><pre>4. 표기법							<b class="vimtag">*<a name="notation">notation</a>*</b>

문서를 읽을 때 문법 강조가 켜져있다면, 화면에 보이는 그대로 입력하지 않는
문자들은 종종 특별한 형태로 강조되어있을 겁니다.  []나 <code class="special">{}</code>, <code class="special">&lt;&gt;</code>에 들어있는
항목들이나 <code class="keystroke">CTRL-X</code> 같은 것이지요.

Vim 명령에는 가능한 모든 문자가 쓰인다는데 주의하세요.  가끔은 []나 <code class="special">{}</code>, <code class="special">&lt;&gt;</code>
자체가 입력해야하는 명령의 일부인 경우도 있습니다.  이런 경우는 그때그때
명확하게 설명하겠습니다.


[]		대괄호안의 문자는 생략할 수 있는 것입니다.

						    <b class="vimtag">*<a name="count">count</a>*</b> <b class="vimtag">*<a name="[count]">[count]</a>*</b>
<code class="special">[count]</code>		명령 앞에 숫자를 추가로 붙여서 명령의 효과를 곱하거나 반복할
		수 있습니다.  아무 숫자가 주어지지 않으면, 따로 언급하지
		않았으면 숫자 1이 사용됩니다.  이 설명서에서는 명령의 정의에
		<code class="special">[count]</code>를 일일이 명시하지 않는다는 데 주의하세요.  명령의 설명
		부분에서만 다룹니다.  명령을 조금 더 찾아보기 쉽게 하려다 보니
		그렇습니다.  만약 'showcmd' 옵션이 켜져있으면, (부분적으로)
		입력된 숫자가 창의 맨 밑에 보입니다.  <code class="special">&lt;Del&gt;</code> 키로 마지막 숫자를
		지울 수 있습니다 (|<code class="badlink">N&lt;Del&gt;</code>|).

							<b class="vimtag">*<a name="[quotex]">[quotex]</a>*</b>
["x]		내용을 저장할 때 특별히 저장할 레지스터를 지정합니다.
		|<code class="badlink">registers</code>|를 참고하세요.  x에는 'a'에서 'z' 또는 "A"에서 Z"
		혹은 '"'이 들어갑니다.  몇몇 경우(넣기 명령을 사용할 때
		등)에는 '0'에서 '9' 사이, '%', '#' 등도 들어갈 수 있습니다.
		대문자와 소문자는 동일한 레지스터를 가리킵니다.  다만 소문자를
		사용하면 기존 내용을 덮어쓰는 반면, 대문자를 사용하면 기존
		내용 뒤에 덧붙입니다.  ""x" 나 """" 없이 저장하면 내용이
		이름 없는 레지스터에 들어갑니다.

							<b class="vimtag">*<a name="{}">{}</a>*</b>
<code class="special">{}</code>		중괄호는 명령에 꼭 필요하지만 몇 가지 다른 값을 가질 수 있는
		부분을 나타냅니다.  Vim과 Vi의 차이점도 중괄호로 표시하여
		나타내는데, 이런 경우에는 앞서의 용도와 헷갈리지 않도록
		명확하게 설명하겠습니다.

							<b class="vimtag">*<a name="{char1-char2}">{char1-char2}</a>*</b>
<code class="special">{char1-char2}</code>	char1 문자에서 char2 문자 범위 안의 문자 하나.  예를 들어
		<code class="special">{a-z}</code>는 소문자 하나를 나타냅니다.  여러 범위를 연달아 나열할
		수도 있습니다.  예를 들어, <code class="special">{a-zA-Z0-9}</code>는 모든 숫자나 알파벳
		문자 중 하나를 나타냅니다.

						<b class="vimtag">*<a name="{motion}">{motion}</a>*</b> <b class="vimtag">*<a name="movement">movement</a>*</b>
<code class="special">{motion}</code>	커서를 움직이는 명령.  |<code class="badlink">motion</code>|에서 설명하고 있습니다.
		예:
			w		다음 어절의 시작으로
			b		현재 어절의 시작으로
			4j		내 줄 아래로
			/The<code class="special">&lt;CR&gt;</code>	"The"가 나타나는 다음 위치로
		이 명령이 오퍼레이터(|<code class="badlink">operator</code>|) 명령 뒤에 쓰이면, 움직임
		명령이 지나가는 부분의 내용에 대해 오퍼레이터가 적용됩니다.
		- 만약 움직임에도 숫자가 붙어있고, 오퍼레이터에도 숫자가
		  붙어있으면, 두 숫자를 곱한 값이 사용됩니다.  예: "2d3w"는
		  여섯 어절을 지웁니다.
		- 움직임은 뒤로도 갈 수 있습니다.  예를 들어 "db"는 어절의
		  시작 위치까지를 지웁니다.
		- 움직임은 마우스 클릭일 수도 있습니다.  마우스가 모든
		  터미널에서 지원되는 것은 아니지만요.
		- 오퍼레이터만 입력된 상태에 사용할 명령은 ":omap" 명령으로
		  매핑을 만들 수 있습니다.
		- Ex 명령으로 커서를 움직일 수 있습니다.  복잡한 움직임을 하는
		  함수를 만들 때 쓸 수 있겠지요.  어떤 ":" 명령이 사용되었든지
		  이 움직임은 문자 불포함(exclusive)입니다.  이 말은 줄바꿈이
		  없는 줄의 마지막 문자를 절대 포함시킬 수 없다는 것입니다
		  ('virtualedit' 옵션이 켜져있지 않다면요).
		  만약 오퍼레이터가 동작하거나 다른 버퍼로 이동하기 전에 Ex
		  명령이 내용을 변경한다면 그 결과는 알 수 없습니다.  내용을
		  더 바꿀 수도 있고, 만약 현재 버퍼가 내려가지 않았다면 다른
		  버퍼로 이동할 수도 있습니다.

							<b class="vimtag">*<a name="{Visual}">{Visual}</a>*</b>
<code class="special">{Visual}</code>	선택한 내용 영역.  "v"나 "V", <code class="keystroke">CTRL-V</code> 명령으로 시작하고 나면,
		선택 영역이 끝나는 부분을 모든 커서 움직임 명령을 써서 움직일
		수 있습니다.  오퍼레이터(|<code class="badlink">operator</code>|)명령 앞에 써서
		오퍼레이터를 적용할 내용 부분을 알아보기 쉽게 만들 수
		있습니다.  |<code class="badlink">Visual-mode</code>|(시각 모드)를 참고하세요.

							<b class="vimtag">*<a name="%3Ccharacter%3E">&lt;character&gt;</a>*</b>
<code class="special">&lt;character&gt;</code>	아래 표의 특수 문자.  특수 문자를 조합 키와 함께 사용한 것일
		수도 있고, 조합 키와 아스키 문자 하나의 조합일 수도 있습니다.

							<b class="vimtag">*<a name="'character'">'character'</a>*</b>
'c'		아스키 문자 하나.

							<b class="vimtag">*<a name="CTRL-{char}">CTRL-{char}</a>*</b>
CTRL-<code class="special">{char}</code>	컨트롤 조합으로 입력한 <code class="special">{char}</code>.  컨트롤(CTRL) 키를 누르고 있는
		상태에서 <code class="special">{char}</code>를 입력한 것을 말합니다.  <code class="special">{char}</code>가 대문자인지
		소문자인지는 상관 없습니다.  <code class="keystroke">CTRL-A</code>와 <code class="keystroke">CTRL-a</code>는 동일하니까요.
		몇몇 터미널에서는 시프트(SHIFT) 키를 함께 쓰면 다른 입력이 될
		때가 있습니다.  이렇게 쓰지는 마세요.

							<b class="vimtag">*<a name="'option'">'option'</a>*</b>
'option'	옵션 혹은 파라미터는 작은따옴표로 표시합니다.  어떤 값으로
지정할 수 있습니다.  |<code class="badlink">options</code>|를 보세요.

							<b class="vimtag">*<a name="quotecommandquote">quotecommandquote</a>*</b>
"command"	입력할 수 있는 명령은 큰따옴표 안에 표시합니다.
`command`	다른 내용이나 문자열의 인용과 구분해야하는 경우 이렇게 명령을
		표시합니다.

					<b class="vimtag">*<a name="key-notation">key-notation</a>*</b> <b class="vimtag">*<a name="key-codes">key-codes</a>*</b> <b class="vimtag">*<a name="keycodes">keycodes</a>*</b>
이 문서에서 사용한 키들의 이름입니다.  ":map" 명령에도 쓸 수 있습니다
(<code class="keystroke">CTRL-K</code>를 누르고, 이름을 넣을 키를 눌러서 키 이름을 입력하세요).

<code class="section">표기		의미		    동일한 키	십진수 값(들)	</code>
-----------------------------------------------------------------------
<code class="special">&lt;Nul&gt;</code>		0			CTRL-@	  0 (10으로 저장) <b class="vimtag">*<a name="%3CNul%3E">&lt;Nul&gt;</a>*</b>
<code class="special">&lt;BS&gt;</code>		백스페이스		<code class="keystroke">CTRL-H</code>	  8	<b class="vimtag">*<a name="backspace">backspace</a>*</b>
<code class="special">&lt;Tab&gt;</code>		탭			<code class="keystroke">CTRL-I</code>	  9	<b class="vimtag">*<a name="tab">tab</a>*</b> <b class="vimtag">*<a name="Tab">Tab</a>*</b>
							<b class="vimtag">*<a name="linefeed">linefeed</a>*</b>
<code class="special">&lt;NL&gt;</code>		라인피드		<code class="keystroke">CTRL-J</code>	 10 (used for <code class="special">&lt;Nul&gt;</code>)
<code class="special">&lt;FF&gt;</code>		폼피드			<code class="keystroke">CTRL-L</code>	 12	<b class="vimtag">*<a name="formfeed">formfeed</a>*</b>
<code class="special">&lt;CR&gt;</code>		캐리지 리턴		<code class="keystroke">CTRL-M</code>	 13	<b class="vimtag">*<a name="carriage-return">carriage-return</a>*</b>
<code class="special">&lt;Return&gt;</code>	<code class="special">&lt;CR&gt;</code>과 동일				<b class="vimtag">*<a name="%3CReturn%3E">&lt;Return&gt;</a>*</b>
<code class="special">&lt;Enter&gt;</code>		<code class="special">&lt;CR&gt;</code>과 동일				<b class="vimtag">*<a name="%3CEnter%3E">&lt;Enter&gt;</a>*</b>
<code class="special">&lt;Esc&gt;</code>		ESC			CTRL-[	 27	<b class="vimtag">*<a name="escape">escape</a>*</b> <b class="vimtag">*<a name="%3CEsc%3E">&lt;Esc&gt;</a>*</b>
<code class="special">&lt;Space&gt;</code>		공백				 32	<b class="vimtag">*<a name="space">space</a>*</b>
<code class="special">&lt;lt&gt;</code>		작다 부등호		&lt;	 60	<b class="vimtag">*<a name="%3Clt%3E">&lt;lt&gt;</a>*</b>
<code class="special">&lt;Bslash&gt;</code>	백슬래시		\	 92	<b class="vimtag">*<a name="backslash">backslash</a>*</b> <b class="vimtag">*<a name="%3CBslash%3E">&lt;Bslash&gt;</a>*</b>
<code class="special">&lt;Bar&gt;</code>		세로 줄			|	124	<b class="vimtag">*<a name="%3CBar%3E">&lt;Bar&gt;</a>*</b>
<code class="special">&lt;Del&gt;</code>		Delete				127
<code class="special">&lt;CSI&gt;</code>		명령 조합 접두		ALT-Esc 155	<b class="vimtag">*<a name="%3CCSI%3E">&lt;CSI&gt;</a>*</b>
<code class="special">&lt;xCSI&gt;</code>		GUI에서 입력한 CSI			<b class="vimtag">*<a name="%3CxCSI%3E">&lt;xCSI&gt;</a>*</b>

<code class="special">&lt;EOL&gt;</code>		줄의 끝 (<code class="special">&lt;CR&gt;</code>일 수도, <code class="special">&lt;LF&gt;</code>일 수도, <code class="special">&lt;CR&gt;</code><code class="special">&lt;LF&gt;</code>일 수도 있음.
		시스템과 'fileformat'에 따라 다름)	<b class="vimtag">*<a name="%3CEOL%3E">&lt;EOL&gt;</a>*</b>

<code class="special">&lt;Up&gt;</code>		위쪽 화살표 키			<b class="vimtag">*<a name="cursor-up">cursor-up</a>*</b> <b class="vimtag">*<a name="cursor_up">cursor_up</a>*</b>
<code class="special">&lt;Down&gt;</code>		아래쪽 화살표 키		<b class="vimtag">*<a name="cursor-down">cursor-down</a>*</b> <b class="vimtag">*<a name="cursor_down">cursor_down</a>*</b>
<code class="special">&lt;Left&gt;</code>		왼쪽 화살표 키			<b class="vimtag">*<a name="cursor-left">cursor-left</a>*</b> <b class="vimtag">*<a name="cursor_left">cursor_left</a>*</b>
<code class="special">&lt;Right&gt;</code>		오른쪽 화살표 키			<b class="vimtag">*<a name="cursor-right">cursor-right</a>*</b> <b class="vimtag">*<a name="cursor_right">cursor_right</a>*</b>
<code class="special">&lt;S-Up&gt;</code>		시프트 위쪽 화살표 키
<code class="special">&lt;S-Down&gt;</code>	시프트 아래쪽 화살표 키
<code class="special">&lt;S-Left&gt;</code>	시프트 왼쪽 화살표 키
<code class="special">&lt;S-Right&gt;</code>	시프트 오른쪽 화살표 키
<code class="special">&lt;C-Left&gt;</code>	컨트롤 왼쪽 화살표 키
<code class="special">&lt;C-Right&gt;</code>	컨트롤 오른쪽 화살표 키
<code class="special">&lt;F1&gt;</code> - <code class="special">&lt;F12&gt;</code>	기능 키 1에서 12		<b class="vimtag">*<a name="function_key">function_key</a>*</b> <b class="vimtag">*<a name="function-key">function-key</a>*</b>
<code class="special">&lt;S-F1&gt;</code> - <code class="special">&lt;S-F12&gt;</code> 시프트 기능 키 1에서 12	<b class="vimtag">*<a name="%3CS-F1%3E">&lt;S-F1&gt;</a>*</b>
<code class="special">&lt;Help&gt;</code>		도움말 키
<code class="special">&lt;Undo&gt;</code>		실행 취소 키
<code class="special">&lt;Insert&gt;</code>	삽입 키
<code class="special">&lt;Home&gt;</code>		Home				<b class="vimtag">*<a name="home">home</a>*</b>
<code class="special">&lt;End&gt;</code>		End				<b class="vimtag">*<a name="end">end</a>*</b>
<code class="special">&lt;PageUp&gt;</code>	Page Up				<b class="vimtag">*<a name="page_up">page_up</a>*</b> <b class="vimtag">*<a name="page-up">page-up</a>*</b>
<code class="special">&lt;PageDown&gt;</code>	Page Down			<b class="vimtag">*<a name="page_down">page_down</a>*</b> <b class="vimtag">*<a name="page-down">page-down</a>*</b>
<code class="special">&lt;kHome&gt;</code>		키패드 Home (왼쪽 위)		<b class="vimtag">*<a name="keypad-home">keypad-home</a>*</b>
<code class="special">&lt;kEnd&gt;</code>		키패드 End (왼쪽 아래)		<b class="vimtag">*<a name="keypad-end">keypad-end</a>*</b>
<code class="special">&lt;kPageUp&gt;</code>	키패드 Page Up (오른쪽 위)	<b class="vimtag">*<a name="keypad-page-up">keypad-page-up</a>*</b>
<code class="special">&lt;kPageDown&gt;</code>	키패드 Page Down (오른쪽 아래)	<b class="vimtag">*<a name="keypad-page-down">keypad-page-down</a>*</b>
<code class="special">&lt;kPlus&gt;</code>		키패드 +			<b class="vimtag">*<a name="keypad-plus">keypad-plus</a>*</b>
<code class="special">&lt;kMinus&gt;</code>	키패드 -			<b class="vimtag">*<a name="keypad-minus">keypad-minus</a>*</b>
<code class="special">&lt;kMultiply&gt;</code>	키패드 <b class="vimtag">*<a name="			">			</a>*</b>keypad-multiply*
<code class="special">&lt;kDivide&gt;</code>	키패드 /			<b class="vimtag">*<a name="keypad-divide">keypad-divide</a>*</b>
<code class="special">&lt;kEnter&gt;</code>	키패드 Enter			<b class="vimtag">*<a name="keypad-enter">keypad-enter</a>*</b>
<code class="special">&lt;kPoint&gt;</code>	키패드 소수점			<b class="vimtag">*<a name="keypad-point">keypad-point</a>*</b>
<code class="special">&lt;k0&gt;</code> - <code class="special">&lt;k9&gt;</code>	키패드 0에서 9			<b class="vimtag">*<a name="keypad-0">keypad-0</a>*</b> <b class="vimtag">*<a name="keypad-9">keypad-9</a>*</b>
<code class="special">&lt;S-...&gt;</code>		시프트 키			<b class="vimtag">*<a name="shift">shift</a>*</b> <b class="vimtag">*<a name="%3CS-">&lt;S-</a>*</b>
<code class="special">&lt;C-...&gt;</code>		컨트롤 키			<b class="vimtag">*<a name="control">control</a>*</b> <b class="vimtag">*<a name="ctrl">ctrl</a>*</b> <b class="vimtag">*<a name="%3CC-">&lt;C-</a>*</b>
<code class="special">&lt;M-...&gt;</code>		알트 키 혹은 메타 키		<b class="vimtag">*<a name="meta">meta</a>*</b> <b class="vimtag">*<a name="alt">alt</a>*</b> <b class="vimtag">*<a name="%3CM-">&lt;M-</a>*</b>
<code class="special">&lt;A-...&gt;</code>		<code class="special">&lt;M-...&gt;</code>와 동일			<b class="vimtag">*<a name="%3CA-">&lt;A-</a>*</b>
<code class="special">&lt;D-...&gt;</code>		커맨드 키 (맥 전용)		<b class="vimtag">*<a name="%3CD-">&lt;D-</a>*</b>
<code class="special">&lt;t_xx&gt;</code>		텀캡에서 "xx" 항목의 키
-----------------------------------------------------------------------

<code class="note">Note:</code> 시프트 키와 화살표 키 조합, 도움말 키, 실행 취소 키는 몇몇 터미널에서만
쓸 수 있습니다.  Amiga에서는 시프트 키와 기능 키 10의 조합이 다른 키
입력에서도 쓰이는 코드(CSI)를 만들어냅니다.  이 때는 다른 키를 입력하면 그
때야 처리될 겁니다.

<code class="note">Note:</code> Delete 키에는 두 개의 코드가 있습니다.  127은 Delete 키의 10진수 아스키
값으로 언제나 동작합니다.  몇몇 Delete 키는 다른 값을 보내는데, 이 값은 텀캡의
"kD" 항목으로 얻을 수 있습니다.  두 값 모두 동작은 같습니다.  |<code class="badlink">:fixdel</code>|을
참고하세요.

<code class="note">Note:</code> 키패드의 키는 해당하는 "일반" 키와 동일한 동작을 합니다.  예를 들어,
<code class="special">&lt;kHome&gt;</code>은 <code class="special">&lt;Home&gt;</code>과 동일한 동작을 합니다.  키패드 키가 일반 키와 동일한 키
코드를 보낸다면, 일반 키로 인식될 수도 있습니다.  예를 들어, <code class="special">&lt;kHome&gt;</code>이
<code class="special">&lt;Home&gt;</code>과 동일한 코드를 보낸다면, <code class="special">&lt;kHome&gt;</code>을 누를 때에도 Vim은 <code class="special">&lt;Home&gt;</code>이 눌렸다고
생각할 수 있습니다.  이때는 <code class="special">&lt;kHome&gt;</code>을 매핑해봐야 동작하지 않겠지요.

								<b class="vimtag">*<a name="%3C%3E">&lt;&gt;</a>*</b>
예제들을 <code class="special">&lt;&gt;</code> 표기법으로 표시할 때가 많습니다.  무엇을 입력해야하는지 알기
쉽게하려는 경우도 있지만, 종종 그 문자 그대로 입력해도 되는 경우도 있습니다.
예를 들어 ":map" 명령 같은 경우에요.  규칙은 다음과 같습니다.
 1.  백슬래시와 '&lt;'를 제외한 모든 출력 가능한 문자는 그대로 입력합니다.
 2.  백슬래시는 "\\"와 같이 백슬래시 두 개나 "<code class="special">&lt;Bslash&gt;</code>"로 표현합니다.
 3.  진짜 '<code class="special">&lt;'는 "\&lt;"나 "&lt;lt&gt;</code>"로 표현합니다.  혼동이 없을만한 곳에서는 '&lt;'를
     그냥 사용하기도 했습니다.
 4.  "<code class="special">&lt;key&gt;</code>"는 특수 키를 입력하는 것입니다.  위 표에서 설명한 표기법이지요.
     몇 가지 예를 보겠습니다.
	   <code class="special">&lt;Esc&gt;</code>		ESC 키
	   <code class="special">&lt;C-G&gt;</code>		<code class="keystroke">CTRL-G</code>
	   <code class="special">&lt;Up&gt;</code>			위쪽 화살표 키
	   <code class="special">&lt;C-LeftMouse&gt;</code>	컨트롤- 왼쪽 마우스 클릭
	   <code class="special">&lt;S-F11&gt;</code>		시프트와 기능 키 11
	   <code class="special">&lt;M-a&gt;</code>		메타- a (8번째 비트가 켜진 'a')
	   <code class="special">&lt;M-A&gt;</code>		메타- A (8번째 비트가 켜진 'A')
	   <code class="special">&lt;t_kd&gt;</code>		텀캡의 "kd" 항목 (아래쪽 화살표 키)

Vim에서 <code class="special">&lt;&gt;</code> 표기 전체를 사용하려면, 'cpoptions'에서 '&lt;' 플래그가 꼭 빠져있어야
합니다 ('compatible'이 켜져있지 않다면, 기본 값으로 빠져 있습니다).
<code class="example">	:set cpo-=&lt;</code>
만약 <code class="special">&lt;&gt;</code> 표기법 에서의 키 이름 효과를 없애고 싶을 때는 <code class="special">&lt;lt&gt;</code>를 사용하면 됩니다.
백슬래시를 써도 되는데, 그러려면 'cpoptions'에서 'B' 플래그가
빠져있어야합니다.

예를 들어 <code class="keystroke">CTRL-H</code>를 "<code class="special">&lt;Home&gt;</code>" 여섯 글자로 매핑하고 싶다고 합시다:
<code class="example">	:imap <code class="special">&lt;C-H&gt;</code> \<code class="special">&lt;Home&gt;</code></code>
<code class="example">	:imap <code class="special">&lt;C-H&gt;</code> <code class="special">&lt;lt&gt;</code>Home&gt;</code>
첫 번째 예는 'cpoptions'에 'B' 플래그가 없을 때만 동작합니다.  두 번째 예는
언제나 동작합니다.
매핑에서 "<code class="special">&lt;lt&gt;</code>"라는 문자열을 얻으려면:
<code class="example">	:map <code class="special">&lt;C-L&gt;</code> <code class="special">&lt;lt&gt;</code>lt&gt;</code>
<code class="example"></code>
매핑과 약어, 메뉴 명령에서는 예제를 복사해다가 붙여넣기 해서 바로 사용할 수
있습니다.  아니면 '<code class="special">&lt;'와 '&gt;</code>' 문자를 포함해서 직접 다 입력할 수도 있고요. 하지만
":set"나 "autocmd" 같은 다른 명령에서는 이렇게 할 수 없습니다!

</pre><hr><pre>5. 모드 소개					<b class="vimtag">*<a name="vim-modes-intro">vim-modes-intro</a>*</b> <b class="vimtag">*<a name="vim-modes">vim-modes</a>*</b>

Vim에는 여섯가지 기본 모드가 있습니다:

					<b class="vimtag">*<a name="Normal">Normal</a>*</b> <b class="vimtag">*<a name="Normal-mode">Normal-mode</a>*</b> <b class="vimtag">*<a name="command-mode">command-mode</a>*</b>
보통 모드		보통 모드에서는 모든 편집기 명령을 입력할 수 있습니다.
(Normal mode)		프로그램을 실행시키면 이 모드로 시작합니다
			('insertmode' 옵션을 켜지 않았다면요.  아래를
			참고하세요).  명령 모드(command mode)로도 알려져
			있습니다.

시각 모드		보통 모드와 같지만, 움직임 명령으로 강조된 영역이
(Visual mode)		바뀝니다.  움직임 명령이 아닌 명령을 사용하면, 강조된
			영역에 대해서 수행됩니다.  |<code class="badlink">Visual-mode</code>|(시각 모드)를
			참고하세요.
			'showmode' 옵션이 켜져있으면, 창의 아래에 "-- 비주얼
			--"이 표시됩니다.

선택 모드		마이크로소프트 윈도의 선택 기능과 유사한 모드입니다.
(Select mode)		출력 가능한 문자를 입력하면 현재 선택된 부분이
			지워지고 입력 모드가 시작됩니다.  |<code class="badlink">Select-mode</code>|(선택
			모드)를 참고하세요.
			'showmode' 옵션이 켜져있으면, 창의 아래에 "-- 고르기
			--"가 표시됩니다.

입력 모드		입력 모드에서는 입력한 내용이 그대로 버퍼에
(Insert mode)		들어갑니다.  |<code class="badlink">Insert-mode</code>|(입력 모드)를 참고하세요.
			'showmode' 옵션이 켜져있으면, 창의 아래에 "-- 끼워넣기
			--"가 표시됩니다.

명령줄 모드		명령줄 모드에서는 창의 맨 아래에 한 줄의 내용을 입력할
(Command-line mode)	수 있습니다.  이 내용은 ":"로 시작하는 Ex 명령일 수도
(Cmdline mode)		있고, "?"나 "/"로 시작하는 패턴 찾기 명령, "!"로
			시작하는 필터 명령일 수도 있습니다.
			|<code class="badlink">Cmdline-mode</code>|(명령줄 모드)

Ex 모드			명령줄 모드와 비슷하지만, 명령을 입력한 후에도 Ex
(Ex mode)		모드에 그대로 남는 점이 다릅니다.  명령 줄의 매우
			제한적인 편집만이 가능합니다.  |<a href="intro.html#Ex-mode">Ex-mode</a>|(Ex 모드)

여기에 여섯 가지 추가 모드가 있습니다.  이들은 기본 모드의 변형입니다:

				<b class="vimtag">*<a name="Operator-pending">Operator-pending</a>*</b> <b class="vimtag">*<a name="Operator-pending-mode">Operator-pending-mode</a>*</b>
오퍼레이터 대기 모드	일반 모드와 비슷하지만, 오퍼레이터 명령이 시작된 후의
(Operator-pending mode)	상태입니다.  <code class="special">{motion}</code> 움직임 명령으로 오퍼레이터를
			적용할 부분을 지정하게 됩니다.

바꾸기 모드		바꾸기 모드는 입력 모드의 특수한 경우입니다.  입력
(Replace mode)		모드와 동일한 일을 할 수 있지만, 문자가 입력됨에 따라
			기존 내용이 한 문자씩 지워집니다.
			|<code class="badlink">Replace-mode</code>|(바꾸기 모드)를 참고하세요.
			'showmode' 옵션이 켜져있으면, 창의 아래에 "-- 바꾸기
			--"가 표시됩니다.

가상 바꾸기 모드	가상 바꾸기 모드는 바꾸기 모드와 비슷합니다.  파일의
(Virtual Replace mode)	문자가 하나씩 지워지는 대신, 화면의 영역 한 칸이
			지워집니다.  즉, 바꾸기 모드에서는 영어 한 글자가
			입력되면 한글 한 글자가 지워지지만, 가상 바꾸기
			모드에서는 영어 두 글자가 입력될 때마다 한글 한
			글자씩이 지워집니다.  한글 한 글자가 두 칸을 차지하기
			때문이지요.
			|<code class="badlink">Virtual-Replace-mode</code>|(가상 바꾸기 모드)를 참고하세요.
			'showmode' 옵션이 켜져있으면, 창의 아래에 "-- 선택치환
			--"이 표시됩니다.

입력 보통 모드		입력 모드에서 <code class="keystroke">CTRL-O</code>를 눌렀을 때의 모드입니다.  일반
(Insert Normal mode)	모드와 동일하지만, 명령 하나를 실행한 후 입력 모드로
			돌아갑니다.
			'showmode' 옵션이 켜져있으면, 창의 아래에 "--
			(끼워넣기) --"가 표시됩니다.

입력 시각 모드		입력 모드에서 시각 모드 선택을 시작했을 때의
(Insert Visual mode)	모드입니다.  예를 들어 <code class="keystroke">CTRL-O</code>를 사용한 뒤, "v"나 "V",
			<code class="keystroke">CTRL-V</code>를 눌렀을 때입니다.  시각 모드 선택이 끝나면,
			입력 모드로 돌아갑니다.
			'showmode' 옵션이 켜져있으면, 창의 아래에 "--
			(끼워넣기) 비주얼 --"이 표시됩니다.

입력 선택 모드		입력 모드에서 선택 모드를 시작했을 때의 모드입니다.
(Insert Select mode)	마우스로 드래그를 하거나 <code class="special">&lt;S-Right&gt;</code>를 눌러서요.
			'showmode' 옵션이 켜져있으면, 창의 아래에 "--
			(끼워넣기) 고르기 --"가 표시됩니다.

</pre><hr><pre>6. 모드 바꾸기						<b class="vimtag">*<a name="mode-switching">mode-switching</a>*</b>

어떤 이유에서는 현재 모드가 무엇인지 모르겠으면, 언제나 <code class="special">&lt;Esc&gt;</code>를 두 번 눌러서
보통 모드로 돌아갈 수 있습니다.  하지만 Ex 모드에서는 이게 안되는데요,
":visual"을 사용하세요.
<code class="special">&lt;Esc&gt;</code>를 눌렀을 때 화면이 깜빡이거나 삐 소리가 들리는 것으로 보통 모드에
돌아왔다는 것을 알 수 있습니다.  하지만 입력 모드에서 <code class="keystroke">CTRL-O</code>를 사용한 후
<code class="special">&lt;Esc&gt;</code>를 누르면 삐 소리가 났지만 여전히 입력 모드에 있게 됩니다.  이때는
<code class="special">&lt;Esc&gt;</code>를 또 눌러주세요.

							<b class="vimtag">*<a name="i_esc">i_esc</a>*</b>
<code class="section">		도착 모드					    </code>
<code class="section">		보통	시각	선택	입력	  바꾸기    명령줄  Ex </code>
<code class="section">시작 모드								 </code>
보통			v V ^V	  <b class="vimtag">*<a name="4	 ">4	 </a>*</b>1	   R gR     : / ? !   Q
시각		 *2		  ^G	 c C	    --	      :       --
선택		 <b class="vimtag">*<a name="5	^O ^G		 ">5	^O ^G		 </a>*</b>6	    --	      --      --
입력		 <code class="special">&lt;Esc&gt;</code>	  --	  --		  <code class="special">&lt;Insert&gt;</code>    --      --
바꾸기		 <code class="special">&lt;Esc&gt;</code>	  --	  --	<code class="special">&lt;Insert&gt;</code>	      --      --
명령줄	 *3	  --	  --	 :start	    --		      --
Ex		 :vi	  --	  --	 --	    --	      --

-- 불가능

*1 보통 모드에서는 다음 명령들로 입력 모드로 갈 수 있습니다.  "i", "I", "a",
   "A", "o", "O", "c", "C", "s", "S".
*2 시각 모드에서는 움직임 명령이 아닌 명령을 사용하면 명령이 실행되면서 일반
   모드로 갑니다.  아니면 <code class="special">&lt;Esc&gt;</code>나 "v", "V", "<code class="keystroke">CTRL-V</code>"(|<code class="badlink">v_v</code>|를 보세요)를 눌러서
   아무 동작도 하지 않은 채 시각 모드를 끝낼 수도 있습니다.
*3 명령줄 모드에서 보통 모드로는 다음과 같이 갑니다:
   - <code class="special">&lt;CR&gt;</code>이나 <code class="special">&lt;NL&gt;</code>을 입력하여 명령을 실행시켜서.
   - 입력한 내용을 모두 지우고(예를 들어 <code class="keystroke">CTRL-U</code>를 써서), <code class="special">&lt;BS&gt;</code>를 한 번 더
     눌러서.
   - <code class="keystroke">CTRL-C</code>나 <code class="special">&lt;Esc&gt;</code>를 눌러서 명령 실행 없이 명령줄을 빠져나가서.
   마지막 경우에서, <code class="special">&lt;Esc&gt;</code>는 'wildchar' 옵션에서 지정한 문자일 수도 있는데요.
   이때는 빠져나가지 않고 명령줄 자동완성이 됩니다.  이를 무시하고 <code class="special">&lt;Esc&gt;</code>를 한
   번 더 눌러서 빠져나갈 수 있습니다.  {Vi: <code class="special">&lt;Esc&gt;</code>를 누르면 명령줄 내용이
   실행됩니다.  대부분의 사람들에게는 당황스러운 결과이지요.  그래서 Vim에서는
   이 동작을 바꾸었습니다.  <code class="special">&lt;Esc&gt;</code>를 눌렀을 때 Vi처럼 동작하게 만들고 싶다면
   ":cmap ^V<code class="special">&lt;Esc&gt;</code> ^V^M" 명령을 사용하세요.}
*4 보통 모드에서 선택 모드로는 다음과 같이 갑니다:
   - 'selectmode'에 "mouse"가 있다면, 마우스로 내용을 선택하세요.
   - 'selectmode'에 "key"가 있다면, 시프트 키를 누른 채로 커서를 움직이는
     출력 불가능한 문자 명령을 사용하세요.
   - 'selectmode'에 "cmd"가 있다면 "v"나 "V", "<code class="keystroke">CTRL-V</code>"를 사용하세요.
   - "gh"나 "gH", "g <code class="keystroke">CTRL-H</code>"를 사용하세요. |<code class="badlink">g_CTRL-H</code>|
*5 시프트 키를 뗀 후에 커서를 움직이는 출력 불가능한 문자 명령을 사용하면 선택
   모드에서 보통 모드로 갑니다.
*6 출력 가능한 문자를 입력하면 선택 모드에서 입력 모드로 갑니다.  선택된
   부분은 지워지고, 입력한 문자가 들어갑니다.

만약 'insertmode' 옵션이 켜져있다면, 파일 편집이 입력 모드에서 시작됩니다.

	<b class="vimtag">*<a name="CTRL-\_CTRL-N">CTRL-\_CTRL-N</a>*</b> <b class="vimtag">*<a name="i_CTRL-\_CTRL-N">i_CTRL-\_CTRL-N</a>*</b> <b class="vimtag">*<a name="c_CTRL-\_CTRL-N">c_CTRL-\_CTRL-N</a>*</b> <b class="vimtag">*<a name="v_CTRL-\_CTRL-N">v_CTRL-\_CTRL-N</a>*</b>
추가로, 어떤 모드에서든 CTRL-\ <code class="keystroke">CTRL-N</code> 혹은 <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-N&gt;</code>을 누르면 보통 모드로
갑니다.  이 명령으로 Vim이 무조건 보통 모드로 가게 만들 수 있습니다.
<code class="special">&lt;Esc&gt;</code>처럼 삑삑 대는 일 없이요.  하지만, Ex 모드에서는 동작하지 않습니다.  또한
|<code class="badlink">f</code>|나 |<code class="badlink">m</code>| 같이 인자가 필요한 명령 다음에 사용하면, 'ttimeoutlen'에 설정한
시간 제한이 적용됩니다.

	<b class="vimtag">*<a name="CTRL-\_CTRL-G">CTRL-\_CTRL-G</a>*</b> <b class="vimtag">*<a name="i_CTRL-\_CTRL-G">i_CTRL-\_CTRL-G</a>*</b> <b class="vimtag">*<a name="c_CTRL-\_CTRL-G">c_CTRL-\_CTRL-G</a>*</b> <b class="vimtag">*<a name="v_CTRL-\_CTRL-G">v_CTRL-\_CTRL-G</a>*</b>
'insertmode'가 설정되어있다면, CTRL-\ <code class="keystroke">CTRL-G</code> 혹은 <code class="special">&lt;C-\&gt;</code><code class="special">&lt;C-G&gt;</code> 명령으로 입력
모드로 갈 수 있습니다.  'insertmode'가 설정되어 있지 않다면 보통 모드로
갑니다.  Vim의 현재 모드를 모르는데 'insertmode'에 지정된 모드로 가야할 때
사용할 수 있습니다.

				    <b class="vimtag">*<a name="Q">Q</a>*</b> <b class="vimtag">*<a name="mode-Ex">mode-Ex</a>*</b> <b class="vimtag">*<a name="Ex-mode">Ex-mode</a>*</b> <b class="vimtag">*<a name="Ex">Ex</a>*</b> <b class="vimtag">*<a name="EX">EX</a>*</b> <b class="vimtag">*<a name="E501">E501</a>*</b>
Q			"Ex" 모드로 갑니다.  이 모드는 ":" 명령을 연속적으로
			입력하는 것과 비슷한데요.  다른 점은:

			- ":"를 계속 입력할 필요가 없습니다.
			- 각 명령 후 바뀐 내용이 화면에 반영되지 않습니다.
			- 일반적인 명령줄 편집이 불가능합니다.
			- 매핑과 약어를 쓸 수 없습니다.
			실제로는 "표준" 줄 편집 명령들(<code class="special">&lt;Del&gt;</code>이나 <code class="special">&lt;BS&gt;</code>로
			지우기, <code class="keystroke">CTRL-U</code>로 전체 줄 지우기 등)로 입력을 하게
			됩니다.
			셸 프롬프트에서 "ex"로 Vim을 실행시키면 이 모드로
			들어옵니다.
			"Ex" 모드를 빠져나가려면 ":vi" 명령|<code class="badlink">:visual</code>|을
			사용하세요.
			<code class="note">Note:</code> Vim의 과거 버전에서는 "Q"가 내용 서식 맞추기
			명령이었습니다.  이제는 |<code class="badlink">gq</code>|로 바뀌었습니다.  하지만
			|<a href="usr_05.html#vimrc_example.vim">vimrc_example.vim</a>| 스크립트를 사용한다면 "Q"가 "gq"로
			동작할 것입니다.

					<b class="vimtag">*<a name="gQ">gQ</a>*</b>
gQ			"Q"와 마찬가지로 "Ex" 모드로 들어갑니다.  하지만 이
			때는 진짜로 ":" 명령을 연이어 입력하는 것처럼
			동작합니다.  모든 명령줄 편집 기능과 자동 완성 등을 쓸
			수 있습니다.
			"Ex" 모드를 빠져나가려면 ":vi" 명령|<code class="badlink">:visual</code>|을
			사용하세요.
			<code class="special">{not in Vi}</code>

</pre><hr><pre>7. 화면 내용						<b class="vimtag">*<a name="window-contents">window-contents</a>*</b>

보통 모드와 입력/바꾸기 모드에서는 버퍼의 현재 내용이 화면에 나옵니다.  화면에
표시된 것이 바로 결과물입니다(WYSIWYG).  다만 두 가지 예외가 있습니다.
- 'cpoptions' 옵션에 '$'가 있고 변경한 내용이 한 줄 안에 들어있다면, 내용이
  바로 지워지지 않습니다.  대신 마지막으로 지운 문자 위치에 '$'가 표시됩니다.
- 한 창에 내용을 입력할 때, 다른 창에 같은 내용이 열려있어도 입력이 끝날
  때까지 바로 반영되지 않습니다.
<code class="special">{Vi: 느린 터미널에서는 화면에 언제나 반영되지는 않습니다}</code>

창 폭보다 긴 줄은 'wrap' 옵션이 꺼져있지 않다면, 다음 줄로 넘어가서 표시
됩니다(아래를 보세요).  'linebreak' 옵션으로 공백 문자에서 줄이 넘어가도록 할
수 있습니다.

창에서 버퍼의 마지막 줄 다음에 공간이 남으면, Vim은 남은 공간의 첫 번째 칸에
'~'를 표시합니다.  다음과 같이요:

	+-----------------------+
	|<code class="badlink">내용			</code>|
	|<code class="badlink">마지막 줄		</code>|
	|<code class="badlink">~			</code>|
	|<code class="badlink">~			</code>|
	+-----------------------+

따라서 '~' 줄은 버퍼의 끝에 도달했다는 표시입니다.

만약 마지막 줄이 창에 표시할 수 없는 길이이면, Vim은 마지막 줄의 첫 번째 칸에
"@"를 표시합니다.  다음과 같습니다:

	+-----------------------+
	|<code class="badlink">첫 번째 줄		</code>|
	|<code class="badlink">두 번째 줄		</code>|
	|<code class="badlink">@			</code>|
	|<code class="badlink">@			</code>|
	+-----------------------+

따라서 '@' 줄은 창에 다 들어가지 않는 줄이 있다는 것을 나타냅니다.

'display' 옵션에 "lastline" 플래그가 있다면, 창의 왼쪽 끝에 '@'가 표시 되지
않습니다.  마지막 줄이 창에 완전히 들어가지 않으면, 일단 들어가는 부분만
표시한 후, 마지막 줄의 화면 끝 세 칸에 "@@@"를 다음과 같이 표시합니다:

	+-----------------------+
	|<code class="badlink">첫 번째 줄		</code>|
	|<code class="badlink">두 번째 줄		</code>|
	|<code class="badlink">화면에 다 들어가지 않는</code>|
	|<code class="badlink">매우매우 긴 줄이 있 @@@</code>|
	+-----------------------+

딱 한 줄짜리 버퍼인데, 이 줄이 엄청 길어서 화면에 들어가지 않는 경우는
어떨까요?  Vim은 현재 커서 위치 주위의 일부만을 보여줍니다.  줄 전체를 편집할
수 있도록 특수 문자는 표시되지 않습니다.
<code class="special">{Vi: 창에 들어가지 않는 줄에 대해서는 "internal error"가 발생합니다}</code>

'highlight' 옵션에 '@'가 있으면 '@'와 '~' 문자에 특별한 강조가 생깁니다.
강조가 되면 버퍼에 있는 진짜 문자와 구분할 수 있겠지요.

'showbreak' 옵션은 넘어간 줄의 맨 앞에 넣을 문자열을 지정합니다.

							<b class="vimtag">*<a name="wrap-off">wrap-off</a>*</b>
만약 'wrap' 옵션이 꺼져있다면, 긴 줄이 넘어가서 표시되지 않습니다.  화면에
들어가는 부분까지만 표시되지요.  만약 커서를 화면에 표시되지 않은 부분으로
움직이면, 화면이 좌우로 스크롤 됩니다.  이 방법의 장점은 실제 열에 맞게 화면에
표시되고, 화면에 들어가지 않는 긴 줄을 편집할 수 있다는 것입니다.  단점은 줄
전체의 내용을 한 번에 볼 수 없다는 것이지요.  'sidescroll' 옵션으로 스크롤
되는 최소 칸 단위를 설정할 수 있습니다.  <code class="special">{Vi: Vi에는 'wrap'옵션이 없습니다}</code>

모든 일반 아스키 문자가 화면에 바로 표시됩니다.  <code class="special">&lt;Tab&gt;</code>은 탭이 가리키는 크기의
공백으로 바뀌어 표시됩니다.  다른 출력 불가능한 문자는 문자 값에 64를 더한
문자를 <code class="special">{char}</code>라 하면, "^<code class="special">{char}</code>"로 표시됩니다.  따라서 7의 값을 갖는 문자(벨)는
"^G"로 표시됩니다.  127에서 160 사이의 문자는 문자 값에서 64를 뺀 문자를
<code class="special">{char}</code>라 하면, "~<code class="special">{char}</code>"로 표시됩니다.  이 문자들은 화면에서 한 칸 이상을
차지합니다.  이 경우 커서는 이 중 첫 번째 칸에만 올 수 있습니다.

'number' 옵션을 켜면, 모든 줄 앞에 줄 번호가 붙습니다.  팁: 줄 번호와 길어서
넘어간 줄이 섞이는 것이 보기 싫다면, 'showbreak' 옵션을 공백 여덟 개로
설정하세요:
	":set showbreak=\ \ \ \ \ \ \ \ "

'list' 옵션을 켜면, <code class="special">&lt;Tab&gt;</code> 문자는 공백 여러 개로 표시되지 않고, "^I"로 나올
것입니다.  줄의 끝에는 '$'가 표시되므로 줄 끝에 달려있는 공백을 찾을 수
있습니다.

명령줄 모드에서는 오직 명령줄 자체의 내용만 정확하게 표시됩니다.  버퍼의
내용은 다시 명령 모드(보통 모드)로 돌아가면서 갱신됩니다.

창의 맨 밑 줄은 상태와 다른 메시지 표시에 쓰입니다.  상태 메시지는 해당 옵션이
켜져있을 때만 표시됩니다.

<code class="section">상태 메시지			옵션	     기본 값	유닉스 기본 값	</code>
현재 모드			'showmode'	켜짐	    켜짐
명령 문자			'showcmd'	켜짐	    꺼짐
커서 위치			'ruler'		꺼짐	    꺼짐

현재 모드는 "-- 끼워넣기 --"나 "-- 바꾸기 --" 같은 것입니다.  |<code class="badlink">'showmode'</code>|를
참고하세요.  명령 문자는 입력은 되었지만 아직 사용되지 않은 문자들입니다.
<code class="special">{Vi: 명령 문자나 커서 위치를 보여주지 않습니다}</code>

느린 터미널을 사용한다면, 상태 메시지를 꺼서 편집 속도를 높일 수 있습니다:
	:set nosc noru nosm

에러가 발생하면, 에러 메시지가 최소 1초간 (역상으로) 표시됩니다.  {Vi: 다른
메시지에 덮어 쓰여서 에러 메시지가 읽기도 전에 지나가버릴 수 있습니다}

몇 가지 명령은 몇 개의 줄을 바꿨는지 알려줍니다.  몇 줄 이상을 바꿨을 때 이를
알려줄지는 'report' 옵션으로 조정할 수 있습니다(기본 값은 2).

Amiga에서는 Vim이 CLI 창에서 동작합니다.  Vim이라는 이름과 현재 파일의 전체
이름이 제목 바에 표시됩니다.  창 크기바 바뀌면, Vim이 알아서 창을 다시
그립니다.  창은 원하는 대로 작게 만들 수 있지만, 너무 작으면 그 안에 한 줄도
채 들어가지 않겠지요.  폭이 최소 40칸은 되게 해야 마지막 줄에 표시되는
메시지를 대부분 읽을 수 있을 겁니다.

대부분의 유닉스 환경에서, 창 크기를 바꾸어도 Vim이 잘 인식하고 정확하게
처리합니다.  <code class="special">{Vi: 문제가 좀 있습니다}</code>

</pre><hr><pre>8. 용어 정의						<b class="vimtag">*<a name="definitions">definitions</a>*</b>

  화면(screen)		Vim이 사용하는 전체 영역.  터미널 에뮬레이터 창일 수
			있습니다.  "Vim 창"이라고도 부릅니다.
  창(window)		버퍼가 표시되는 영역.

화면에는 하나 이상의 창이 들어갑니다.  각 창은 상태 줄로 구분되고, 화면의 맨
밑에 명령 줄이 있습니다.

	+-------------------------------+
화면	|<code class="badlink"> 창 1		</code>| 창 2		|
	|<code class="badlink">		</code>|		|
	|<code class="badlink">		</code>|		|
	|<code class="badlink">= 상태 줄 =====</code>|= 상태 줄 =====|
	|<code class="badlink"> 창 3				</code>|
	|<code class="badlink">				</code>|
	|<code class="badlink">				</code>|
	|<code class="badlink">==== 상태 줄 ==================</code>|
	|<code class="badlink">명령 줄			</code>|
	+-------------------------------+

명령 줄은 메시지 표시에도 쓰입니다.  명령 줄에 충분한 공간이 없으면 화면이
스크롤 됩니다.

다음 네 가지 줄의 차이를 확인해보세요:

  버퍼 줄		버퍼 안의 줄.  파일에서 읽고 쓸 때의 줄과 같습니다.
  (buffer lines)	한 줄 안에 수천 개의 글자가 있을 수도 있습니다.
  논리 줄		폴드를 적용한 상태의 버퍼 줄.  접힌 폴드 안의 버퍼
  (logical lines)	줄들은 "+-- 99 줄 접힘"과 같이 하나의 논리 줄로
			바뀝니다.  역시 수천 개의 글자가 있을 수 있습니다.
  창 줄			창에 표시되는 줄.  줄 넘김 등을 적용한 논리 줄의 일부.
  (window lines)	창의 폭이 허용하는 만큼만 길어질 수 있습니다.  보다 긴
			줄은 다음 줄로 넘어가거나 잘립니다.
  화면 줄		Vim이 사용하는 화면의 줄.  모든 창들의 창 줄들과 상태
  (screen lines)	줄, 명령 줄들로 구성됩니다.  화면 폭이 허용하는 만큼만
			길어질 수 있습니다.  명령이 너무 길어져서 명령 줄에
			들어가지 않게 되면, 줄이 넘어가면서 명령줄이
			스크롤되어 공간이 생깁니다.

<code class="section">버퍼 줄		논리 줄		창 줄		화면 줄 </code>

1. 하나		1. 하나		1. +-- 접힘     1.  +-- 접힘
2. 둘		2. +-- 접힘	2. 다섯		2.  다섯
3. 셋		3. 다섯		3. 여섯		3.  여섯
4. 넷		4. 여섯		4. 일곱		4.  일곱
5. 다섯		5. 일곱				5.  === 상태 줄 ===
6. 여섯						6.  ㄱㄱㄱ
7. 일곱						7.  ㄴㄴㄴ
						8.  ㄷㄷㄷ ㄷㄷ
1. ㄱㄱㄱ	1. ㄱㄱㄱ	1. ㄱㄱㄱ	9.  ㄷㄷ
2. ㄴㄴㄴ	2. ㄴㄴㄴ	2. ㄴㄴㄴ	10. ㄹㄹㄹ
<code class="section">3. ㄷㄷㄷ  ㄷㄷ	3. ㄷㄷㄷ  ㄷㄷ	3. ㄷㄷㄷ  ㄷㄷ	11. </code>
4. ㄹㄹㄹ	4. ㄹㄹㄹ	4. ㄷㄷ		12. === 상태 줄 ===
				5. ㄹㄹㄹ	13. (명령 줄)
<code class="section">				6. </code>

</pre><hr><pre> vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2013. 12. 14. (토) 19:53:58 KST</i></p>
</body>
</html>
