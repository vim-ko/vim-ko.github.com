<!DOCTYPE html>
<html>
<head>
<title>VIM: usr_42</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>USR_42</h2>
<pre>
<b class="vimtag">*<a name="usr_42.txt">usr_42.txt</a>*</b>	Vim version 7.4 대상.  새로 고침: 2008년 5월 5일

		      VIM 사용설명서 - Bram Moolenaar 저
				       정지용 역

			       새 메뉴 추가하기


지금까지 보면서 Vim이 매우 유연하다는 걸 아셨을 겁니다.  GUI에서 사용하는
메뉴도 마찬가지입니다.  특정 명령을 쉽게 사용하기 위해 자신만의 메뉴 항목을
정의할 수 있습니다.  마우스를 즐겨 쓰는 분들을 위한 내용입니다.

|<a href="usr_42.html#42.1">42.1</a>|	소개
|<a href="usr_42.html#42.2">42.2</a>|	메뉴 명령
|<a href="usr_42.html#42.3">42.3</a>|	기타
|<a href="usr_42.html#42.4">42.4</a>|	도구막대와 팝업 메뉴

다음 장: |<a href="usr_43.html#usr_43.txt">usr_43</a>|  파일 형식 플러그인 사용하기
이전 장: |<a href="usr_41.html#usr_41.txt">usr_41</a>|  Vim 스크립트 만들기
   차례: |<a href="usr_toc.html#usr_toc.txt">usr_toc</a>|

</pre><hr><pre><b class="vimtag">*<a name="42.1">42.1</a>*</b>	소개

Vim이 사용하는 메뉴는 "$VIMRUNTIME/menu.vim"에 정의되어있습니다.  자신만의
메뉴를 만들고 싶다면, 이 파일을 먼저 보는 것이 좋을 겁니다.
   메뉴를 정의하려면 ":menu" 명령을 사용하세요.  이 명령의 기본형은 다음과
같습니다:
<code class="example"></code>
<code class="example">	:menu <code class="special">{menu-item}</code> <code class="special">{keys}</code></code>
<code class="example"></code>
<code class="special">{menu-item}</code>은 메뉴의 어느 곳에 항목을 넣을 지를 지정합니다.  전형적인
<code class="special">{menu-item}</code>은 "File.Save"과 같은 형태입니다.  "File" 메뉴 밑에 있는 "Save"
항목을 가리킵니다.  이름들 사이에 마침표를 넣어서 표시합니다.  예:
<code class="example"></code>
<code class="example">	:menu File.Save  :update<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
":update"는 변경된 사항을 저장하는 명령입니다.
   단계를 더 추가할 수도 있습니다.  "Edit.Settings.Shiftwidth"는 "Edit" 메뉴
밑에 "Settings" 하위 메뉴를 정의하고, 그 안에 "Shiftwidth" 항목을 넣습니다.
더 깊은 단계도 추가할 수 있습니다.  하지만 너무 많은 단계를 만들어서 사용할
때마다 마우스를 한참 움직여야하도록 만들지는 마세요.
   ":menu" 명령은 ":map" 명령과 비슷합니다.  왼편에 이 항목이 어떻게
작동되는지를 쓰고, 오른편에 실행되는 문자들을 씁니다.  <code class="special">{keys}</code>에 있는 문자들은
사용자가 직접 입력한 것처럼 실행됩니다.  입력 모드에 있고, <code class="special">{keys}</code>가 단순
문자열이라면, 문자열이 그대로 입력됩니다.


단축키
------

앰퍼샌드 문자(&amp;)로 단축키를 지정합니다.  예를 들어, Alt-F로 "File"을 선택한
후, S로 "Save"를 선택할 수 있습니다.  ('winaltkeys' 옵션으로 이 기능이
꺼져있을 수 있습니다!)  이때 <code class="special">{menu-item}</code>은 "&amp;File.&amp;Save"와 같습니다.
메뉴에서 단축키 문자에는 밑줄이 표시됩니다.
   각 메뉴에서 특정 키가 한번만 사용되도록 신경써주세요.  아니면 둘 중 어떤
것이 사용될지 알 수 없습니다.  Vim은 여기에 대해서 따로 경고하지 않습니다.


우선순위
--------

실제 File.Save 메뉴 항목의 정의는 다음과 같습니다:
<code class="example"></code>
<code class="example">	:menu 10.340 &amp;File.&amp;Save<code class="special">&lt;Tab&gt;</code>:w  :confirm w<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
숫자 10.340 부분을 우선순위 숫자(priority number)라고 부릅니다.  우선순위
숫자는 메뉴 항목을 배열하는데 사용됩니다.  첫 번째 숫자(10)는 메뉴 바에서의
위치를 나타냅니다.  낮은 숫자가 왼쪽에, 높은 숫자는 오른쪽에 표시됩니다.
   아래 숫자들은 기본 메뉴들에 사용되는 우선순위 숫자입니다:

	  10	20     40     50      60       70		9999

	+------------------------------------------------------------+
	|<code class="badlink"> File	Edit  Tools  Syntax  Buffers  Window		Help </code>|
	+------------------------------------------------------------+

Help 메뉴는 맨 오른 쪽에 나타나도록 매우 큰 수를 지정했습니다.
   두 번째 숫자(340)는 풀다운 메뉴에서의 위치를 지정합니다.  낮은 숫자가
위쪽에, 높은 숫자가 아래쪽에 표시됩니다.  File 메뉴의 우선순위 숫자들을
봅시다:

			+-----------------+
	    10.310	|<code class="badlink">Open...	  </code>|
	    10.320	|<code class="badlink">Split-Open...	  </code>|
	    10.325	|<code class="badlink">New		  </code>|
	    10.330	|<code class="badlink">Close		  </code>|
	    10.335	|<code class="badlink">---------------- </code>|
	    10.340	|<code class="badlink">Save		  </code>|
	    10.350	|<code class="badlink">Save As...	  </code>|
	    10.400	|<code class="badlink">---------------- </code>|
	    10.410	|<code class="badlink">Split Diff with  </code>|
	    10.420	|<code class="badlink">Split Patched By </code>|
	    10.500	|<code class="badlink">---------------- </code>|
	    10.510	|<code class="badlink">Print		  </code>|
	    10.600	|<code class="badlink">---------------- </code>|
	    10.610	|<code class="badlink">Save-Exit	  </code>|
	    10.620	|<code class="badlink">Exit		  </code>|
			+-----------------+

각 숫자가 조금씩 떨어져있는 것을 볼 수 있습니다.  이는 정말로 원하는 경우 그
사이에 메뉴를 추가할 수 있도록 해놓은 것입니다(보통은 기본 메뉴는 그대로
놔두고, 추가하는 항목들을 위한 메뉴를 별도로 만드는 것이 좋습니다).
   하위메뉴를 만들 때, 우선순위 숫자에 ".숫자" 를 더 추가할 수 있습니다.
<code class="special">{menu-item}</code>에 있는 각 이름마다 우선순위 숫자를 갖도록 말이지요.


특수 문자
---------

위 예에서 <code class="special">{menu-item}</code>은 "&amp;File.&amp;Save<code class="special">&lt;Tab&gt;</code>:w"입니다.  여기서 중요한 점을 깨달을
수 있는데요.  바로 <code class="special">{menu-item}</code>에는 공백이 들어갈 수 없다는 것입니다.  만약
이름에 마침표나 공백, 탭을 넣고 싶다면, <code class="special">&lt;&gt;</code> 표기법(예를 들어 <code class="special">&lt;Space&gt;</code>나 <code class="special">&lt;Tab&gt;</code>)을
사용하거나, 백슬래시(\)를 써서 이스케이프 시켜야 합니다.
<code class="example"></code>
<code class="example">	:menu 10.305 &amp;File.&amp;Do\ It\.\.\. :exit<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
위 예에서 메뉴 항목의 이름은 "Do It..."으로 공백을 포함하고 있습니다.
수행하는 명령은 ":exit<code class="special">&lt;CR&gt;</code>"입니다.

메뉴 이름에서 <code class="special">&lt;Tab&gt;</code>문자는 실제 메뉴 이름과 사용자에게 표시되는 힌트를 구분하기
위해 사용합니다.  <code class="special">&lt;Tab&gt;</code> 이후의 부분은 메뉴에서 오른쪽 정렬되어 나타납니다.
File.Save 메뉴에서 사용한 이름은 "&amp;File.&amp;Save<code class="special">&lt;Tab&gt;</code>:w"인데요.  메뉴 이름은
"File.Save", 힌트는 ":w"가 됩니다.


구분선
------

연관된 항목들을 구분하기 위해 사용하는 구분선은 '-'로 시작하고 끝나는 이름을
사용해서 만들 수 있습니다.  예를 들어 "-sep-"과 같이 쓰면 됩니다.  구분선이
여러 개이면 각각의 이름이 달라야 합니다.  이름은 어떤 것이든 상관없습니다.
   구분선에 해당되는 명령은 절대 실행되지 않겠지만, 그래도 무엇인가 입력은
해야 합니다.  그냥 콜론 하나를 쓰면 됩니다.  예:
<code class="example"></code>
<code class="example">	:amenu 20.510 Edit.-sep3- :</code>
<code class="example"></code>
</pre><hr><pre><b class="vimtag">*<a name="42.2">42.2</a>*</b>	메뉴 명령

일부 모드에서만 존재하는 메뉴를 정의할 수 있습니다.  ":map" 명령의 변종들과
같은 방식으로 동작합니다:

	:menu		보통 모드, 시각 모드, 오퍼레이터 대기 모드
	:nmenu		보통 모드
	:vmenu		시각 모드
	:omenu		오퍼레이터 대기 모드
	:menu!		입력 모드, 명령줄 모드
	:imenu		입력 모드
	:cmenu		명령줄 모드
	:amenu		모든 모드

메뉴의 명령이 다시 매핑 되는 것을 막으려면 ":noremenu", ":nnoremenu",
":anoremenu" 등의 명령을 사용하십시오.


:AMENU 사용하기
---------------

":amenu" 명령은 다른 명령과 조금 다릅니다.  ":amenu"는 <code class="special">{keys}</code>에 지정한 것들을
보통 모드에서 실행합니다.  Vim이 시각 모드나 입력 모드에 있을 때 메뉴가
사용된다면, Vim은 먼저 보통 모드로 바뀝니다.  ":amenu"가 알아서 <code class="keystroke">CTRL-C</code>나
<code class="keystroke">CTRL-O</code>를 넣어주는 겁니다.  예를 들어, 다음 명령을 사용하면:
<code class="example"></code>
<code class="example">	:amenu  90.100 Mine.Find\ Word  *</code>
<code class="example"></code>
메뉴를 선택했을 때 실제로 실행되는 명령은 다음과 같습니다:

	보통 모드:		*
	시각 모드:		<code class="keystroke">CTRL-C</code> *
	오퍼레이터 대기 모드:	<code class="keystroke">CTRL-C</code> *
	입력 모드:		<code class="keystroke">CTRL-O</code> *
	명령줄 모드:		<code class="keystroke">CTRL-C</code> *

명령줄 모드에 있을 때는 <code class="keystroke">CTRL-C</code>로 인해 입력중인 명령이 지워질 것입니다.  시각
모드나 오퍼레이터 대기 모드였다면 <code class="keystroke">CTRL-C</code>로 인해 모드가 종료됩니다.  입력
모드에서 <code class="keystroke">CTRL-O</code>는 명령을 실행한 후 입력 모드로 돌아오게 해줍니다.
   <code class="keystroke">CTRL-O</code>는 명령 하나에 대해서만 잘 동작합니다.  둘 이상의 명령을
실행해야한다면, 명령들을 하나의 함수에 넣고 함수를 호출하세요.  예:
<code class="example"></code>
<code class="example">	:amenu  Mine.Next\ File  :call <code class="special">&lt;SID&gt;</code>NextFile()<code class="special">&lt;CR&gt;</code></code>
<code class="example">	:function <code class="special">&lt;SID&gt;</code>NextFile()</code>
<code class="example">	:  next</code>
<code class="example">	:  1/^코드</code>
<code class="example">	:endfunction</code>
<code class="example"></code>
이 메뉴 항목을 선택하면 ":next"로 인자 목록의 다음 파일로 갑니다.  그리고
"코드"로 시작하는 줄을 찾습니다.
   함수 이름 앞의 <code class="special">&lt;SID&gt;</code>는 스크립트 아이디입니다.  이를 통해 이 함수가 현재 Vim
스크립트 파일에서만 사용하도록 만들 수 있습니다.  다른 스크립트 파일에 같은
이름의 함수가 있을 경우 생기는 문제를 막아주지요.  |<code class="badlink">&lt;SID&gt;</code>|를 참고하세요.


침묵 메뉴
---------

메뉴는 <code class="special">{keys}</code>에 입력된 것을 키보드로 입력한 것처럼 실행합니다.  따라서 ":"
명령이라면 실행되는 명령이 명령줄에 그대로 나타나게 됩니다.  긴 명령이라면,
엔터를 입력하라는 프롬프트가 뜰 겁니다.  짜증나죠!
   이걸 없애려면, 메뉴를 침묵(silent) 메뉴로 만들면 됩니다.  <code class="special">&lt;silent&gt;</code> 인자로
할 수 있지요.  예를 들어, 이전 예에서의 NextFile() 함수 호출을 봅시다.  이
메뉴를 사용하면, 명령줄에 다음과 같이 나옵니다:

<code class="section">	:call <code class="special">&lt;SNR&gt;</code>34_NextFile() </code>

이 내용이 명령줄에 나오지 않게 하려면, 첫 번째 인자로 "<code class="special">&lt;silent&gt;</code>"를 넣으면
됩니다:
<code class="example"></code>
<code class="example">	:amenu <code class="special">&lt;silent&gt;</code> Mine.Next\ File :call <code class="special">&lt;SID&gt;</code>NextFile()<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
"<code class="special">&lt;silent&gt;</code>"를 너무 자주 사용하지는 마세요.  짧은 명령에는 필요가 없습니다.
다른 사람들이 쓰는 메뉴를 만든다면, 실행되는 명령을 보여줌으로써, 사용자가
마우스를 쓰는 대신 뭐라고 타자를 치면 되는지 알려줄 수 있을 겁니다.


메뉴 나열하기
-------------

menu 명령을 <code class="special">{keys}</code> 부분 없이 실행하면, 정의되어있는 메뉴들을 보여줍니다.
<code class="special">{menu-item}</code>이나 그 일부를 명시하면 특정 메뉴들만 나열할 수 있습니다.  예:
<code class="example"></code>
<code class="example">	:amenu</code>
<code class="example"></code>
모든 메뉴를 보여줍니다.  아주 깁니다!  짧은 목록을 얻으려면 메뉴 이름을
지정하는 게 좋겠지요:
<code class="example"></code>
<code class="example">	:amenu Edit</code>
<code class="example"></code>
이 명령은 모든 모드에서 "Edit" 메뉴 항목만을 보여줍니다.  입력 모드에서의 메뉴
항목 딱 하나만 보려면:
<code class="example"></code>
<code class="example">	:imenu Edit.Undo</code>
<code class="example"></code>
이름을 정확하게 입력해야 합니다.  여기서는 대소문자도 구별합니다.  단, 단축키
지정을 위한 '&amp;'는 생략할 수 있습니다.  <code class="special">&lt;Tab&gt;</code>과 그 뒤에 오는 내용도 마찬가지로
생략 가능합니다.


메뉴 삭제하기
-------------

메뉴를 지우려면, 메뉴를 나열할 때와 비슷하게 하되, "menu" 대신 "unmenu"를
사용하면 됩니다.  즉 ":menu"는 ":unmenu"가 되고, ":nmenu"는 ":nunmenu"가 되는
식입니다.  입력 모드에서 "Tools.Make" 항목을 지우려면:
<code class="example"></code>
<code class="example">	:iunmenu Tools.Make</code>
<code class="example"></code>
메뉴 이름을 써서 메뉴와 그 하위메뉴들까지 전부 지울 수도 있습니다.  예:
<code class="example"></code>
<code class="example">	:aunmenu Syntax</code>
<code class="example"></code>
이 명령은 Syntax 메뉴와 그 안의 모든 하위메뉴를 지웁니다.

</pre><hr><pre><b class="vimtag">*<a name="42.3">42.3</a>*</b>	기타

메뉴가 보이는 모습을 'guioptions'의 플래그들로 조정할 수 있습니다.  기본 값은
"M"을 제외한 모든 것을 포함한 것입니다.  아래 명령과 같이 플래그를 지울 수
있습니다:
<code class="example"></code>
<code class="example">	:set guioptions-=m</code>

	m		지우면 메뉴가 표시되지 않습니다.

	M		추가되면 기본 메뉴가 빠집니다.

	g		지우면 비활성화된 메뉴 항목이 회색으로 변하는 것이
			아니라 아예 사라집니다.  (모든 시스템에서 동작하지는
			않습니다.)

	t		지우면 떼어내기 기능이 비활성화 됩니다.

메뉴 맨 위의 점선은 구분선이 아닙니다.  이 항목을 선택하면, 메뉴는
"떼어내"져서, 별도의 창에 표시됩니다.  이를 떼어낸 메뉴(tearoff menu)라고
합니다.  한 메뉴를 자주 사용할 때 유용합니다.

메뉴를 번역하는 것에 대해서는 |<code class="badlink">:menutrans</code>|를 참고하세요.

메뉴를 선택하는데 이미 마우스를 사용해야하므로, 파일을 선택할 때는 ":browse"
명령을 사용하는 것이 좋을 겁니다.  또, 예를 들어 현재 버퍼에 변경사항이
있다거나 할 때 에러 메시지를 쓰는 것 보다는 ":confirm"으로 대화상자를 사용하면
좋습니다.  둘을 조합할 수도 있습니다:
<code class="example"></code>
<code class="example">	:amenu File.Open  :browse confirm edit<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
":browse"로 편집할 파일을 고를 파일 탐색기를 엽니다.  ":confirm"은 현재 버퍼에
변경 사항이 있을 경우 대화상자를 띄웁니다.  그러면 변경 사항을 저장할지,
무시할지 아니면 명령을 취소할지 선택할 수 있게 됩니다.
   보다 복잡한 경우에는 confirm()과 inputdialog() 함수를 쓰면 됩니다.  기본
메뉴에 몇 가지 예가 있습니다.

</pre><hr><pre><b class="vimtag">*<a name="42.4">42.4</a>*</b>	도구막대와 팝업 메뉴

두 가지 특별한 메뉴가 있습니다.  도구막대(ToolBar)와 팝업(PopUp) 메뉴입니다.
ToolBar와 PopUp으로 시작하는 메뉴는 일반 메뉴에는 나타나지 않습니다.


도구막대
--------

도구막대는 'guioptions' 옵션에 "T" 플래그가 포함되어있을 때만 나타납니다.
   도구막대는 명령을 나타내기 위해 문자가 아니라 아이콘을 사용합니다.  예를
들어 <code class="special">{menu-item}</code>이 "ToolBar.New"이면 도구막대에 "New" 아이콘을 표시합니다.
   Vim에는 28개의 아이콘이 내장되어있습니다.  |<code class="badlink">builtin-tools</code>|에서 표를
확인해보세요.  대부분은 기본 도구막대에서 사용됩니다.  이 항목들이 하는 일을
재정의할 수도 있습니다(기본 메뉴가 모두 만들어진 다음에요).
   도구막대 항목을 위해 비트맵을 추가할 수도 있습니다.  아니면 비트맵과 함께
새로운 도구막대 항목을 추가할 수도 있습니다.  예를 들어 다음과 같이 새로운
도구막대 항목을 정의해봅시다:
<code class="example"></code>
<code class="example">	:tmenu ToolBar.Compile  현재 파일을 컴파일</code>
<code class="example">	:amenu ToolBar.Compile  :!cc % -o %:r<code class="special">&lt;CR&gt;</code></code>
<code class="example"></code>
이제 아이콘을 만들어야 합니다.  마이크로소프트 윈도에서는 비트맵(bitmap)
형식이고 파일명은 "Compile.bmp"여야 합니다.  유닉스라면 XPM 포맷이어야 하고,
파일명은 "Compile.xpm"입니다.  이미지 크기는 18x18 픽셀이어야 합니다.
마이크로소프트 윈도에서는 다른 사이즈도 사용할 수 있긴 합니다만 이상하게 보일
겁니다.
   비트맵 파일을 'runtimepath'의 디렉터리 중 하나의 "bitmaps" 디렉터리에
넣으세요.  예를 들어 유닉스라면 "~/.vim/bitmaps/Compile.xpm"입니다.

도구막대의 항목에 대해 툴팁을 정의할 수 있습니다.  툴팁(tooltip)은 도구막대의
항목이 어떤 일을 하는 지에 대한 짧은 설명입니다.  예를 들어 "파일 열기"같은
것이지요.  마우스 포인터를 항목 위에 올린 채 잠시 그대로 있으면 나타납니다.
아이콘 그림이 빤한 것이 아니라면 매우 유용합니다.  예:
<code class="example"></code>
<code class="example">	:tmenu ToolBar.Make  현재 디렉터리에서 make 실행</code>

	<code class="note">Note:</code>
	대소문자에 주의하세요.  "Toolbar"나 "toolbar"는 "ToolBar"와 다릅니다!

툴팁을 제거하려면 |<code class="badlink">:tunmenu</code>| 명령을 사용하세요.

'toolbar' 옵션에서 아이콘 이미지 대신 텍스트를 보여주거나 이미지와 텍스트를
모두 보여주도록 할 수 있습니다.  대부분은 텍스트가 공간을 꽤 차지하므로
이미지만 사용하겠지요.


팝업 메뉴
---------

팝업 메뉴는 마우스 포인터가 있는 곳에서 나타납니다.  마이크로소프트 윈도에서는
오른쪽 마우스 버튼을 클릭하여 활성화시킵니다.  그리고 원하는 항목을 왼쪽
마우스 버튼으로 선택합니다.  유닉스에서는 오른쪽 마우스를 누르고 유지하는
방식으로 팝업 메뉴를 사용합니다.
   팝업 메뉴는 'mousemodel'이 "popup"이나 "popup_setpos"일 때만 나타납니다.
둘 사이의 차이점은 "popup_setpos"가 마우스 포인터의 위치로 커서를 이동시킨다는
것입니다.  선택 영역 안을 클릭하면 선택 영역이 그대로 유지됩니다.  선택 영역
바깥을 클릭하면 선택한 것이 없어집니다.
   각 모드 별로 별개의 팝업 메뉴가 있습니다.  따라서 일반 메뉴와 같이 회색인
항목이 없습니다.

삶, 우주 그리고 모든 것에 대한 궁극적 질문의 해답은?  <b class="vimtag">*<a name="42">42</a>*</b>
불행히도, 이 질문이 진정 무엇에 관한 것이었는지 아는 유일한 사람이었던
더글러스 애덤스(Douglas Adams, <code class="special">&lt;은하수를 여행하는 히치하이커를 위한 안내서&gt;</code>의
저자)는 이미 세상을 떠났습니다.  이제는 죽음의 의미가 무엇인지 궁금하겠지요...

</pre><hr><pre>
다음 장: |<a href="usr_43.html#usr_43.txt">usr_43</a>|  파일 형식 플러그인 사용하기

저작권: |<a href="usr_01.html#manual-copyright">manual-copyright</a>| 참고  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2013. 12. 14. (토) 19:53:58 KST</i></p>
</body>
</html>
